<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MilkTeaAddicted</title>
  
  <subtitle>欢迎来到晓沐的主页</subtitle>
  <link href="http://sweetheart.huangtao.xyz/atom.xml" rel="self"/>
  
  <link href="http://sweetheart.huangtao.xyz/"/>
  <updated>2021-01-11T14:22:56.803Z</updated>
  <id>http://sweetheart.huangtao.xyz/</id>
  
  <author>
    <name>晓沐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css前端页面布局</title>
    <link href="http://sweetheart.huangtao.xyz/2021/01/02/css%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://sweetheart.huangtao.xyz/2021/01/02/css%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</id>
    <published>2021-01-02T10:38:03.000Z</published>
    <updated>2021-01-11T14:22:56.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css前端页面布局"><a href="#css前端页面布局" class="headerlink" title="css前端页面布局"></a>css前端页面布局</h1><p>前端三件套里面除了javascript之外，比较难学的就是css的页面布局操作，可以说css掌握好布局那么基本上就能写出一个一般通俗的静态页面了，其他都可以现学现抄</p><h2 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h2><p>浮动布局指：</p><ul><li>将元素排除在普通流之外</li><li>元素不在页面占据空间</li><li>将浮动元素放置在包含框的左右边</li><li>浮动元素依旧位于包含框之内</li></ul><p>浮动的框可以向左或者向右移动，直到外边缘碰到包含框或另一个浮动边框为止</p><ul><li>浮动元素的外边缘不会超过其父元素的内边缘</li><li>浮动元素不会相互重叠</li><li>浮动元素不会上下浮动</li><li>任何一个元素浮动，display属性完全失效，并且不会独占一行</li></ul><p>语法：</p><ul><li>float:none/left/right;</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #box&amp;#123;            width: 600px;            height: 600px;            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;box&quot;&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图如下:</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513261589626880.html?v=1610374614000"></p><p>倘若设置浮动：</p><pre><code class="css">    &lt;style&gt;        #box&amp;#123;            width: 600px;            height: 600px;            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513256077426688.html?v=1610374826000"></p><p>说明float碰到边缘停止，</p><p>打个比方，大的div外边框相当于七巧板的框</p><p>而不浮动的div相当于七巧板的框内花纹，而浮动的div相当于七巧板，碰到同样的七巧板或者边框就停止</p><p>原有的行容不下div的时候，会自动到下一行找更大空间</p><p>覆盖关系由孩子关系决定</p><ul><li>div的本质属性是不设置宽度的时候独占一行，</li><li>span标签的特点是没有宽高属性，并且不会独占一行</li><li>如果设置了float，给无宽高属性的元素会生效宽高属性</li></ul><p>如果父元素没有设置宽高，而子元素有设置宽高，那么父元素会根据子元素调整自己的宽高属性</p><p>例如：</p><pre><code class="css">  &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            /* float: right; */        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            /* float: right; */        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下，说明:</p><ul><li>div的本质属性是不设置宽度的时候独占一行，<ul><li>所以父元素占了一整行</li><li>子元素虽然宽没有满行，但是依旧占了一整行，导致排成一列</li></ul></li><li>父div根据子div调整宽高</li></ul><p>如果给部分元素恢复浮动，如下：</p><pre><code class="css">    &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513241930924032.html?v=1610374864000"></p><p>那么说明在有浮动条件下div感受根据浮动调整，可以认为外边框是一个可伸缩的长方形边框</p><p>内部元素float的情况下，父亲感知不到内元素高度</p><p>解决方法：</p><ul><li><p>设置父元素宽高</p></li><li><p>父元素设置overflow:hidden;</p><p>如下：</p><pre><code class="css">  &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;            overflow: hidden;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;            float: right;        &amp;#125;    &lt;/style&gt;</code></pre><p>如下图所示：</p></li><li><p>父类设置浮动,兄弟元素清除浮动clear</p></li></ul><p>注意浮动是优先在行内操作</p><p>假设现在有一个div，宽度不比行内宽度小，所以不足以移到下一行，若想移到下一行，则要设置</p><pre><code class="css">clear:both;/*清除两边浮动*/</code></pre><p>这个可以抵消其他元素浮动对当前元素的影响</p><p>属性：clear</p><p>值：left,right,both</p><h2 id="头部布局以及font字体图标使用"><a href="#头部布局以及font字体图标使用" class="headerlink" title="头部布局以及font字体图标使用"></a>头部布局以及font字体图标使用</h2><p>网页布局的时候一般是先水平再垂直，头部布局一般适用于网页导航栏</p><p>这里先学习导航栏的布局：</p><p>html：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/style.css&quot;/&gt;        &lt;!-- 这里引入css文件 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>引入的css文件：</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    background: red;&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    background: green;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    background: aqua;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;&amp;#125;</code></pre><p>初步的效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513260343988224.html?v=1610374496000"></p><p>但是注意到由于div独占一行的原因</p><p>这里pink的div出来了，说明等待解决问题</p><p>利用上次学到的浮动属性，让pink和aqua在green里面浮动：</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    background: red;&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    background: green;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    background: aqua;    float: left;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;    float: right;&amp;#125;</code></pre><p>效果图如下：</p><p>​                                                               图丢了</p><p>这时首页头部的基本框架搭好了，取消父类容器颜色，并且加入子类文字：</p><p>html:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/style.css&quot;/&gt;        &lt;!-- 这里引入css文件 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                    &lt;div &gt;                        &lt;span &gt;                            我是头部                        &lt;/span&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>css:</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    /* background: red; */&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    /* background: green; */    border:1px solid #FF0000;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    /* background: aqua; 取消父类容器颜色*/    float: left;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;    float: right;&amp;#125;.header_left&gt;div&amp;#123;    float: left;    line-height: 40px;    color: dimgray;    /* 设置字体颜色，在父类中 */&amp;#125;.header_left&gt;div&gt;span&amp;#123;    font-weight: bold;    /* 设置字体加粗 */&amp;#125;</code></pre><p>效果如下</p><p>​                                                                            图又无了</p><p>设置超链接：</p><pre><code class="html">&lt;div &gt;    &lt;a href=&quot;&quot;&gt;        &lt;img src=&quot;&quot; alt=&quot;&quot; &gt;        核心产品        &lt;i&gt;&lt;/i&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><p>为了清除原有超链接丑不拉几的样式，css里面设置为</p><pre><code class="css">a&amp;#123;    text-decoration: none;&amp;#125;</code></pre><p>这样去掉了下划线的样式</p><p>然后设置添加图片</p><p>html:</p><pre><code class="html">&lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                    &lt;div &gt;                        &lt;span &gt;                            我是头部                        &lt;/span&gt;                    &lt;/div&gt;                    &lt;div &gt;                        &lt;a href=&quot;&quot;&gt;                            &lt;img src=&quot;./img/imag.png&quot; alt=&quot;&quot; &gt;                            核心产品                            &lt;i&gt;&lt;/i&gt;                        &lt;/a&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;</code></pre><p>css:</p><pre><code class="css">.header&gt;div:nth-child(2)&gt;a,.header_left&gt;div:nth-child(2)&gt;a&gt;img,.header_left&gt;div:nth-child(2)&gt;a&gt;i&amp;#123;    float: left;&amp;#125;.header_left&gt;div:nth-child(2)&gt;a&gt;img&amp;#123;    width: 17px;&amp;#125;</code></pre><p>这里全部设置为浮动布局，并且调整了图片大小如图：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513259392987136.html?v=1610374390000"></p><p>下面是给文字添加图标：</p><p>阿里图标库，找到想要的图标后</p><ul><li><p>点击加入购物车</p></li><li><p>点击购物车添加到项目</p></li><li><p>点击项目更新代码</p></li><li><p>复制更新后的链接，引入到页面的css的link，这样：</p><pre><code class="css">&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;//at.alicdn.com/t/font_2076021_pp0wtm9fh8j.css&quot;/&gt;</code></pre></li><li><p>复制好想要的图标的代码后，如下(注意复制好代码后再标注iconfont才能显示出来)：</p><pre><code class="html">&lt;div &gt;    &lt;a href=&quot;&quot;&gt;        &lt;img src=&quot;./img/imag.png&quot; alt=&quot;&quot; &gt;        核心产品        &lt;i class=&quot;icon-arrow-down iconfont&quot;&gt;&lt;/i&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre></li><li><p>取消i标签的浮动(不取消浮动i标签跑前面去)，并且修改超链接字体颜色：</p><p>去除样式的一篇参考blog:<a href="https://blog.csdn.net/hl_qianduan/article/details/84964511?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161037371816780266298133%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161037371816780266298133&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-84964511.pc_search_result_cache&utm_term=%E5%8E%BB%E9%99%A4%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F">去除css中的默认样式</a></p><pre><code class="css">.header&gt;div:nth-child(2)&gt;a,.header_left&gt;div:nth-child(2)&gt;a&gt;img,&amp;#123;    float: left;    color:dimgrey;&amp;#125;.header_left&gt;div:nth-child(2)&gt;a&gt;img&amp;#123;    width: 17px;&amp;#125; a&amp;#123;text-decoration: none;color:#333;&amp;#125; a:hover, a:visited, a:link, a:active &amp;#123;    color:dimgrey;    // 设置使所有a标签的四种状态都和本身颜色保持一致，样式代码自己写&amp;#125;</code></pre></li></ul><p>最终的效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513257500176384.html?v=1610374336000"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;css前端页面布局&quot;&gt;&lt;a href=&quot;#css前端页面布局&quot; class=&quot;headerlink&quot; title=&quot;css前端页面布局&quot;&gt;&lt;/a&gt;css前端页面布局&lt;/h1&gt;&lt;p&gt;前端三件套里面除了javascript之外，比较难学的就是css的页面布局操作，可以</summary>
      
    
    
    
    <category term="web" scheme="http://sweetheart.huangtao.xyz/categories/web/"/>
    
    <category term="前端" scheme="http://sweetheart.huangtao.xyz/categories/web/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://sweetheart.huangtao.xyz/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css" scheme="http://sweetheart.huangtao.xyz/tags/css/"/>
    
    <category term="html" scheme="http://sweetheart.huangtao.xyz/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>tensoflow基础</title>
    <link href="http://sweetheart.huangtao.xyz/2020/11/11/tensoflow%E5%9F%BA%E7%A1%80/"/>
    <id>http://sweetheart.huangtao.xyz/2020/11/11/tensoflow%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-11T09:57:31.000Z</published>
    <updated>2021-01-12T09:39:08.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tensorflow基础"><a href="#Tensorflow基础" class="headerlink" title="Tensorflow基础"></a>Tensorflow基础</h1><p>​    TensorFlow是现在比较火爆的一个深度学习的框架，内部集成了多种优化算法还有模型框架，所以对初学者十分友好，所以今天起开始自己的TensorFlow第一步</p><h2 id="训练自己的第一个神经网络"><a href="#训练自己的第一个神经网络" class="headerlink" title="训练自己的第一个神经网络"></a>训练自己的第一个神经网络</h2><p>代码如下</p><ul><li><p>第一次上手tensorflow结果发现憨憨的自己抄的代码是temsoflow1.0的版本</p><p>但是安装的tensorflow版本是2.1.3，在咨询了下csdn后在原代码的基础上做了下版本转换</p><p>然而只是试水了下而已，个人认为tensorflow2.0版本更加友好，更简洁，没有session这种操作，后面都会用tensorflow2.0版本实现,指导课程为北大</p></li></ul><pre><code class="python">import tensorflow.compat.v1 as tfimport numpy as nptf.disable_v2_behavior()# create datax_data = np.random.rand(100).astype(np.float32)##随机生成100个数据y_data = x_data * 0.1 + 0.3 #随机生成y# create tensorflow struct start 新建Weights = tf.Variable(tf.random_uniform((1,), -1.0, 1.0))#随机生成权重biases = tf.Variable(tf.zeros((1,)))#初始化Biasesy = Weights * x_data + biases#定义函数loss = tf.reduce_mean(tf.square(y - y_data))#根据均方根差进行梯度下降optimizer = tf.train.GradientDescentOptimizer(0.5)#梯度下降，设置学习率为0.5train = optimizer.minimize(loss)init = tf.initialize_all_variables()# 创建sessionsess = tf.Session()#session是一个对话控制，对sess.run(init)for step in range(201):#训练200轮    sess.run(train)    if step % 20 == 0:        print(step, sess.run(Weights), sess.run(biases), sess.run(loss))        ##每20轮输出一次训练后的权重还有偏差还有损失</code></pre><p>输出如下：</p><pre><code class="python">0 [-0.00268313] [0.5169402] 0.02760824420 [0.0633762] [0.32074773] 0.0001312771540 [0.09214579] [0.3044495] 6.037642e-0660 [0.0983156] [0.30095425] 2.7768752e-0780 [0.09963877] [0.30020466] 1.2771677e-08100 [0.09992254] [0.3000439] 5.874353e-10120 [0.09998339] [0.30000943] 2.7032572e-11140 [0.09999646] [0.300002] 1.2318857e-12160 [0.09999923] [0.30000046] 6.0014216e-14180 [0.09999982] [0.3000001] 3.7214676e-15200 [0.09999991] [0.30000007] 1.2079227e-15##可见训练次数越多</code></pre><p>进行线性回归预测</p><pre><code class="python">##懒得下数据集了，所以就自己生成了一个数据集##线性回归import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tfx_data = np.random.rand(100).astype(np.float32)y_data = x_data * 0.1 + 0.3  # 很显然这个是个非常明显的线性回归plt.scatter(x_data, y_data)    #绘制数据集的形状，是一个严格符合线性回归的散点图# 建立顺序模型model = tf.keras.Sequential()  # 实例化一个模型model.add(tf.keras.layers.Dense(1, input_shape=(1,)))#定义神经元的数目，由于输入的维度就一个就定义一个输入model.compile(    optimizer=&#39;adam&#39;, loss=&#39;mse&#39;)#选择优化算法，这里我们选择adam优化的梯度下降算法，基于均方根差model.fit(x_data,y_data,epochs=10)#对模型训练10轮print(model.predict(x_data))#这时训练结束，对输入X进行预测</code></pre><h2 id="神经网络计算"><a href="#神经网络计算" class="headerlink" title="神经网络计算"></a>神经网络计算</h2><h3 id="神经网络设计过程"><a href="#神经网络设计过程" class="headerlink" title="神经网络设计过程"></a>神经网络设计过程</h3><p>鸢尾花设计分类</p><p>Y=x*w+b 一般神经网络的设计过程</p><pre><code class="python">import tensorflow as tfw=tf.Variable(tf.constant(5,dtype=tf.float32))#设置w的随机初始值为5lr=0.2#学习率epoch=40#迭代次数for i in range(epoch):#在每一次的迭代中    with  tf.GradientTape() as tape:#执行梯度下降算法        loss=tf.square(w+1)#损失函数定义为loss=(w+1)^2    grads=tape.gradient(loss,w)#告知对w求偏导    w.assign_sub((lr*grads))#每次减去学习率乘上导数    print(&quot;在%s 次迭代后,w变为%f ,loss变为 %f&quot;%(epoch,w.numpy(),loss))</code></pre><p>结果如下：</p><p>在1 次迭代后,w变为2.600000 ,loss变为 36.000000<br>在2 次迭代后,w变为1.160000 ,loss变为 12.959999<br>在3 次迭代后,w变为0.296000 ,loss变为 4.665599<br>在4 次迭代后,w变为-0.222400 ,loss变为 1.679616<br>在5 次迭代后,w变为-0.533440 ,loss变为 0.604662<br>在6 次迭代后,w变为-0.720064 ,loss变为 0.217678<br>在7 次迭代后,w变为-0.832038 ,loss变为 0.078364<br>在8 次迭代后,w变为-0.899223 ,loss变为 0.028211<br>在9 次迭代后,w变为-0.939534 ,loss变为 0.010156<br>在10 次迭代后,w变为-0.963720 ,loss变为 0.003656<br>在11 次迭代后,w变为-0.978232 ,loss变为 0.001316<br>在12 次迭代后,w变为-0.986939 ,loss变为 0.000474<br>在13 次迭代后,w变为-0.992164 ,loss变为 0.000171<br>在14 次迭代后,w变为-0.995298 ,loss变为 0.000061<br>在15 次迭代后,w变为-0.997179 ,loss变为 0.000022<br>在16 次迭代后,w变为-0.998307 ,loss变为 0.000008<br>在17 次迭代后,w变为-0.998984 ,loss变为 0.000003<br>在18 次迭代后,w变为-0.999391 ,loss变为 0.000001<br>在19 次迭代后,w变为-0.999634 ,loss变为 0.000000<br>在20 次迭代后,w变为-0.999781 ,loss变为 0.000000<br>                                    …..</p><p>​                                    …..<br>在40 次迭代后,w变为-1.000000 ,loss变为 0.000000</p><p>多次改变学习率，发现结果不一样，</p><p>学习率过小时，40次loss都没达到0</p><p>学习率过大时也找不到</p><h3 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h3><h4 id="张量含义"><a href="#张量含义" class="headerlink" title="张量含义"></a>张量含义</h4><p>tensorflow中的tensor就是指张量的意思，多维数组和列表的意思</p><p>0-D的张量表示一个单独的数 1,2,3,4…..</p><p>1-D的张量表示一个向量 [1,2,3,4,…..]</p><p>2-D的张量表示一个矩阵[[1,2,3],[4,5,6],……]</p><p>3-D的张量表示一个立方，每一层是一个矩阵</p><p>[[[1,2,3],[3,4,5]],</p><p>[[8,9,0],[7,8,5]]]</p><p>n-D以此类推……</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>tf.int,tf.float…….</p><ul><li>tf.int32,tf.float32,tf.float64</li></ul></li><li><p>tf.bool</p><ul><li>tf.constant([True,False])</li></ul></li><li><p>tf.string</p><ul><li>tf.constant(“hollow”)</li></ul></li></ul><h4 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h4><p>直接创建：</p><pre><code class="python">import tensorflow as tfa=tf.constant([1,5],dtype=tf.int64)#实例化一个张量print(a)print(a.dtyppe)print(a.shape)</code></pre><p>numpy转换：</p><pre><code class="python">import tensorflow as tfimport numpy as npa=np.arange(0,5)b=tf.convert_to_tensor(a,dtype=tf.int64)#将numpy格式转换成tf张量格式print(a)print(b)#[0 1 2 3 4]#tf.Tensor([0 1 2 3 4], shape=(5,), dtype=int64)</code></pre><p>一维直接写个数，二维用行列，三维用[n,m,j,k,…..]</p><pre><code class="python">#tf.zreos(维度)#tf.fill(维度，指定值)#tf.ones(维度)a=tf.zeros([2,3])b=tf.fill([2,2],9)</code></pre><p>其他生成张量：</p><pre><code class="python">#tf.random.normal(维度，meaan=均值，stddv=标准差)#生成符合正态分布的张量#tf.random.truncated_normal(维度，均值，标准差)#生成截断式分布的随机数，保证生成数在2sitar之间a=tf.random.normal([2,2],mean=0.5,stddev=1)b=tf.random.truncated_normal([2,2],mean=0.5,stddev=1)#结果如下tf.Tensor([[ 1.1104964  -0.04805636] [ 0.00457174 -0.14143777]], shape=(2, 2), dtype=float32)tf.Tensor([[ 2.312311    1.8229972 ] [-0.07491392  0.20661339]], shape=(2, 2), dtype=float32)a=tf.random.uniform([2,2],minval=0,maxval=1)#生成平均分布的随机数print(a)#结果如下tf.Tensor([[0.33741152 0.5539886 ] [0.8860432  0.18990982]], shape=(2, 2), dtype=float32)</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="张量操作"><a href="#张量操作" class="headerlink" title="张量操作"></a>张量操作</h4><h5 id="tf-cast-tf-reduce"><a href="#tf-cast-tf-reduce" class="headerlink" title="tf.cast()/tf.reduce"></a>tf.cast()/tf.reduce</h5><pre><code class="python">tf.cast(a,dtype=iny64)#转换数据类型用tf.reduce_min(a)#计算张量上的最小值#同理tf.reduce_操作 还有其他的方法，</code></pre><p>轴axis:</p><p>axis=0:表示纵轴</p><p>axis=1:表示横轴，</p><p>则可用其表示求解均值还有最大值的方向</p><p>不指定axis时，对所有元素进行操作</p><pre><code class="python">x=tf.constant([[1,2,3],[2,2,3]])print(x)print(tf.reduce_mean(x))print(tf.reduce_mean(x,axis=1))#结果如下：tf.Tensor([[1 2 3] [2 2 3]], shape=(2, 3), dtype=int32)tf.Tensor(2, shape=(), dtype=int32)tf.Tensor([2 2], shape=(2,), dtype=int32)</code></pre><h5 id="tf-Variable"><a href="#tf-Variable" class="headerlink" title="tf.Variable"></a>tf.Variable</h5><p>tf.Variable将变量标记为可训练，被标记的变量会在反向传播中记录梯度信息，神经网络中，常用该函数标记待训练参数</p><p>tf.Variable(初始值)</p><pre><code class="python">w=tf.Variable(tf.random.normal([2,2],mean=0,stddev=1))</code></pre><h4 id="数学运算操作"><a href="#数学运算操作" class="headerlink" title="数学运算操作"></a>数学运算操作</h4><h5 id="四则运算函数"><a href="#四则运算函数" class="headerlink" title="四则运算函数"></a>四则运算函数</h5><pre><code class="python">x=tf.constant([[1,2],[2,5]])x=tf.cast(x,dtype=float)y=tf.random.normal([2,2],mean=1,stddev=0.5)print(x)print(y)print(tf.add(x,y))print(tf.subtract(x,y))print(tf.multiply(x,y))print(tf.divide(x,y))</code></pre><p>结果如下：</p><pre><code class="python">tf.Tensor([[1. 2.] [2. 5.]], shape=(2, 2), dtype=float32)tf.Tensor([[1.2040572  0.82556653] [0.49909478 1.6746361 ]], shape=(2, 2), dtype=float32)tf.Tensor([[2.2040572 2.8255665] [2.4990947 6.674636 ]], shape=(2, 2), dtype=float32)tf.Tensor([[-0.20405722  1.1744335 ] [ 1.5009053   3.3253639 ]], shape=(2, 2), dtype=float32)tf.Tensor([[1.2040572  1.6511331 ] [0.99818957 8.37318   ]], shape=(2, 2), dtype=float32)tf.Tensor([[0.83052534 2.4225788 ] [4.007255   2.9857233 ]], shape=(2, 2), dtype=float32)</code></pre><p>注意只有维度相同的张量才可以进行四则运算，所以是点乘点加，不是矩阵运算</p><h5 id="幂操作"><a href="#幂操作" class="headerlink" title="幂操作"></a>幂操作</h5><pre><code class="python">x=tf.constant([[1,2],[2,5]])x=tf.cast(x,dtype=float)print(x)print(tf.pow(x,3))print(tf.square(x))print(tf.sqrt(x))#结果如下：tf.Tensor([[1. 2.] [2. 5.]], shape=(2, 2), dtype=float32)tf.Tensor([[  1.   8.] [  8. 125.]], shape=(2, 2), dtype=float32)tf.Tensor([[ 1.  4.] [ 4. 25.]], shape=(2, 2), dtype=float32)tf.Tensor([[1.        1.4142135] [1.4142135 2.236068 ]], shape=(2, 2), dtype=float32)</code></pre><p>以上都是矩阵的点操作</p><h5 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h5><pre><code class="python">tf.matmul(矩阵1，矩阵2)</code></pre><p>要符合矩阵运算</p><h4 id="训练操作"><a href="#训练操作" class="headerlink" title="训练操作"></a>训练操作</h4><h5 id="特征与标签配对的函数"><a href="#特征与标签配对的函数" class="headerlink" title="特征与标签配对的函数"></a>特征与标签配对的函数</h5><pre><code class="python">data=tf.data.Dataset.from_tensor_slices((输入特征，标签))</code></pre><p>举例如下</p><pre><code class="python">features = tf.constant([12,23,10,17])labels = tf.constant([0,1,1,0])dataset= tf.data.Dataset.from_tensor_slices((features, labels))print(dataset)for element in dataset:    print(element)#结果如下&lt;TensorSliceDataset shapes: ((), ()), types: (tf.int32, tf.int32)&gt;(&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=23&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=10&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=17&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)</code></pre><h5 id="求取梯度"><a href="#求取梯度" class="headerlink" title="求取梯度"></a>求取梯度</h5><p>tf.GradientTape（）</p><pre><code class="python">with  tf.GradientTape() as tape:#执行梯度下降算法    w=tf.Variable(tf.constant(3.0))    loss=tf.square(w+1)#损失函数定义为loss=(w+1)^2grad=tape.gradient(loss,w)print(grad)#结果如下：tf.Tensor(8.0, shape=(), dtype=float32)</code></pre><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>enumerate是python内建的函数，可以遍历每个列表元素</p><p>组合为索引 元素</p><pre><code class="python">seq=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]for i,element in enumerate(seq):    print(i,element)</code></pre><h5 id="独热码"><a href="#独热码" class="headerlink" title="独热码"></a>独热码</h5><p>tf.one_hot 特征向量形式表示分类</p><p>tf.one_hot(待转换数据，depth=几分类)</p><pre><code class="python">classes=3label=tf.constant([1,0,2])output=tf.one_hot(label,depth=classes)print(output)#表示如下tf.Tensor([[0. 1. 0.] [1. 0. 0.] [0. 0. 1.]], shape=(3, 3), dtype=float32)</code></pre><h5 id="使符合概率分布"><a href="#使符合概率分布" class="headerlink" title="使符合概率分布"></a>使符合概率分布</h5><p>归一化处理：softmax()</p><p>让输出的每个分类的概率和为1</p><pre><code class="python">y=tf.constant([1.01,2.01,-0.66])y_pro=tf.nn.softmax(y)print(&quot;归一化处理后为：&quot;,y_pro)#归一化处理后为： tf.Tensor([0.25598174 0.69583046 0.04818781], shape=(3,), dtype=float32)</code></pre><h5 id="参数自更新"><a href="#参数自更新" class="headerlink" title="参数自更新"></a>参数自更新</h5><p>相当于c语言中的++或者–</p><pre><code class="python">w=tf.Variable(4)#标记为可训练才能更新w.assign_sub(1)print(w)#即w-1</code></pre><h5 id="返回索引"><a href="#返回索引" class="headerlink" title="返回索引"></a>返回索引</h5><p>tf.argmax(张量名，axis=操作轴)</p><pre><code class="python">test=np.array([[1,2,3],[2,3,4],[4,5,3],[8,7,2]])print(test)print(tf.argmax(test,axis=0))#纵向最大值索引print(tf.argmax(test,axis=1))#横向最大值索引#结果如下[[1 2 3] [2 3 4] [4 5 3] [8 7 2]]tf.Tensor([3 3 1], shape=(3,), dtype=int64)tf.Tensor([2 2 1 0], shape=(4,), dtype=int64)</code></pre><h3 id="鸢尾花数据集读入"><a href="#鸢尾花数据集读入" class="headerlink" title="鸢尾花数据集读入"></a>鸢尾花数据集读入</h3><p>通过sklearn中的dataset数据集引入</p><pre><code class="python">import tensorflow as tffrom sklearn import datasetsimport pandas as pdfrom  pandas import DataFramex_data=datasets.load_iris().data#.data 返回鸢尾花的输入特征y_data=datasets.load_iris().target#.target返回鸢尾花的所有标签print(&quot;x_data:\n&quot;,x_data)print(&quot;y_data:\n&quot;,y_data)x_data=DataFrame(x_data,columns=[&quot;花萼长&quot;,&quot;花萼宽&quot;,&quot;花瓣长&quot;,&quot;花瓣宽&quot;])#把数据变成表格形式，增加可读性pd.set_option(&#39;display.unicode.east_asian_width&#39;,True)#设置列名对齐print(&quot;x_data and index:\n&quot;,x_data)x_data[&#39;类别&#39;]=y_data#给增加一个类别标签print(&quot;x_data add a colum:\n&quot;,x_data)</code></pre><p>展示如下：</p><pre><code>x_data: [[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2]         .......... [6.5 3.  5.2 2. ] [6.2 3.4 5.4 2.3] [5.9 3.  5.1 1.8]]y_data: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]x_data and index:      花萼长  花萼宽  花瓣长  花瓣宽0       5.1     3.5     1.4     0.21       4.9     3.0     1.4     0.22       4.7     3.2     1.3     0.23       4.6     3.1     1.5     0.24       5.0     3.6     1.4     0.2..      ...     ...     ...     ...145     6.7     3.0     5.2     2.3146     6.3     2.5     5.0     1.9147     6.5     3.0     5.2     2.0148     6.2     3.4     5.4     2.3149     5.9     3.0     5.1     1.8[150 rows x 4 columns]x_data add a colum:      花萼长  花萼宽  花瓣长  花瓣宽  类别0       5.1     3.5     1.4     0.2     01       4.9     3.0     1.4     0.2     02       4.7     3.2     1.3     0.2     03       4.6     3.1     1.5     0.2     04       5.0     3.6     1.4     0.2     0..      ...     ...     ...     ...   ...145     6.7     3.0     5.2     2.3     2146     6.3     2.5     5.0     1.9     2147     6.5     3.0     5.2     2.0     2148     6.2     3.4     5.4     2.3     2149     5.9     3.0     5.1     1.8     2[150 rows x 5 columns]</code></pre><h3 id="神经网络实现鸢尾花分类"><a href="#神经网络实现鸢尾花分类" class="headerlink" title="神经网络实现鸢尾花分类"></a>神经网络实现鸢尾花分类</h3><ul><li><p>准备数据</p><ul><li>数据集读入</li><li>数据集乱序</li><li>生成测试集和训练集</li><li>标签配对，每次读入一个batch</li></ul></li><li><p>搭建网络</p><ul><li>定义神经网络中所有可训练参数</li></ul></li><li><p>参数优化</p><ul><li>嵌套迭代循环，with结构更新参数，显示当前loss</li></ul></li><li><p>测试效果</p><ul><li>计算当前参数前向传播后的准确率，显示当前acc</li></ul></li><li><p>acc/loss可视化</p><ul><li>matplotlib库使用</li></ul></li></ul><p>以下是训练用代码，只用一层网络进行训练，Mooc的要求是都能把代码背下来</p><pre><code class="python"># -*- coding: UTF-8 -*-# 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线# 导入所需模块import tensorflow as tffrom sklearn import datasetsfrom matplotlib import pyplot as pltimport numpy as np# 导入数据，分别为输入特征和标签x_data = datasets.load_iris().datay_data = datasets.load_iris().target# 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）# seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）np.random.seed(116)  # 使用相同的seed，保证输入特征和标签一一对应np.random.shuffle(x_data)np.random.seed(116)np.random.shuffle(y_data)tf.random.set_seed(116)# 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行x_train = x_data[:-30]y_train = y_data[:-30]x_test = x_data[-30:]y_test = y_data[-30:]# 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错x_train = tf.cast(x_train, tf.float32)x_test = tf.cast(x_test, tf.float32)# from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)# 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元# 用tf.Variable()标记参数可训练# 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))lr = 0.1  # 学习率为0.1train_loss_results = []  # 将每轮的loss记录在此列表中，为后续画loss曲线提供数据test_acc = []  # 将每轮的acc记录在此列表中，为后续画acc曲线提供数据epoch = 500  # 循环500轮loss_all = 0  # 每轮分4个step，loss_all记录四个step生成的4个loss的和# 训练部分for epoch in range(epoch):  #数据集级别的循环，每个epoch循环一次数据集    for step, (x_train, y_train) in enumerate(train_db):  #batch级别的循环 ，每个step循环一个batch        with tf.GradientTape() as tape:  # with结构记录梯度信息            y = tf.matmul(x_train, w1) + b1  # 神经网络乘加运算            y = tf.nn.softmax(y)  # 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）            y_ = tf.one_hot(y_train, depth=3)  # 将标签值转换为独热码格式，方便计算loss和accuracy            loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失函数mse = mean(sum(y-out)^2)            loss_all += loss.numpy()  # 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确        # 计算loss对各个参数的梯度        grads = tape.gradient(loss, [w1, b1])        # 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad        w1.assign_sub(lr * grads[0])  # 参数w1自更新        b1.assign_sub(lr * grads[1])  # 参数b自更新    # 每个epoch，打印loss信息    print(&quot;Epoch &amp;#123;&amp;#125;, loss: &amp;#123;&amp;#125;&quot;.format(epoch, loss_all/4))    train_loss_results.append(loss_all / 4)  # 将4个step的loss求平均记录在此变量中    loss_all = 0  # loss_all归零，为记录下一个epoch的loss做准备    # 测试部分    # total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0    total_correct, total_number = 0, 0    for x_test, y_test in test_db:        # 使用更新后的参数进行预测        y = tf.matmul(x_test, w1) + b1        y = tf.nn.softmax(y)        pred = tf.argmax(y, axis=1)  # 返回y中最大值的索引，即预测的分类        # 将pred转换为y_test的数据类型        pred = tf.cast(pred, dtype=y_test.dtype)        # 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)        # 将每个batch的correct数加起来        correct = tf.reduce_sum(correct)        # 将所有batch中的correct数加起来        total_correct += int(correct)        # total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数        total_number += x_test.shape[0]    # 总的准确率等于total_correct/total_number    acc = total_correct / total_number    test_acc.append(acc)    print(&quot;Test_acc:&quot;, acc)    print(&quot;--------------------------&quot;)# 绘制 loss 曲线plt.figure(figsize=(20,8),dpi=120)plt.title(&#39;Loss Function Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x轴变量名称plt.ylabel(&#39;Loss&#39;)  # y轴变量名称plt.plot(train_loss_results, label=&quot;$Loss$&quot;)  # 逐点画出trian_loss_results值并连线，连线图标是Lossplt.legend()  # 画出曲线图标plt.show()  # 画出图像# 绘制 Accuracy 曲线plt.title(&#39;Acc Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x轴变量名称plt.ylabel(&#39;Acc&#39;)  # y轴变量名称plt.plot(test_acc, label=&quot;$Accuracy$&quot;)  # 逐点画出test_acc值并连线，连线图标是Accuracyplt.legend()plt.show()plt.savefig(&quot;./firstNetwork.png&quot;)#保存图片</code></pre><h2 id="神经网络优化"><a href="#神经网络优化" class="headerlink" title="神经网络优化"></a>神经网络优化</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="tf-where"><a href="#tf-where" class="headerlink" title="tf.where()"></a>tf.where()</h4><ul><li><p>条件语句真返回A，条件语句假返回B</p></li><li><p>tf.where(条件语句,真返回A，假返回B)</p><pre><code class="python">a=tf.constant([1,2,3,1,1])b=tf.constant([0,1,3,4,5])c=tf.where(tf.greater(a,b), a, b)  若a&gt;b，返  回a对应位置的元素,否则  返回b对应位置的元素print(&quot;c:&quot;,c)  运行结果:c:tf.Tensor([1 2345], shape=(5,), dtype=int32)</code></pre></li></ul><h4 id="np-random-RandomState-rand"><a href="#np-random-RandomState-rand" class="headerlink" title="np.random.RandomState.rand()"></a>np.random.RandomState.rand()</h4><ul><li>返回一个[0,1)之间的随机数</li><li>np.random.RandomState.rand(维度)<br>维度为空，返回标量</li></ul><pre><code class="python">import numpy as nprdm=np.random.RandomState(seed:1) #seed=常数每次生成随机数相同a=rdm.rand()#返回一个随机标量b=rdm.rand(2,3)#返回维度为2行3列随机数矩阵print(&quot;a:&quot;,a)print(&quot;b:&quot;,b)#运行结果:a: 0.417022004702574b: [[7.20324493e-01 1.14374817e-04 3.02332573e-01][1.46755891e-01 9.23385948e-02 1.86260211e-01]]</code></pre><h4 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a>np.vstack()</h4><ul><li>将两个数组按垂直方向叠加np.vstack(数组1，数组2)</li></ul><pre><code class="python">import numpy as npa=np.array([1,2,3])b = np.array([4,5,6])C=np.vstack((a,b))np.vstack()print(&quot;c:ln&quot;,c)运行结果:c:        [[1,2,3],         [4,5,6]]</code></pre><h4 id="np-mgrid-ravel-np-c"><a href="#np-mgrid-ravel-np-c" class="headerlink" title="np.mgrid[ ]     .ravel()     np.c_[]"></a>np.mgrid[ ]     .ravel()     np.c_[]</h4><p>生成网格坐标点</p><ul><li>np.mgrid[起始值:结束值:步长，起始值:结束值:步长，…]</li><li>x.ravel() 将x变为一维数组，“把.前变量拉直”</li><li>np.c [1使返回的间隔数值点配对<br>np.c_[数组1，数组2，….]</li></ul><pre><code class="python">- import numpy as np  X, y= np.mgrid[1:3:1,2:4:0.5]  grid =np.c_[x.ravel(), y.ravel  print(&quot;x:&quot;,x)  print(&quot;y:&quot;,y)  print(&#39;grid:\n&quot;, grid)</code></pre><h3 id="复杂学习率"><a href="#复杂学习率" class="headerlink" title="复杂学习率"></a>复杂学习率</h3><h4 id="神经网络（NN）复杂度"><a href="#神经网络（NN）复杂度" class="headerlink" title="神经网络（NN）复杂度"></a>神经网络（NN）复杂度</h4><ul><li><p>√NN复杂度:多用NN层数和NN参数的个数表示</p><ul><li><p>空间复杂度:</p><ul><li>√层数=隐藏层的层数+1个输出层左图为2层NN</li><li>√总参数=总w＋总b</li></ul></li><li><p>时间复杂度:</p><ul><li>√乘加运算次数</li></ul></li></ul></li></ul><h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p>可以先用较大的学习率，快速得到较优的解，然后逐步减小学习率，使模型后期稳定</p><p>指数衰减学习率=初始学习率*当习率衰减率（当前轮数/多少轮衰减一次）</p><pre><code class="python">epoch=40LR BASE =0.2LR DECAY =0.99LR STEP =1for epoch in range (epoch):    lr = LR BASE *LR DECAY **(epoch / LR STEP)    with tf.GradientTape()as tape:        loss = tf.square(w +1)    grads = tape.gradient (loss, w)    w.assign sub (lr *grads)    print (&quot;After s epoch,w is %f,loss is %f,lr is %f&quot;%(epoch, w.numpy() , loss,lr))</code></pre><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="√优秀的激活函数"><a href="#√优秀的激活函数" class="headerlink" title="√优秀的激活函数:"></a>√优秀的激活函数:</h4><ul><li><p>非线性:激活函数非线性时，多层神经网络可逼近所有函数(只有网络是非线性的时候才不会被单层网络替代)</p></li><li><p>可微性:优化器大多用梯度下降更新参数</p></li><li><p>单调性:当激活函数是单调的，能保证单层网络的损失函数是凸函数（保证单层网络的损失函数是凸函数）</p></li><li><p>近似恒等性:f(x)sx当参数初始化为随机小值时，神经网络更稳定</p></li></ul><h4 id="√激活函数输出值的范围"><a href="#√激活函数输出值的范围" class="headerlink" title="√激活函数输出值的范围:"></a>√激活函数输出值的范围:</h4><ul><li>激活函数输出为有限值时，基于梯度的优化方法更稳定（权重对特征的影响更加显著）</li><li>激活函数输出为无限值时，建议调小学习</li></ul><h4 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h4><h5 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h5><p>近年来用sigmoid作为激活函数的网络越来越少，因为深层神经网络进行链式求导的时候，需要从输出层到输入层逐层进行链式求导，但是sigmoid函数的导数是0到0.25之间的小数，链式求导需要多层连续相乘，会出现多个0到0.25之间的连续相乘，结果将会趋于0,产生梯度消失，让参数无法继续更新</p><p>我们希望输入每层神经网络的特征是以0为均值的小数，但是sigmoid后的都是正数，收敛变慢，幂运算计算复杂度大训练时间长</p><ul><li>容易造成梯度消失</li><li>输出非0均值，收敛慢</li><li>幂运算复杂，训练时间长</li></ul><h5 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h5><ul><li>输出0均值</li><li>同样梯度消失</li><li>幂运算复杂，训练时间长</li></ul><h5 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h5><p>tf.nn.relu(x)</p><p>是个分段函数，</p><p>优点：</p><ul><li>解决了梯度消失问题</li><li>只需判断输入是否大于0，计算速度快</li><li>收敛远远快于前两者</li></ul><p>缺点：</p><ul><li>输出不是0均值，收敛慢</li><li>dead ReIU问题：当激活特征是负数时，某些神经元无法被激活，导致参数无法被更新<ul><li>设置更小学习率</li><li>减少参数分布的巨大变化</li></ul></li></ul><h5 id="Leaky-Relu"><a href="#Leaky-Relu" class="headerlink" title="Leaky Relu"></a>Leaky Relu</h5><p>tf.nn.leaky_relu(x)</p><p>为了解决relu负区间为0引起神经元死亡而设置的，使其负区间斜率不为0，无完全证明标书leaky relu比relu更好</p><p>但一般都用relu</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>首选relu激活函数;</li><li>√学习率设置较小值;</li><li>输入特征标准化,即让输特征满足以0为均值,1为标准差的正态分布;</li><li>初始参数中心化，即让随机生成的参数满足以0为均值,根下输入特征分之2为标准差的正态分布</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数（loss） :预测值（y)与已知答案（y_）的差距</p><p>NN优化目标:loss最小</p><p>主流的损失函数：</p><ul><li><p>mse (Mean Squared Error)</p></li><li><p>自定义</p></li><li><p>ce(Cross Entropy)交叉熵</p></li></ul><h4 id="均方误差mse"><a href="#均方误差mse" class="headerlink" title="均方误差mse:"></a>均方误差mse:</h4><pre><code class="python">loss_mse = tf.reduce_mean(tf.square(y_-y))</code></pre><h4 id="自定义损失函数："><a href="#自定义损失函数：" class="headerlink" title="自定义损失函数："></a>自定义损失函数：</h4><p>对不同的损失赋予不同的惩罚</p><pre><code class="python">loss zdy= tf.reduce _sum(where :(tf.greatery,y_b, cOST(y -y_),PROFT(y_-y))</code></pre><h4 id="交叉熵："><a href="#交叉熵：" class="headerlink" title="交叉熵："></a>交叉熵：</h4><p>√交叉嫡损失函数CE(Cross Entropy):表征两个概率分布之间的距离</p><p>eg.二分类已知答案y_=(1,0)预测y,=(0.6, 0.4)y2=(0.8, 0.2)哪个更接近标准答案?</p><p>H1((1.0),(0.6,0.4))=-(1<em>ln0.6+O</em>ln0.4)~~(-0.511 ＋0)=0.511</p><p>H2((1,0).(0.8,0.2))=-(1<em>ln0.8+O</em>ln0.2)~~(-0.223+0)=0.223</p><p>因为H&gt;H，所以y,预测更准</p><pre><code class="python">tf.losses.categorical_crossentropy(y ,y)loss_ce1=tf.losses.categorical_ crossentropy([1,0],[0.6,0.4])loss_ce1=tf.losses.categorical_ crossentropy([1,0],[0.8,0.2])print(&quot;loss_ce1:&quot;, loss_ce1)print(&quot;loss_ce2:&quot;, loss_ce2)</code></pre><p>softmax与交叉结合</p><p>√输出先过softmax函数，再计算第y与y_的交叉嫡损失函数。</p><pre><code class="python">tf.nn.softmax_cross_entropy_with_logits(y_,y)Y_= np.array([[1, 0, 0],[0,1,0],[0, 0,1],[1,0,0],[0,1,0]])y = np.array([[12,3,2],[3,10,1],[1,2, 5],[4,6.5,1.2],[3,6, 1]])y_pro= tf.nn.softmax(y)loss_ce1 = tf.losses.categorical_crossentropy(y_,y_pro)loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_y)print(&#39;分步计算的结果:ln&#39;, loss_ce1)print(&#39;结合计算的结果:ln&#39;, loss_ce2)</code></pre><h3 id="缓解过拟合"><a href="#缓解过拟合" class="headerlink" title="缓解过拟合"></a>缓解过拟合</h3><p>过拟合把数据点记住了，导致模型过度训练，泛化性弱</p><h4 id="欠拟合的解决方法："><a href="#欠拟合的解决方法：" class="headerlink" title="欠拟合的解决方法："></a>欠拟合的解决方法：</h4><ul><li>增加输入特征</li><li>增加网络参数</li><li>减少正则化参数</li></ul><h4 id="过拟合的解决方法："><a href="#过拟合的解决方法：" class="headerlink" title="过拟合的解决方法："></a>过拟合的解决方法：</h4><ul><li>数据清洗减少噪声</li><li>增大训练集</li><li>采用正则项</li><li>增大正则化参数</li></ul><p>下面详细介绍正则化：</p><p>正则化就是在损失函数中引入模型复杂度指标：，给每个参数w加上权重，抑制训练集中的噪声(一般不正则化b)</p><p>loss = loss(y与y)+ REGULARIZER * loss(w)</p><p>loss(y与y)是模型中所有参数的损失函数<br>超参数REGULARIZER给出参数w在总loss中的比例，即正则化的权重<br>w是需要正则化的参数</p><p>一般：</p><ul><li>L1正则：loss(w)=lwI</li><li>L2正则：loss 2(w)=sum(w^2)</li></ul><p>√正则化的选择：</p><ul><li><p>L1正则化大概率会使很多参数变为零,<br>因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度。</p></li><li><p>L2正则化会使参数很接近零但不为零,<br>因此该方法可通过减小参数<br>值的大小降低复杂度。</p><p>下面是代码：</p><pre><code class="python">with tf.GradientTape() as tape:    hl = tf.matmul(x train, wl)+ b1    h1 = tf.nn.relu(hl)    y = tf.matmul(h1, w2)+ b2    loss mse = tf.reduce mean (tf.square(y train - y))    loss regularization = []    loss regularization.append (tf.nn.l2_loss(wl))    loss regularization. append (tf.nn. l2_ loss(w2))    loss regularization = tf.reduce sum (loss regularization)    loss = loss mse + 0.03 *loss regularizationvariables = [w1,b1， w2，b2]grads = tape. gradient (loss, variables)</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tensorflow基础&quot;&gt;&lt;a href=&quot;#Tensorflow基础&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow基础&quot;&gt;&lt;/a&gt;Tensorflow基础&lt;/h1&gt;&lt;p&gt;​    TensorFlow是现在比较火爆的一个深度学习的</summary>
      
    
    
    
    <category term="machinlearning" scheme="http://sweetheart.huangtao.xyz/categories/machinlearning/"/>
    
    
    <category term="DeepLearning" scheme="http://sweetheart.huangtao.xyz/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之sklearn</title>
    <link href="http://sweetheart.huangtao.xyz/2020/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn/"/>
    <id>http://sweetheart.huangtao.xyz/2020/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn/</id>
    <published>2020-10-21T06:59:54.000Z</published>
    <updated>2020-10-22T15:56:06.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记之sklearn"><a href="#机器学习笔记之sklearn" class="headerlink" title="机器学习笔记之sklearn"></a>机器学习笔记之sklearn</h1><p>  sklearn是机器学习中重要的测试数据集来源之一，并且可以提供特征提取以及降维聚类等功能</p><p>   蒟蒻从今天起开始机器学习调库调参的第一步，</p><h3 id="sklearn数据集介绍"><a href="#sklearn数据集介绍" class="headerlink" title="sklearn数据集介绍"></a>sklearn数据集介绍</h3><h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><p>数据集的操作有:</p><ul><li>load_*获取自带的较小的数据集</li><li>fetchg_*获取外部的较大的数据集</li></ul><pre><code class="python">import sklearn.datasets from sklearn.datasets import load_iris //导入鸢尾花数据集iris=load_iris()print(&quot;鸢尾花的数据集返回值&quot;,iris)print(&quot;鸢尾花数据的描述&quot;,iris[&quot;DESCR&quot;])print(&quot;鸢尾花数据的特征值&quot;,iris.data)print(&quot;鸢尾花的目标值&quot;,iris.target)print(&quot;鸢尾花的特征值名字&quot;,iris.data.shape)print(&quot;鸢尾花的特征值名字&quot;,iris.feture_name)</code></pre><p>sklearn返回值介绍：</p><ul><li>load 和fetch返回的是字典格式<ul><li>data：特征数据集</li><li>target:标签数据</li><li>DESCR:数据描述</li><li>feature_names:特征名字，新闻数据，手写数字，回归数据集没有</li><li>target_name:标签名</li></ul></li></ul><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><p>进行机器学习的时候我们要对数据集进行划分，划分成训练集和测试集</p><p>​    一般来说，测试集所占比例比较少：</p><ul><li>一般：测试集一般占比20%~30%{sklearn库中划分函数默认25%}</li><li>训练集特征值，测试集特征值，训练集特征值。测试目标集特征值分别是：x_train x_test  y_train y_test</li></ul><p>训练集划分api：</p><pre><code class="python">from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitiris=load_iris()print(&quot;鸢尾花的数据集返回值&quot;, iris)print(&quot;鸢尾花数据的描述&quot;, iris[&quot;DESCR&quot;])print(&quot;鸢尾花数据的特征值&quot;, iris.data)print(&quot;鸢尾花的目标值&quot;, iris.target)print(&quot;鸢尾花的特征值名字&quot;, iris.data.shape)print(&quot;鸢尾花的特征值名字&quot;, iris.feature_names)x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=22)//第一个参数：数据集x的特征值，第二个参数数据集y的特征值，测试集的占比,第三个随机分配时数种子//返回：训练集特征值，测试集特征值，训练集目标值，测试集目标值</code></pre><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>即是对一些非数值的数据，比如对文本语音图像等，将其转换成数值化，便于进行矩阵运算</p><p>特征提取用于降维等等</p><p>特征工程：</p><p>一般用sklearn进行特征提取、</p><p>而用pandas进行数据清洗，数据抽取，等预处理工作</p><ul><li><p>目标</p><ul><li>应用DicVectorizer实现对类别特征进行数值化离散化</li><li>应用CountVectorizer实现对文本特征进行数值化</li><li>应用TfidVectorizer实现对文本特征进行数值化</li></ul></li><li><p>特征提取api</p><pre><code class="python">sklearn.feature_extraction</code></pre></li></ul><h4 id="对字典进行数值化抽取"><a href="#对字典进行数值化抽取" class="headerlink" title="对字典进行数值化抽取"></a>对字典进行数值化抽取</h4><pre><code class="python">from sklearn.feature_extraction import DictVectorizerdef dict_demo():    data = [&amp;#123;&#39;city&#39;: &#39;beijing&#39;, &#39;number&#39;: 1&amp;#125;, &amp;#123;&#39;city&#39;: &#39;guangdong&#39;, &#39;number&#39;: 4&amp;#125;, &amp;#123;&#39;city&#39;: &#39;shanghai&#39;, &#39;number&#39;: 3&amp;#125;]    transfer = DictVectorizer()  # 实例化转换器    data_new = transfer.fit_transform(data)    print(&quot;data_new:&quot;, data_new)    print(&quot;data_new的名字:&quot;, transfer.feature_names_)#查看矩阵各列代表属性    return Noneif __name__ == &quot;__main__&quot;:    dict_demo()</code></pre><p>返回的矩阵：</p><pre><code>data_new:   (0, 0)    1.0  (0, 3)    1.0  (1, 1)    1.0  (1, 3)    4.0  (2, 2)    1.0  (2, 3)    3.0返回的是一个稀疏矩阵，当把稀疏矩阵转换成矩阵形式的时候，设置稀疏矩阵falsetransfer = DictVectorizer(sparse=False)输出：data_new: [[1. 0. 0. 1.] [0. 1. 0. 4.] [0. 0. 1. 3.]] data_new的名字: [&#39;city=beijing&#39;, &#39;city=guangdong&#39;, &#39;city=shanghai&#39;, &#39;number&#39;]</code></pre><h4 id="文本特征提取"><a href="#文本特征提取" class="headerlink" title="文本特征提取"></a>文本特征提取</h4><pre><code class="python">from sklearn.feature_extraction.text import CountVectorizerdef count_demo():    data = [&quot;lfe is short l like python&quot;, &quot;life is short ,code more&quot;]    transfer = CountVectorizer()    data_new = transfer.fit_transform(data)    print(&quot;data_new:\n&quot;, data_new)     print(&quot;特征名字：\n&quot;,transfer.get_feature_names())#调用此方法获取矩阵的值    return Noneif __name__ == &quot;__main__&quot;:    count_demo()</code></pre><p>同样返回的是一个稀疏矩阵：</p><pre><code class="python">data_new:   (0, 2)    1  (0, 1)    1  (0, 7)    1  (0, 4)    1  (0, 6)    1  (1, 1)    1  (1, 7)    1  (1, 3)    1  (1, 0)    1  (1, 5)    1  特征名字： [&#39;code&#39;, &#39;is&#39;, &#39;lfe&#39;, &#39;life&#39;, &#39;like&#39;, &#39;more&#39;, &#39;python&#39;, &#39;short&#39;]    #可见过滤了I等低频词汇    #若对中文进行词频抽取，要用空格隔开词语</code></pre><h4 id="中文文本抽取"><a href="#中文文本抽取" class="headerlink" title="中文文本抽取"></a>中文文本抽取</h4><p>from sklearn.feature_extraction.text import CountVectorizer(stop_word=[])</p><p>这里的stop_word是跳过词，抽取时忽略这个词，自然语言处理时用停顿词表进行无关词语忽略</p><p>这里把把is和like作为停顿词</p><pre><code class="python">transfer = CountVectorizer(stop_words=[&#39;is&#39;, &#39;like&#39;])</code></pre><p>输出特征名字：<br> [‘code’, ‘lfe’, ‘life’, ‘more’, ‘python’, ‘short’]</p><p>中文文本抽取：</p><p>由于中文文本在CountVectorizer中使用必需分词，所以要调用jieba的分词函数</p><pre><code class="python">import jieba  # 对中文文本进行分词处理def cut_word(text):    # 中文文本分词函数    text = &quot;&quot;.join(list(jieba.cut(text)))    # jibe分词函数-&gt;转化成；列表—&gt;转化成字符串    return textdef count_Chinese():    data = [&quot;一种还是一种今天很残酷，明天更加残酷，但是对大部分人来说&quot;, &quot;进行机器学习的时候我们要对数据集进行划分，划分成训练集和测试集&quot;, &quot;一般来说，测试集所占比例比较少&quot;,            &quot;训练集特征值，测试集特征值，训练集特征值。测试目标集特征值分别是：x_train x_test  y_train y_test&quot;]    data_new = []    for i in data:        data_new.append(cut_word(i))    print(data_new)    return Noneif __name__ == &quot;__main__&quot;:    count_Chinese()</code></pre><p>然后对生成列表进行特征抽取</p><p>然而这样的特征抽取没有突出高频率词汇，所以要对高频率词汇进行提取</p><p>但是有些词比较辣鸡，不该作为信息抽取</p><h4 id="文本特征抽取2"><a href="#文本特征抽取2" class="headerlink" title="文本特征抽取2"></a>文本特征抽取2</h4><p>关键词：在某一个类别的文章中出现次数多，但在其他文章中出现次数少的词汇，标志了一个文本的特征</p><p>Tf-idf文本特征抽取原理即是如此</p><p>tf:词频</p><p>idf:逆向文本频率:</p><p>由文本文件数目除以包含词语的文件的数目，再将得到的商取以10为底的对数</p><p>Tf-idf=tf*idf</p><p>举例：</p><p>语料库：1000文章</p><p>100文章有非常</p><p>10偏有经济</p><p>两篇文章：</p><p>​    A文章（100词）：经济10词</p><p>​        ‘经济’：</p><p>​            tf=0.1</p><p>​            idf=log 10 1000/10=2</p><p>​            Tf-idf=0.2</p><p>​    B文章（100词）：非常10词</p><p>​        ‘非常’：</p><p>​        tf=0.1</p><p>​        idf=log 10 1000/100=1</p><p>​        Tf-idf=0.1</p><p>ApI</p><pre><code class="python">from sklearn.feature_extraction.text import TfidfVectorizerdef Tfidf_demo():    data = [&quot;lfe is short l like python&quot;, &quot;life is short ,code more&quot;]    transfer = TfidfVectorizer(stop_words=[&#39;is&#39;, &#39;like&#39;])    data_new = transfer.fit_transform(data)    print(&quot;data_new:\n&quot;, data_new)    print(&quot;特征名字：\n&quot;, transfer.get_feature_names())    return None#就实例化的时候改了下转换器的名字if __name__ == &quot;__main__&quot;:    Tfidf_demo()</code></pre><p>实例化和提取操作类似于CountVectorizer，同样有停顿词功能</p><p>返回：</p><pre><code class="python">data_new:   (0, 4)    0.6316672017376245  (0, 5)    0.4494364165239821  (0, 1)    0.6316672017376245  (1, 3)    0.534046329052269  (1, 0)    0.534046329052269  (1, 2)    0.534046329052269  (1, 5)    0.37997836159100784特征名字： [&#39;code&#39;, &#39;lfe&#39;, &#39;life&#39;, &#39;more&#39;, &#39;python&#39;, &#39;short&#39;]</code></pre><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p>为了使数据更加适合算法模型处理</p><p>归一化就是在将数据处理在一定中范围内</p><p>如果不对数据进行归一化处理，那么数据将会由于某一个特征值过于巨大而导致其他特征值被忽略，（在聚类中的欧式距离计算中尤为明显）</p><p>所以要将几个数据项的值固定在一个统一的范围内：</p><p>数学上叫做无量纲化</p><p>公式</p><pre><code class="python">x&#39;=(x-min)/(max-min)x&#39;&#39;=x&#39;*(mx-mi)+mi</code></pre><p>例如有数据[90,60,75]</p><p>对于数据90：</p><p>x’=(90-60)/(90-60)=1</p><p>x”=1*(1)+0=1   #放缩到1-0区间，mx=1，mi=0</p><p>ApI:</p><pre><code class="python">import pandas as pd#调用pandas清洗函数from sklearn.preprocessing import MinMaxScaler#调用归一化函数def minmax():    data=pd.read_csv(&quot;titanic/test.csv&quot;)    data=data.iloc[:6, :2]    #截取数据前两列前6行    trans=MinMaxScaler()#实例化转换器    datanew=trans.fit_transform(data)    print(datanew)    return Noneif __name__ == &quot;__main__&quot;:    minmax()</code></pre><p>输出：</p><pre><code class="python">[[0.  1. ] [0.2 1. ] [0.4 0. ] [0.6 1. ] [0.8 1. ] [1.  1. ]]</code></pre><p>这样在处理聚类数据的时候可以减少特征值之间的差距</p><h4 id="标准化处理"><a href="#标准化处理" class="headerlink" title="标准化处理"></a>标准化处理</h4><p>当数据中有缺失值和异常值，做归一化处理得到的数据可能会有缺陷，这种方式鲁棒性较差，只适合传统的精确度小的数据处理</p><p>异常值通常是：</p><ul><li>最大值</li><li>最小值</li></ul><p>标准化定义</p><p>对原始数据变换将数据变为均值为0，标准差为1</p><p>公式：</p><p>x’=(x-mean)/std</p><p>std=标准差</p><p>API</p><pre><code class="python">from sklearn.preprocessing import MinMaxScaler,StandardScaler#即在原来归一化基础上实例的时候改了转换器就行def std_demo():    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:6, :2]    # 截取数据前两列前6行    trans = StandardScaler() # 实例化转换器    datanew = trans.fit_transform(data)    print(datanew)    return Noneif __name__ == &quot;__main__&quot;:    std_demo()</code></pre><p>返回：</p><pre><code class="python">[[-1.46385011  0.4472136 ] [-0.87831007  0.4472136 ] [-0.29277002 -2.23606798] [ 0.29277002  0.4472136 ] [ 0.87831007  0.4472136 ] [ 1.46385011  0.4472136 ]]</code></pre><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>降维是在某些限定的条件，降低随机特征的个数，得到一组不相关主变量的过程</p><p>维数：嵌套层数</p><ul><li>0维：标量</li><li>1维：向量</li><li>2维：矩阵</li></ul><p>降低的对象：二维数组</p><p>此处降维：降低列数</p><ul><li>相关特征：<ul><li>相对湿度与降雨量之间的关系</li><li>等等</li></ul></li></ul><blockquote><p>正是因为在进行训练的时候，我们都是使用特征进行学习的，如果有特征本身存在问题或者特征之间相关性比较强，对于算法学习的预测影响会比较大</p></blockquote><p>降维的两种方法：</p><ul><li>特征选择</li><li>主成分分析</li></ul><p>特征选择：</p><p>数据中包含冗余的或相关变量，希望在原有特征中找出主要特征</p><p>方法：</p><ul><li>filter过滤式<ul><li>方差选择法：低方差特征过滤（说明此属性共有不必要）</li><li>相关系数法：特征与特征之间的相关程度</li></ul></li><li>embeded嵌入式<ul><li>决策树</li><li>正则化</li><li>深度学习</li></ul></li></ul><h4 id="低方差特征过滤"><a href="#低方差特征过滤" class="headerlink" title="低方差特征过滤"></a>低方差特征过滤</h4><p>API</p><pre><code class="python">import pandas as pdfrom sklearn.feature_selection import VarianceThresholddef varianse_demo():    # 过滤低方差    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:5, :2]    transfer = VarianceThreshold()    data = transfer.fit_transform(data)    print(data)    return Noneif __name__ == &quot;__main__&quot;:    varianse_demo()</code></pre><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p>皮尔森相关系数:</p><p>公式略</p><p>特点：</p><ul><li>当r&gt;0正相关，R&lt;0负相关</li><li>当r=-1or1完全相关，r=0表示毫无关系</li><li>越近于1相关性越强</li><li>0.4&lt;abs(r)&lt;0.7说明有一定相关性</li></ul><p>Api:</p><pre><code class="python">import pandas as pdfrom scipy.stats import pearsonrdef varianse_demo():    # 过滤低方差    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:5, :2]    r = pearsonr(data[&quot;pe_ratio&quot;], data[&quot;pb_ratio&quot;])    print(r)    return Noneif __name__ == &quot;__main__&quot;:    varianse_demo()</code></pre><p>如果特征与多个特征之间相关性很高：</p><ul><li><p>选取其中一个</p></li><li><p>加权求和</p></li><li><p>主成分分析</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习笔记之sklearn&quot;&gt;&lt;a href=&quot;#机器学习笔记之sklearn&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记之sklearn&quot;&gt;&lt;/a&gt;机器学习笔记之sklearn&lt;/h1&gt;&lt;p&gt;  sklearn是机器学习中重要的测试数据</summary>
      
    
    
    
    <category term="machine learning" scheme="http://sweetheart.huangtao.xyz/categories/machine-learning/"/>
    
    
    <category term="sklearn" scheme="http://sweetheart.huangtao.xyz/tags/sklearn/"/>
    
    <category term="machine learning" scheme="http://sweetheart.huangtao.xyz/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>pandaa&amp;&amp;numpy学习笔记</title>
    <link href="http://sweetheart.huangtao.xyz/2020/10/04/pandas-numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.huangtao.xyz/2020/10/04/pandas-numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-04T08:02:15.000Z</published>
    <updated>2020-12-31T12:35:01.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy-matplotlib-pandas以及文件批量操作"><a href="#numpy-matplotlib-pandas以及文件批量操作" class="headerlink" title="numpy,matplotlib,pandas以及文件批量操作"></a>numpy,matplotlib,pandas以及文件批量操作</h1><p>写在前面，由于自己python基础能力有点菜，并且基本上每上手一个框架都需要这四方面的操作以及掌握，所以我决定恶补这方面的不足，故有了这样一篇博客，持续更新中~</p><ul><li>环境：conda,jupyter notebook</li></ul><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>绘图用库，进行数据可视化，</p><h3 id="练手项目1-初识matplotlib，绘制折线图"><a href="#练手项目1-初识matplotlib，绘制折线图" class="headerlink" title="练手项目1 初识matplotlib，绘制折线图"></a>练手项目1 初识matplotlib，绘制折线图</h3><h4 id="教学部分"><a href="#教学部分" class="headerlink" title="教学部分"></a>教学部分</h4><p>假设一天中每隔两个小时（range（2,26,2））的气温分别是：</p><p>[15,13,14,5,17,20,25,26,27,22,18,15]</p><pre><code class="python">from matplotlib import pyplot as plt#导入pyplot模块x = range(2, 26, 2)#设置x轴的步距以及上下限y = [15, 13, 14, 5, 17, 20, 25, 26, 27, 22, 18, 15]#y轴的数据，和x对应plt.plot(x, y)#执行方法plt.show()#show方法#最后画出一个折线图</code></pre><p>要点：x和y的数据量一定要一一对应，不然会直接报错，要求步长和上下限list的数据大小和y中一样</p><p>但是这样生成的图表示的数据很模糊，没有标注以及并不好看</p><p>目前存在以下几个问题：</p><ul><li>设置图片大小</li><li>保存到本地</li><li>描述信息，比如x轴和y轴表示什么，这个图表示什么</li><li>描述x或者y的刻度的间距</li><li>标记出特殊点的（比如最高以及最低点）</li><li>给图片添加一个水印（防伪）</li></ul><p>设置图片大小/保存图片：</p><pre><code class="python">from matplotlib import pyplot as pltfig = plt.figure(figsize=(20, 8), dpi=80)# figure图形图标的意思，这里指的是我们画的图，通过实例化一个figure并且传递参数，能够在后台自动使用该figure实例# dpi参数，让图片更加清楚x = range(2, 26, 2)y = [15, 13, 14.5, 17, 20, 25, 26, 26, 27, 22, 18, 15]plt.plot(x, y)# 或者这种方法_xtick_labels=[i/2 for i in range(2,50)]# plt.xticks(_xtick_labels)采用传入数组的方法式# plt.yticks(range(min(y),max(y)+1))步距自动为1plt.xticks(range(2, 25))  # 设置x轴显示步距plt.yticks(range(10, 30, 1))  # range,(start ,end,step)plt.savefig(&quot;./first.png&quot;)  # 在本地保存plt.show()</code></pre><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>如果a表示10到12点的每一分钟的气温，如何绘制折线观察每分钟的气温变化</p><p> a=[random.randint(20,35) for i in range(120)]</p><pre><code class="python">from matplotlib import pyplot as pltimport random as rd#记得导入随机数库a = [rd.randint(20, 35) for i in range(120)]#设置x，y轴x = range(1, 121)plt.plot(x, a)#实例化图形plt.xticks(range(1, 121))plt.yticks(range(15, 41))#设置xy轴参数plt.show()#显示plt.savefig(&quot;./firstproject.png&quot;)#保存</code></pre><p>现在这个代码有点问题，问题在于x轴并不能如实反映钟点数，而是10进制</p><h5 id="转化成时间形式"><a href="#转化成时间形式" class="headerlink" title="转化成时间形式"></a>转化成时间形式</h5><p>修改后</p><pre><code class="python">from matplotlib import pyplot as pltimport random as rda = [rd.randint(20, 35) for i in range(120)]x = range(1, 121)plt.figure(figsize=(20,8),dpi=80)#修改长宽比，修改像素 这是决定图片好看与否的一个因素plt.plot(x, a)_x = list(x)[::3]  # 修改步长变成3，要修改成列表形式 _xtick_label = [&quot;10:&amp;#123;&amp;#125;&quot;.format(i) for i in range(60)]_xtick_label += [&quot;11:&amp;#123;&amp;#125;&quot;.format(i) for i in range(60)]  # 追加列表尾plt.xticks(_x, _xtick_label[::3],rotation=300)  # rotation旋转的度数#前两个参数数量大小应该一样，则不能完全覆盖整个轴#第一个参数：上下限，是个列表，第二个参数吗，同样是个列表，表示参数注释，注释基本上没有中文plt.yticks(range(15, 41))plt.show()plt.savefig(&quot;./firstproject.png&quot;)</code></pre><h5 id="显示中文以及修改设置"><a href="#显示中文以及修改设置" class="headerlink" title="显示中文以及修改设置"></a>显示中文以及修改设置</h5><p>在pycharm中，ctrol加上鼠标可查看模块源码</p><p>比如修改matplotlib的绘图设置，可以</p><pre><code class="python">import matplotlibmatplotlib.rc</code></pre><p>然后点开源码，进行查看</p><pre><code class="python"> &quot;&quot;&quot;    Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,    for ``lines.linewidth`` the group is ``lines``, for    ``axes.facecolor``, the group is ``axes``, and so on.  Group may    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).    *kwargs* is a dictionary attribute name/value pairs, e.g.,::      rc(&#39;lines&#39;, linewidth=2, color=&#39;r&#39;)可以设置线条样式    sets the current `.rcParams` and is equivalent to::      rcParams[&#39;lines.linewidth&#39;] = 2      rcParams[&#39;lines.color&#39;] = &#39;r&#39;    The following aliases are available to save typing for interactive users:    =====   =================    Alias   Property    =====   =================    &#39;lw&#39;    &#39;linewidth&#39;    &#39;ls&#39;    &#39;linestyle&#39;    &#39;c&#39;     &#39;color&#39;    &#39;fc&#39;    &#39;facecolor&#39;    &#39;ec&#39;    &#39;edgecolor&#39;    &#39;mew&#39;   &#39;markeredgewidth&#39;    &#39;aa&#39;    &#39;antialiased&#39;    =====   =================    Thus you could abbreviate the above call as::          rc(&#39;lines&#39;, lw=2, c=&#39;r&#39;)    Note you can use python&#39;s kwargs dictionary facility to store    dictionaries of default parameters.  e.g., you can customize the    font rc as follows::      font = &amp;#123;&#39;family&#39; : &#39;monospace&#39;,或者这种字典写法，引入后一一对应              &#39;weight&#39; : &#39;bold&#39;,              &#39;size&#39;   : &#39;larger&#39;&amp;#125;      rc(&#39;font&#39;, **font)  # pass in the font dict as kwargs    This enables you to easily switch between several configurations.  Use    ``matplotlib.style.use(&#39;default&#39;)`` or :func:`~matplotlib.rcdefaults` to    restore the default `.rcParams` after changes.    Notes    -----    Similar functionality is available by using the normal dict interface, i.e.    ``rcParams.update(&amp;#123;&quot;lines.linewidth&quot;: 2, ...&amp;#125;)`` (but ``rcParams.update``    does not support abbreviations or grouping).    &quot;&quot;&quot;</code></pre><p>则可以</p><pre><code class="python">import matplotlibfont = &amp;#123;&#39;family&#39; : &#39;monospace&#39;              &#39;weight&#39; : &#39;bold&#39;,              &#39;size&#39;   : &#39;larger&#39;&amp;#125;matplotlib.rc(&#39;font&#39;, **font)</code></pre><p>或者通过此显示中文</p><pre><code class="python">from matplotlib import font_managermy_font=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\PingFang.ttc&quot;)#字体所在地址</code></pre><p>具体中文显示可以见此博客</p><p><a href="https://blog.csdn.net/fengdu78/article/details/111189331?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160933291616780265368901%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160933291616780265368901&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-111189331.pc_search_result_cache&utm_term=font_manager.FontProperties">使用matplotlib绘图时中文字体的解决方案</a></p><h5 id="给图添加描述信息"><a href="#给图添加描述信息" class="headerlink" title="给图添加描述信息"></a>给图添加描述信息</h5><pre><code class="python">plt.xlabel(&quot;Time&quot;)plt.ylabel(&quot;temperaturec&quot;)#x与y轴分别标注plt.title(&quot;10:00-12:00&quot;)#给图添加标题</code></pre><p>总结：</p><ul><li><p>学习了怎么绘图：</p><ul><li>from matplotlib import pyplot as plt</li><li>plt.plot(x,y)</li><li>plt.show()</li></ul><p>这三个是绘图的主要流程，即调库，导入数据，显示</p></li><li><p>对图形进行优化</p><ul><li>plt.figure(长宽比,像素)</li><li>_xtick_label实例化一个列表后，作为参数导入plt.xticks(）方法，从而对x轴进行优化、</li><li>plt.xlabel()和plt.ylabel(）解释参数plt.title()给图片命名</li><li>保存图片plt.savefig（）</li><li>字体设置，详见博客</li></ul></li></ul><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_551150525955559424.html?v=1609334127000" alt="课后作业"></p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltx = [i for i in range(11,31)]y = [1, 0, 1, 1, 2, 4, 3, 2, 3, 4, 4, 5, 6, 5, 4, 3, 3, 1, 1, 1]plt.figure(figsize=(20, 8), dpi=80)plt.plot(x, y)plt.xlabel(&quot;age&quot;)plt.ylabel(&quot;the number of girl(boy) friends&quot;)plt.title(&quot;my plot&quot;)_x = list(x)x_label= [&quot;&amp;#123;&amp;#125;year&quot;.format(i) for i in range(11,31)]y_label = [&quot;&amp;#123;&amp;#125; boys or girls&quot;.format(i) for i in y]plt.xticks(_x,x_label,rotation=300)plt.yticks(range(0,9))#注意名字不能写错，plt.show()</code></pre><h3 id="练手项目2-绘制散点图和折线图"><a href="#练手项目2-绘制散点图和折线图" class="headerlink" title="练手项目2 绘制散点图和折线图"></a>练手项目2 绘制散点图和折线图</h3><h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><p>假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?</p><p>a =[11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</p><p>b =[26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</p><p>三月单独绘制代码如下：</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managery_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22, 22,     23]y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13, 12,     13, 6]x=range(1,32)plt.scatter(x,y_3)plt.show()</code></pre><p>但是这时并没有达到我们想要的结果，我们想要绘制一个三月十月同时存在的图，并且有完整图例</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)y_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22,       22,       23]y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13,        12,        13, 6]x_3 = range(1, 32)x_10 = range(51, 82)plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.scatter(x_3, y_3,label=&quot;三月份&quot;)plt.scatter(x_10, y_10,label=&quot;十月份&quot;)_x = list(x_3) + list(x_10)_xticks_labels = [&quot;三月&amp;#123;&amp;#125;日&quot;.format(i) for i in x_3]_xticks_labels += [&quot;十月&amp;#123;&amp;#125;日&quot;.format(i - 50) for i in x_10]plt.legend(loc=&quot;upper left&quot;,prop=myfont)#添加图例plt.xticks(_x[::3], _xticks_labels[::3],fontProperties=myfont, rotation=300)plt.ylabel(&quot;气温C&quot;,fontProperties=myfont)plt.title(&quot;气温对照表&quot;,fontProperties=myfont)plt.show()</code></pre><p>之后会利用散点图绘制线性回归的拟合曲线</p><h4 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h4><p>a =[“战狼2”,”速度与激情8” “功夫瑜伽”∵”西游伏妖篇”,”变形金刚5∶最后的骑士”,”摔跤吧!爸爸” ,”加勒比海盗5∶死无对证”,”金刚:骷髅岛”,”极限特工:终极回归”,”生化危机6:终章”, “乘风破浪”∵”神偷奶爸3”,”智取威虎山”;”大闹天竺”,”金刚狼3∶殊死一战” ,”蜘蛛侠:英雄归来”,”悟空传”,”银河护卫队2”,”情圣”,”新木乃伊”,]</p><p>b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23]单位:亿</p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a = [&quot;战狼2&quot;,&quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;,&quot;西游伏妖篇&quot;,&quot;变形金刚5∶最后的骑士&quot;,&quot;摔跤吧!爸爸&quot; ]b = [56.01,26.94,17.53,16.49,15.45,12.96]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.bar(range(len(a)),b,width=0.3)plt.xticks(range(len(a)),a,fontProperties=myfont, rotation=300)plt.show()</code></pre><p>截断了前6个</p><p>但是我们更加希望是变成竖着的条形图，那么就改成barh,于是代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a = [&quot;战狼2&quot;,&quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;,&quot;西游伏妖篇&quot;,&quot;变形金刚5∶最后的骑士&quot;,&quot;摔跤吧!爸爸&quot; ]b = [56.01,26.94,17.53,16.49,15.45,12.96]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.barh(range(len(a)),b,height=0.3,color=&quot;red&quot;)#改成竖图后，wight应该改成hightplt.yticks(range(len(a)),a,fontProperties=myfont)plt.grid(alpha=0.3)#设置网格plt.show()</code></pre><h4 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h4><p>假设你知道了列表a中电影分别在2017-09-14(b_ 14), 2017-09 -15(b _15),2017-09-16(b _16)三天的票房，为了展示列表中电影本身的票房以及同其他假设你知道了列表a中电影分别在2017-09- -14(b14), 2017-09 -15(b15),<br>2017-09- 16(b16)三天的票房，为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?<br>a= [“猩球崛起3:终极之战”,”敦刻尔克”，”蜘蛛侠:英雄归来”,”战狼2”]<br>b16 = [15746,312,4497,319]<br>b15 = [12357,156,2045,168]<br>b14 = [2358,399,2358,362]</p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a= [&quot;猩球崛起3:终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠:英雄归来&quot;,&quot;战狼2&quot;]b16 = [15746,312,4497,319]b15 = [12357,156,2045,168]b14 = [2358,399,2358,362]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别x_14=list(range(len(a)))x_15=[i+0.2 for i in x_14]x_16=[i+0.4 for i in x_14]plt.bar(range(len(a)),b14,width=0.2,color=&quot;red&quot;,label=&quot;九月14&quot;)plt.bar(x_15,b15,width=0.2,color=&quot;orange&quot;,label=&quot;九月15&quot;)plt.bar(x_16,b16,width=0.2,color=&quot;blue&quot;,label=&quot;九月16&quot;)#改成竖图后，wight应该改成hightplt.legend(prop=myfont)plt.xticks(range(len(a)),a,fontProperties=myfont)plt.grid(alpha=0.3)#设置网格plt.show()</code></pre><p>暂时的matplotlib到这，更多用法查询csdn</p><h4 id="其他绘图工具推荐"><a href="#其他绘图工具推荐" class="headerlink" title="其他绘图工具推荐"></a>其他绘图工具推荐</h4><p>echart:一个前端js框架</p><p>plotly:一个github上的项目，比matplotlib好看</p><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="创建numpy数组"><a href="#创建numpy数组" class="headerlink" title="创建numpy数组"></a>创建numpy数组</h3><pre><code class="python">import numpy as npt1=np.array([1,2,3])print(t1)print(type(t1))#[1 2 3]#&lt;class &#39;numpy.ndarray&#39;&gt;t2 = np.array(range(10))print(t2)t3 = np.arange(10)print(t3)#效果一样#[0 1 2 3 4 5 6 7 8 9]print(t3.dtype)#int32t3.dtype=floatprint(t3.dtype)#float64t4=np.array([rd.random() for i in range(10)])print(t4)print(t4.dtype)#[0.06217892 0.51319594 0.84344407 0.14711661 0.03576193 0.48263391#0.79937126 0.49026005 0.43495258 0.8738894 ]#float64print(np.round(t4,2))print(t4.dtype)#取两位#[0.99 0.76 0.46 0.78 0.32 0.33 0.   0.56 0.89 0.66]#float64</code></pre><h3 id="numpy数组操作"><a href="#numpy数组操作" class="headerlink" title="numpy数组操作"></a>numpy数组操作</h3><h4 id="改变形状"><a href="#改变形状" class="headerlink" title="改变形状"></a>改变形状</h4><pre><code class="python">import numpy as npimport random as rdt1=np.arange(12)print(t1.shape)t2=np.array([[1,2,3],[3,4,5]])print(t2.shape)#查看形状#修改形状t3=np.arange(12)t4=t3.reshape((3,4))print(t4)#改变形状，注意这里改变形状不对原数组进行改变,原地操作</code></pre><p>注意这里的shape</p><p>(24,)与（24,1）是不一样的，前者的1个24行向量，后者是24个1列向量</p><p>以下是操作：</p><ul><li>t.shape[0]  t.shape[1]分别是行数和列数</li><li>t.flatten()数组降维一维</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>nan:不是一个数字</p><p>INF:无穷</p><ul><li>点加减: t1+2</li><li>点乘除：t1*2</li><li>矩阵相加减：t1+t2（若不符合矩阵运算，某一维度相同时可以计算，效果类似点加减，广播原则）</li><li>矩阵相乘除：t1*t2(以上要符合矩阵运算规律)</li></ul><p>具体查csdn</p><h3 id="numpy读取文件"><a href="#numpy读取文件" class="headerlink" title="numpy读取文件"></a>numpy读取文件</h3><p>现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量([“views”,”likes” , “dislikes”,” comment total”])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作</p><p><a href="https://www.kaggle.com/datasnaek/youtube/data">数据来源</a></p><h3 id="切片索引操作"><a href="#切片索引操作" class="headerlink" title="切片索引操作"></a>切片索引操作</h3><p>见blog</p><p><a href="https://blog.csdn.net/liujian20150808/article/details/81273289?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941748916780299054215%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160941748916780299054215&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-81273289.pc_search_result_cache&utm_term=numpy%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">numpy切片索引操作</a></p><p>或者bilibili视频</p><h3 id="数据拼接"><a href="#数据拼接" class="headerlink" title="数据拼接"></a>数据拼接</h3><p><a href="https://blog.csdn.net/qq_39516859/article/details/80666070?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941769016780277095641%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160941769016780277095641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-80666070.pc_search_result_cache&utm_term=numpy%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5">数组拼接</a></p><h3 id="好的参考blog"><a href="#好的参考blog" class="headerlink" title="好的参考blog"></a>好的参考blog</h3><p><a href="https://blog.csdn.net/weixin_45651336/article/details/111408557?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-2&spm=1001.2101.3001.4242">blog1</a></p><p><a href="https://blog.csdn.net/a373595475/article/details/79580734?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941798816780310237261%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160941798816780310237261&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~hot_rank-1-79580734.pc_v1_rank_blog_v1&utm_term=numpy%E6%93%8D%E4%BD%9C">blog2</a></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;numpy-matplotlib-pandas以及文件批量操作&quot;&gt;&lt;a href=&quot;#numpy-matplotlib-pandas以及文件批量操作&quot; class=&quot;headerlink&quot; title=&quot;numpy,matplotlib,pandas以及文件批量操</summary>
      
    
    
    
    <category term="machine learning" scheme="http://sweetheart.huangtao.xyz/categories/machine-learning/"/>
    
    
    <category term="machine learning" scheme="http://sweetheart.huangtao.xyz/tags/machine-learning/"/>
    
    <category term="numpy" scheme="http://sweetheart.huangtao.xyz/tags/numpy/"/>
    
    <category term="pandas" scheme="http://sweetheart.huangtao.xyz/tags/pandas/"/>
    
    <category term="matplotlib" scheme="http://sweetheart.huangtao.xyz/tags/matplotlib/"/>
    
    <category term="文件批量操作" scheme="http://sweetheart.huangtao.xyz/tags/%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>matlab基础使用(更新中)</title>
    <link href="http://sweetheart.huangtao.xyz/2020/08/15/matlab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://sweetheart.huangtao.xyz/2020/08/15/matlab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-15T14:01:13.000Z</published>
    <updated>2020-08-28T06:45:10.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab基础使用"><a href="#Matlab基础使用" class="headerlink" title="Matlab基础使用"></a>Matlab基础使用</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>和之前那篇不同的是，这篇文章记录了matlab基础使用的方法，总共也就那么几个部分</p><ul><li>向量运算</li><li>多项式运算</li><li>矩阵运算</li><li>符号运算</li><li>数列求和与函数极限与导数操作</li><li>函数积分</li><li>方程求解</li><li>微分方程//曲线方程</li><li>拟合插值（这个我更倾向于excel）</li><li>程序设计</li><li>二维绘图</li><li>三维绘图</li></ul><p>大概基础就这么多了，之前知识都是散的于是来个汇总。真·边复习高数线代边用matlab解高数线代题。</p><h2 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h2><p>向量：行矩阵列矩阵，秩数为1</p><h3 id="向量创建"><a href="#向量创建" class="headerlink" title="向量创建"></a>向量创建</h3><ul><li>直接创建：a=[1,2,3,4]</li><li>步距创建：a=1:4</li><li>函数生成：a=linspace(0,10,6),从0到10共六个数的向量,自动求步距</li><li>对数分割：a=logspace(1,3,3),表示三个数，10的1次到10的3次</li></ul><h4 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h4><pre><code>- 加法- 减法- 数乘- 求内积：dot(a，b)- 求外积：cross(a,b)- 混合积：dot(a,cross(b,c))</code></pre><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><h3 id="单元型变量"><a href="#单元型变量" class="headerlink" title="单元型变量"></a>单元型变量</h3><ul><li>类似于结构体</li><li>cell来表示，排列方式又类似于矩阵</li></ul><h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><ul><li>struct创建</li><li>要求键值对对应：struct(‘a’,{A});</li></ul><h2 id="多项式操作"><a href="#多项式操作" class="headerlink" title="多项式操作"></a>多项式操作</h2><h4 id="多项式创建"><a href="#多项式创建" class="headerlink" title="多项式创建"></a>多项式创建</h4><ul><li>直接创建：’ax+bx^n’</li><li>向量加函数创建：ploy2sym(p)，p中元素按照顺序分别为n次到0次的系数</li></ul><h4 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h4><ul><li>乘法：conv(a,b),ab分别为向量</li><li>除法：decov(a,b),同上</li></ul><h4 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h4><p>​    步骤：</p><pre><code>- 先向量创建成多项式符号函数- 利用polyder()给多项式求导，得出导数的系数向量- 然后在系数向量创建</code></pre><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><p>基础操作：</p><h3 id="矩阵创建："><a href="#矩阵创建：" class="headerlink" title="矩阵创建："></a>矩阵创建：</h3><ul><li>rand()</li><li>zeros()</li><li>ones()</li><li>eye()</li></ul><p>主要就是这些</p><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul><li>删除元素：将某一行设置为空列表，例如：a(m;:)=[]</li><li>元素赋值，a(m,n)=b</li><li>组合矩阵</li></ul><h4 id="变维变向抽取"><a href="#变维变向抽取" class="headerlink" title="变维变向抽取"></a>变维变向抽取</h4><ul><li>变维：reshape():根据顺序以列的顺序上下重排元素</li><li>变向：翻转，基本上不用</li><li>抽取元素：<ul><li>diag()</li><li>tril()，下三角</li><li>triu(),上三角</li></ul></li></ul><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><ul><li>加法</li><li>减法</li><li>数乘</li><li>乘法</li><li>点乘，A.*B</li><li>除法，记得区分左除\和一般除法/（右除）</li><li>幂运算:A^n,  A.^n</li><li>求逆：inv(A)，pinv(A)</li><li>求秩：rank(A)</li><li>转置：s’</li><li>求行列式det(C)</li></ul><h2 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h2><h3 id="符号与数值转换"><a href="#符号与数值转换" class="headerlink" title="符号与数值转换"></a>符号与数值转换</h3><ul><li><p>sym():数值转换成分数</p></li><li><p>eval():分数转化为小数（同时也可以用vpa()对某个表达式求数值解）</p></li><li><p>设置表达式数值精度：digits(D)//d为有效数字个数-&gt;vpa(s)或者vpa(s,d)</p></li></ul><h3 id="符号创建"><a href="#符号创建" class="headerlink" title="符号创建"></a>符号创建</h3><ul><li>x=sym(‘x’)创建符号变量</li><li>syms x 进行定义</li><li>矩阵创建sym(‘a’,n);</li></ul><h3 id="数值带入表达式"><a href="#数值带入表达式" class="headerlink" title="数值带入表达式"></a>数值带入表达式</h3><ul><li>sub(f，x,c)：f为表达式，x是变量，c是数值</li></ul><h3 id="符号运算-1"><a href="#符号运算-1" class="headerlink" title="符号运算"></a>符号运算</h3><ul><li>因式分解：factor(f)：f是表达式，或者用sym()转化的数值，转化为质数乘积表达式</li><li>幂函数展开：expand(f):比如展开x（x+1)</li><li>求通分后的分子分母：[n，m]=numden(F)，n是分子，m是分母</li></ul><h2 id="数列求和求积与函数极限与导数操作与级数求和"><a href="#数列求和求积与函数极限与导数操作与级数求和" class="headerlink" title="数列求和求积与函数极限与导数操作与级数求和"></a>数列求和求积与函数极限与导数操作与级数求和</h2><h3 id="数列求和"><a href="#数列求和" class="headerlink" title="数列求和"></a>数列求和</h3><h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><ul><li>sum(1:n)返回1到n的累加和</li><li>sun（a),a是矩阵，返回各个列的累加和，结果组成行矩阵</li><li>sum(a,1or2),1表示不求和，2表示求和结果等于原来数列的和，若a是矩阵，啧1对列求和2对行求和</li><li>nansum(),忽略累加中的nan</li></ul><h4 id="cumsum"><a href="#cumsum" class="headerlink" title="cumsum"></a>cumsum</h4><ul><li>求该元素前的累积和加上该元素的和</li></ul><h3 id="数列求积-数值求和"><a href="#数列求积-数值求和" class="headerlink" title="数列求积(数值求和)"></a>数列求积(数值求和)</h3><h4 id="prod"><a href="#prod" class="headerlink" title="prod"></a>prod</h4><ul><li>用法同sum,但是是求积</li></ul><h4 id="cumprod"><a href="#cumprod" class="headerlink" title="cumprod"></a>cumprod</h4><ul><li>用法同cumsum，但是求积</li></ul><h3 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h3><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>默认求极小值</p><p>使用步骤：</p><p>1.定义变量syms x</p><p>2.带入limit(f,范围)，例子：limit((1+1/n)^n,inf)</p><p><strong>多元求极限</strong>：</p><p>syms x y</p><p>f=(exp(x+exp(y))/(cos(x)-sin(y))</p><p>limit(limit(f,x,0),y,0)</p><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>diff(f,x,n):求f函数关于x的n阶数导</p><p>diff(f，n):求n阶导数</p><p>可知可以通过这种方式求偏导</p><h3 id="级数求和（符号求和）"><a href="#级数求和（符号求和）" class="headerlink" title="级数求和（符号求和）"></a>级数求和（符号求和）</h3><h4 id="symsum"><a href="#symsum" class="headerlink" title="symsum"></a>symsum</h4><ul><li>symsum（f，x,a,b),f关于x从a到b的所有和</li><li>结果用vpa()转换</li><li>无穷级数symsum(f,0,inf)表示，结果用vpa转换</li></ul><h2 id="函数积分"><a href="#函数积分" class="headerlink" title="函数积分"></a>函数积分</h2><h3 id="定积分和不定积分"><a href="#定积分和不定积分" class="headerlink" title="定积分和不定积分"></a>定积分和不定积分</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><ul><li>int(f,x,a,b):求f关于x在a到b上的定积分，然后用vpa表示数值</li><li>int(f,x,0,inf):求反常积分</li><li>不定积分就相对于定积分少一个范围参数</li></ul><h3 id="重积分"><a href="#重积分" class="headerlink" title="重积分"></a>重积分</h3><h4 id="dblquad（二重积分求解快捷方式）"><a href="#dblquad（二重积分求解快捷方式）" class="headerlink" title="dblquad（二重积分求解快捷方式）"></a>dblquad（二重积分求解快捷方式）</h4><ul><li><p>dblquad(f,xm,xM,ym,yM)</p><p>或者也可以用int来求解,int（）通过调换参数可以实现多元积分</p></li></ul><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><h4 id="taylor"><a href="#taylor" class="headerlink" title="taylor()"></a>taylor()</h4><ul><li>taylor(f,m,a),求f以x0=a，的情况下的m阶泰勒展开，当a舍去的时候，求麦克劳林展开</li><li>taylor(f,’order’,n)求n阶麦克劳林展开</li></ul><h4 id="傅里叶展开"><a href="#傅里叶展开" class="headerlink" title="傅里叶展开"></a>傅里叶展开</h4><h4 id="Fourierzpi"><a href="#Fourierzpi" class="headerlink" title="Fourierzpi()"></a>Fourierzpi()</h4><ul><li>[a0,an,bn]=Fourierzpi(f)直接出表达式</li></ul><h2 id="方程求解"><a href="#方程求解" class="headerlink" title="方程求解"></a>方程求解</h2><h3 id="线性方程求解"><a href="#线性方程求解" class="headerlink" title="线性方程求解"></a>线性方程求解</h3><ul><li><p>除法求解：（当解唯一时）</p><p>​    X=A\B 注意是左除即左乘上A的逆矩阵</p></li><li><p>求齐次通解：</p><p>​    1 判断是否是：唯一解，无穷解，有解</p><p>​    2 null函数求通解：X=null(A,’r’),A是齐次方程的系数矩阵，’r’表示有理数形式返回</p></li><li><p>求非齐次通解：</p><p>​    1 先用伪逆求特解：x0=pinv(A)*B,不用A满秩</p><p>​    2 然后求同届 null(A,’r’);</p></li><li><p>将增广矩阵化为行阶梯型，求行阶梯型矩阵，</p><p>​    1x=rref(AB);AB是增广矩阵</p><p>​    2解为曾广矩阵最后一列</p></li></ul><h3 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h3><ul><li>x=fzero(f,x0)</li></ul><h3 id="非线性方程组求解"><a href="#非线性方程组求解" class="headerlink" title="非线性方程组求解"></a>非线性方程组求解</h3><ul><li>x=fsolve(f,x0)</li></ul><h2 id="微分方程求解"><a href="#微分方程求解" class="headerlink" title="微分方程求解"></a>微分方程求解</h2><ul><li><p>dsolve</p><ul><li><p>示例：</p><p>y=dsolve(‘(Dy)^2-x*Dy+y=0’,’x);</p></li></ul></li></ul><h3 id="微分方程求特解"><a href="#微分方程求特解" class="headerlink" title="微分方程求特解"></a>微分方程求特解</h3><p>示例：y=dsolve(‘(D2y)*x-5Dy=-x^3’,’y(1)=0,y(5)=0’,x)</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>建议excel</p><h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><h3 id="polyfit"><a href="#polyfit" class="headerlink" title="polyfit"></a>polyfit</h3><p>y=polyfit(x,y,n),用<strong>n阶多项式</strong>来拟合x，y数据</p><p>注意，最后呈现的不是一个曲线形式而是求出一个多项式的系数向量；</p><h3 id="linefit"><a href="#linefit" class="headerlink" title="linefit"></a>linefit</h3><p>顾名思义，直线拟合，基于最小二乘法</p><p>[k,b]=linefit(x,y),求出系数和截距</p><p>然后用y1=polyval([k,b],x);生成多项式函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Matlab基础使用&quot;&gt;&lt;a href=&quot;#Matlab基础使用&quot; class=&quot;headerlink&quot; title=&quot;Matlab基础使用&quot;&gt;&lt;/a&gt;Matlab基础使用&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;head</summary>
      
    
    
    
    <category term="数学建模" scheme="http://sweetheart.huangtao.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="matlab" scheme="http://sweetheart.huangtao.xyz/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>蒟蒻的matlab实战笔记（更新中）</title>
    <link href="http://sweetheart.huangtao.xyz/2020/08/15/%E8%92%9F%E8%92%BB%E7%9A%84matlab%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.huangtao.xyz/2020/08/15/%E8%92%9F%E8%92%BB%E7%9A%84matlab%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-15T10:05:04.000Z</published>
    <updated>2020-08-15T18:09:59.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab-实战笔记"><a href="#Matlab-实战笔记" class="headerlink" title="Matlab 实战笔记"></a>Matlab 实战笔记</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>暑假为了参加国赛学习了matlab（白给的可能性比较大毕竟第一次参加比赛还撞上开学考试），看了也快有半月多一点了，之前基本上就是看书，会了点线性规划图论微分方程积分等等，然而实践出真知，具体问题还得具体分析。于是从今天起开始对着那本黄书上的案例（数学建模算法与应用）大致复现一遍，顺便做些课后题目，希望能有所收获（事实证明这玩意突然就实战真的能把人搞自闭，走一步是一步），并且配合excel（用这个画图或者进行曲线拟合）进行。</p><p>​    需要：</p><ul><li>Matlab2018b</li><li>《数学建模算法与应用》</li><li>《matlab从入门到精通》</li><li>交流群嫖来的代码</li><li>CSDN解答</li></ul><p>​    那么现在就开始叭</p><h2 id="DAY-1-线性规划-整数规划-非线性规划"><a href="#DAY-1-线性规划-整数规划-非线性规划" class="headerlink" title="DAY 1 线性规划/整数规划/非线性规划"></a>DAY 1 线性规划/整数规划/非线性规划</h2><h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><h4 id="linprog函数"><a href="#linprog函数" class="headerlink" title="linprog函数"></a>linprog函数</h4><p>linprog是求解线性规划的重要函数</p><p>求解线性规划的函数：</p><p>​    <img src="http://pan-yz.chaoxing.com/preview/showpreview_501461499312701440.html?v=1597487340000" alt="求解所用的linprog函数"></p><p>关于lingprog的一些注意事项：</p><ul><li><p>求解结果是线性最小值<strong>当求最大值时一定要把系数为负！！！</strong></p><ul><li><p>f是多元一次线性式的系数（当未知数矩阵是行矩阵，注意是列矩阵）<strong>同时这要求当求max时对应y变为负</strong></p></li><li><p>A是不等式的系数矩阵</p></li><li><p>b是不等式的常数项矩阵</p></li><li><p>要求不等式是小于等于关系<strong>大于等于关系时时对应系数变为负数转换成小于等于</strong>；</p></li><li><p>Aeq和beq是等式约束；</p></li><li><p>lb是各变量下限，要求为列矩阵，ub是上限也是列矩阵；</p></li><li><p>当无某一项约束时，用空矩阵[]代替</p><p>以下为代码案例</p><pre><code>&gt;&gt; clear all&gt;&gt; f=[2;3;1];&gt;&gt; a=[1,4,2;3,2,0];&gt;&gt; a=[-1,-4,-2;-3,-2,0];&gt;&gt; b=[-8;-6];&gt;&gt; [x,y]=linprog(f,a,b,[],[],zeros(3,1));Optimal solution found.//说明运行成功&gt;&gt; x,yx =   2.0000        0   3.0000</code></pre></li></ul></li></ul><p>   y =</p><pre><code>    7</code></pre><p>   ```</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>   编写函数要：</p><ul><li>文件名要和函数名字一样；</li><li>函数要以end结尾；</li><li>工程文件要和函数文件在同一个文件夹下</li></ul><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><h4 id="intlinprog"><a href="#intlinprog" class="headerlink" title="intlinprog"></a>intlinprog</h4><p>​    这是解整数规划的函数使用方法和linprog一样；</p><p>​    <img src="http://imageproxy.chaoxing.com/0x0,q15,jpeg,suFgohD7APLCb6Cke59_2e4xL3xgbs2RgrOVhoeo1w18/http://p.ananas.chaoxing.com/star3/origin/ec92e0ecd6278c84a24712d5c0c59365.png" alt="intlinprog"></p><p>不同的是，整数规划多了限制参数；</p><h3 id="非线性整数规划"><a href="#非线性整数规划" class="headerlink" title="非线性整数规划"></a>非线性整数规划</h3><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_501489184993955840.html?v=1597493941000" alt="当你线性规划用多项式的时候"></p><p>​    很显然，多了函数入口；</p><p>​    使用方法：</p><p>​    <img src="http://pan-yz.chaoxing.com/preview/showpreview_501490501555433472.html?v=1597494257000" alt="使用示例"></p><p>注意函数名要加单引号；</p><h2 id="day2约束问题-图论"><a href="#day2约束问题-图论" class="headerlink" title="day2约束问题/图论"></a>day2约束问题/图论</h2><p>也就是图论开始，我意识到我作为编程手做的最大也就是嫖到算法和函数后套上模型罢了</p><p>只有离散只考了人均水平的垃圾硬看算法看了半天愣是看不出什么所以然，然而事实证明还是matlab的强大的，有现成的图论工具箱，往上套就可以了。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Matlab-实战笔记&quot;&gt;&lt;a href=&quot;#Matlab-实战笔记&quot; class=&quot;headerlink&quot; title=&quot;Matlab 实战笔记&quot;&gt;&lt;/a&gt;Matlab 实战笔记&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;</summary>
      
    
    
    
    <category term="数学建模" scheme="http://sweetheart.huangtao.xyz/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="matlab" scheme="http://sweetheart.huangtao.xyz/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>这是一篇关于创建博客的吐槽（持续更新中）</title>
    <link href="http://sweetheart.huangtao.xyz/2020/08/13/something-about-blog/"/>
    <id>http://sweetheart.huangtao.xyz/2020/08/13/something-about-blog/</id>
    <published>2020-08-13T07:56:42.000Z</published>
    <updated>2020-08-25T16:40:06.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一篇关于创建博客的吐槽"><a href="#这是一篇关于创建博客的吐槽" class="headerlink" title="这是一篇关于创建博客的吐槽"></a>这是一篇关于创建博客的吐槽</h1><p>​    搭了自己第一个博客，过程也算顺利，但还是有不少想吐槽的。</p><p>​    对了，右下角是音乐设置，嫌吵可以调小或者关掉。</p><h2 id="关于github"><a href="#关于github" class="headerlink" title="关于github"></a>关于github</h2><p>​    用github部署的麻烦也不少：</p><h3 id="速度慢"><a href="#速度慢" class="headerlink" title="速度慢"></a>速度慢</h3><p>​    首先是速度，真的好慢啊，从第一篇blog上传完成到全部显示出来，隔了很久，毕竟网站架设在国外，个人博客还是建议搭在gitee上。</p><h3 id="域名会被清掉"><a href="#域名会被清掉" class="headerlink" title="域名会被清掉"></a>域名会被清掉</h3><p>​    每次我hexo d后，也就是上传一篇文章或者对网站进行改动后重新部署到github上（这个过程也慢），设置的域名都会被清掉,导致访问出现404,需要重新在设置里面输入域名，太繁琐了。</p><p>​    如果有好的解决方法欢迎分享鸭</p><h2 id="自己踩过的一些坑"><a href="#自己踩过的一些坑" class="headerlink" title="自己踩过的一些坑"></a>自己踩过的一些坑</h2><h3 id="不要乱改配置文件"><a href="#不要乱改配置文件" class="headerlink" title="不要乱改配置文件"></a>不要乱改配置文件</h3><p>​    <del>为了追求刺激</del>为了美观实用，把matery的_config.yml文件改得面目全非，结果美观的目的是达到了，但生成的index.html打开是空的,也就是上传的博客文章打开只有空白网页（泪目）。查了下也不是路径的问题，就是不知道乱动了哪里导致生成空白网页（可能是留言板那的设置），估摸着估计是找不到原因了，于是单独重下matery的config.yml文件，然后不乱改了，问题解决。</p><h3 id="部署后404"><a href="#部署后404" class="headerlink" title="部署后404"></a>部署后404</h3><p>​    主要原因还是每次更新到github设置的域名都会被清掉，重新设置后就解决了，但是真的好麻烦啊。</p><h3 id="首页图片被覆盖的颜色太浓"><a href="#首页图片被覆盖的颜色太浓" class="headerlink" title="首页图片被覆盖的颜色太浓"></a>首页图片被覆盖的颜色太浓</h3><p>​    改matery主题的source文件夹下的matery.css</p><p>​    具体是这三个：</p><pre><code class="kotlin">   /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &amp;#123;    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&amp;#125;@-webkit-keyframes rainbow &amp;#123;   /* 动态切换背景颜色. */&amp;#125;@keyframes rainbow &amp;#123;    /* 动态切换背景颜色. */&amp;#125;</code></pre><h3 id="关于markdown笔记无法加载"><a href="#关于markdown笔记无法加载" class="headerlink" title="关于markdown笔记无法加载"></a>关于markdown笔记无法加载</h3><pre><code>title: “something_about_blogdate: 2020-08-13 15:56:42tags: [技术总结, 吐槽, 避雷]categories: 杂谈</code></pre><p>这是这篇文章markdown的设置，注意：</p><ul><li>每个设置之后都与内容有一个空格隔开，不然会报错，</li><li>tag列表里面每个逗号后面都要有空格，不然也会报错</li></ul><h2 id="待实现的功能"><a href="#待实现的功能" class="headerlink" title="待实现的功能"></a>待实现的功能</h2><p>先记下来有时间做下</p><ul><li>首页图片实现轮播</li><li>每个文章的封面都是一样的</li><li>留言板</li><li>字数统计</li></ul><hr><p>大概就这些了</p><h2 id="8月15日更新"><a href="#8月15日更新" class="headerlink" title="8月15日更新"></a>8月15日更新</h2><ul><li><p>通过在sourse文件夹下添加了写入域名的CNAME文件，解决了部署后域名失效的问题</p></li><li><p>通过调整hexo-theme-matery\layout_partial下的bg-cover-content.ejs文件，成功将首页图变成了刷新一次切换一次</p><p>代码如下：</p></li></ul><pre><code>&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    var bannerUrl = &quot;&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for(&#39;/medias/banner/&#39;) %&gt;&quot; + (new Date().getSeconds())%7 + &#39;.jpg&#39;;    //把getDay（）改成getSecond（）并且对7取余数(因为只有七张图片，如果有多张可以对图片数取余)    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(&#39; + bannerUrl + &#39;)&#39;);&lt;/script&gt;</code></pre><ul><li>添加了点击就推荐奶茶的特效（其实还整了烟花特效但真的太花了还是少点特效好）</li><li>去掉了首页图的滤镜特效，（太难看了www为什么开发者要这么设置，明明审美也不差）</li><li>完善了友链</li><li>超星网盘当图床是真的香啊</li><li>开启了背景动态图</li><li>修改了首页栏的透明度</li><li>去掉了音乐（这玩意太吵了，自己都看不下去了）</li></ul><h2 id="8月25日更新"><a href="#8月25日更新" class="headerlink" title="8月25日更新"></a>8月25日更新</h2><ul><li>实现了留言板功能，然而目前好像不支持markdown格式</li><li>迷上了小林家的龙女仆，修改了首页，（康娜托尔suki!)</li></ul><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一篇关于创建博客的吐槽&quot;&gt;&lt;a href=&quot;#这是一篇关于创建博客的吐槽&quot; class=&quot;headerlink&quot; title=&quot;这是一篇关于创建博客的吐槽&quot;&gt;&lt;/a&gt;这是一篇关于创建博客的吐槽&lt;/h1&gt;&lt;p&gt;​    搭了自己第一个博客，过程也算顺利，但还是有</summary>
      
    
    
    
    <category term="杂谈" scheme="http://sweetheart.huangtao.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="总结" scheme="http://sweetheart.huangtao.xyz/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="避雷" scheme="http://sweetheart.huangtao.xyz/tags/%E9%81%BF%E9%9B%B7/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇blog</title>
    <link href="http://sweetheart.huangtao.xyz/2020/08/13/my_first_blog/"/>
    <id>http://sweetheart.huangtao.xyz/2020/08/13/my_first_blog/</id>
    <published>2020-08-13T03:29:30.000Z</published>
    <updated>2020-08-16T18:54:57.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇blog"><a href="#我的第一篇blog" class="headerlink" title="我的第一篇blog"></a>我的第一篇blog</h1><h2 id="大概是心路历程？"><a href="#大概是心路历程？" class="headerlink" title="大概是心路历程？"></a>大概是心路历程？</h2><p>​    大概在期中的时候就想着要不做一个自己的blog叭，里面放些日常，自己画的画，技术总结（或许还有秀恩爱？）然后在B站搜索blog搭建从入门到精通之类的balalabala。emmmmm，白嫖党看见要花钱注册域名买服务器就不想动了，反正也只是想搭着玩没什么大用处，还不如在QQ空间微博CSDN里面BB。后来了解到可以将blog部署在github便有了兴趣，然而由于懒一直没动，下次一定下次一定。</p><p>​    恰巧在前几天刷b站正好看见一个搭建的视频（保姆级），挺喜欢这个hexo主题，于是便捣鼓出来了这个基于hexo的matery个人blog。搭建完改了改，换上了自己在推特上收集的各种图片（老二次元了）。域名是ht给的，当然他一开始给的非常屑，不过现在的我很满意。这个主题居然还有打赏的功能，i了i了，但还有一些功能没有实现，比如好友评论，有时间做一下。</p><p>​    音乐在右下角，嫌弃吵可以调小点</p><p>​    没了没了</p><hr><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><h3 id="视频和文档"><a href="#视频和文档" class="headerlink" title="视频和文档"></a>视频和文档</h3><p>​    blog搭建的视频地址：</p><p>​    <a href="https://www.bilibili.com/video/BV1je41147Ma">bilibili保姆级基于hexo框架的建站视频</a>  </p><p>​    感谢up的博客提供的支持：</p><p>​    <a href="https://rika0-0.github.io/">up的技术博客</a></p><h3 id="需要："><a href="#需要：" class="headerlink" title="需要："></a>需要：</h3><ul><li><p>一个github账号</p></li><li><p>nodejs环境</p></li><li><p>git环境</p></li><li><p>html css js基础（后期diy需要）</p></li><li><p>markdown语法基础（建议VSCode or Typora编辑器）</p></li><li><p><del>一个提供虐狗域名的npy</del></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的第一篇blog&quot;&gt;&lt;a href=&quot;#我的第一篇blog&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇blog&quot;&gt;&lt;/a&gt;我的第一篇blog&lt;/h1&gt;&lt;h2 id=&quot;大概是心路历程？&quot;&gt;&lt;a href=&quot;#大概是心路历程？&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="css" scheme="http://sweetheart.huangtao.xyz/tags/css/"/>
    
    <category term="html" scheme="http://sweetheart.huangtao.xyz/tags/html/"/>
    
    <category term="web" scheme="http://sweetheart.huangtao.xyz/tags/web/"/>
    
    <category term="markdown" scheme="http://sweetheart.huangtao.xyz/tags/markdown/"/>
    
  </entry>
  
</feed>
