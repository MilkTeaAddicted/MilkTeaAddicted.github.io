<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MilkTeaAddicted</title>
  
  <subtitle>欢迎来到晓沐的主页</subtitle>
  <link href="http://sweetheart.nefu.site/atom.xml" rel="self"/>
  
  <link href="http://sweetheart.nefu.site/"/>
  <updated>2021-01-28T09:24:27.358Z</updated>
  <id>http://sweetheart.nefu.site/</id>
  
  <author>
    <name>晓沐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 爬虫学习笔记</title>
    <link href="http://sweetheart.nefu.site/2021/01/24/Python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.nefu.site/2021/01/24/Python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-24T01:18:36.000Z</published>
    <updated>2021-01-28T09:24:27.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-爬虫笔记"><a href="#Python-爬虫笔记" class="headerlink" title="Python 爬虫笔记"></a>Python 爬虫笔记</h1><p>为了学习机器学习时方便获取数据以及日后的web开发</p><p>这个寒假又开始捡起爬虫（其实之前只会基本请求，网页源码全扒下来的那种~~）</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备爬取豆瓣top250的信息</p><p>规律：每页都是以25为间隔</p><p>利用Chrome开发者工具辅助</p><p>需要引入的库：</p><pre><code class="python">import  bs4           #网页解析获取数据import re            #正则表达式，文字匹配import urllib.request,urllib.error  #制定url,获取网页数据import xlwt       # 进行excel操作import   sqlite3  #进行sqlite数据库操作</code></pre><p>代码架构如下：</p><pre><code class="python">def main():                                                                        baseUrl=&quot;https://movie.douban.com/top250&quot;       #基本网址                          # 爬取网页                                                                         savePath=r&quot;.\豆瓣电影Top250.xls&quot;                                                   # 逐一解析数据                                                                       # 保存数据                                                                     # 爬取网页                                                                         def getData():                                                                     datalist=[]                                                                    # 逐一解析数据                                                                       return datalist                                                            def SaveData(savePath):                                                            print()                                                                    if __name__==&quot;__main__&quot;:                                                           main()                                                                     </code></pre><h2 id="urlib用法"><a href="#urlib用法" class="headerlink" title="urlib用法"></a>urlib用法</h2><pre><code class="python">import urllib.request#获取一个get方式response=urllib.request.urlopen(&quot;https://www.baidu.com&quot;)#将网页打开并返回网页数据,就是获得了网页源代码print(response.read().decode(&#39;utf-8&#39;))#打印信息，并且保证中文显示</code></pre><pre><code class="python">import urllib.requestimport urllib.parse#解析器#获取一个post请求data=bytes(urllib.parse.urlencode(&amp;#123;&quot;hellow&quot;:&quot;world&quot;&amp;#125;),encoding=&quot;utf-8&quot;)#转化二进制,解析键值对response=urllib.request.urlopen(r&quot;https://httpbin.org/post&quot;,data=data)print(response.read().decode(&quot;utf-8&quot;))# 返回如下：# &amp;#123;#   &quot;args&quot;: &amp;#123;&amp;#125;,#   &quot;data&quot;: &quot;&quot;,#   &quot;files&quot;: &amp;#123;&amp;#125;,#   &quot;form&quot;: &amp;#123;#     &quot;hellow&quot;: &quot;world&quot;这里是我们请求的数据#   &amp;#125;,#   &quot;headers&quot;: &amp;#123;#     &quot;Accept-Encoding&quot;: &quot;identity&quot;,#     &quot;Content-Length&quot;: &quot;12&quot;,#     &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,#     &quot;Host&quot;: &quot;httpbin.org&quot;,#     &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;,#     &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60102159-645571fd5c4c09b93338b8d5&quot;#   &amp;#125;,#   &quot;json&quot;: null,#   &quot;origin&quot;: &quot;117.65.146.144&quot;,#   &quot;url&quot;: &quot;https://httpbin.org/post&quot;# &amp;#125;</code></pre><pre><code class="python">import urllib.requestimport urllib.parse#解析器#超时try:    response=urllib.request.urlopen(r&quot;https://httpbin.org&quot;,timeout=0.01)    print(response.read())except urllib.error.URLError as e:    print(&quot;超时了&quot;)</code></pre><pre><code class="python">import urllib.requestimport urllib.parse#解析器response=urllib.request.urlopen(r&quot;https://douban.com&quot;)print(response.status)#urllib.error.HTTPError: HTTP Error 418: #表示发现你是一个爬虫了print(response.getheaders())#获取响应头，print(response.getheader(&#39;Set-Cookie&#39;))#获取具体的头部数据</code></pre><p>如何让网页不知道我们是爬虫从而避免418：</p><pre><code class="python">import urllib.requestimport urllib.parse#解析器url=&quot;https://douban.com&quot;headers=&amp;#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;&amp;#125;#网页检查network中从header中复制粘贴来的，req=urllib.request.Request(url=url,headers=headers)response=urllib.request.urlopen(req)print(response.read().decode(&quot;utf-8&quot;))#成功返回了</code></pre><p>编写函数来访问:</p><pre><code class="python">import  bs4           #网页解析获取数据import re            #正则表达式，文字匹配import urllib.request,urllib.error  #制定url,获取网页数据import xlwt       # 进行excel操作import   sqlite3  #进行sqlite数据库操作def main():    baseUrl = &quot;https://movie.douban.com/top250&quot;  # 基本网址    AskUrl(baseUrl)#得到指定URL的内容def AskUrl(url):    head = &amp;#123;#模拟浏览器头部信息        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;    &amp;#125;#用户代理，告诉豆瓣我们可以接受什么类型的文件内容，这里一定要用豆瓣网页的    request=urllib.request.Request(url,headers=head)    html=&quot;&quot;    try:        response=urllib.request.urlopen(request)        html=response.read().decode(&quot;utf-8&quot;)        print(html)    except urllib.error.URLError as e:        if hasattr(e,&quot;code&quot;):            print(e.code)        if hasattr(e,&quot;reason&quot;):            print(e.reason)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>这里逐页获取：</p><pre><code class="python">def main():    baseUrl = &quot;https://movie.douban.com/top250?start=&quot;  # 基本网址    # 爬取网页                                                                         savePath = r&quot;.\豆瓣电影Top250.xls&quot;    # 逐一解析数据                                                                       # 保存数据                                                                         getData()# 爬取网页def getData():    datalist = []    for i in range(0,10):        url=baseurl+str(i*25)        html=AskUrl(url) #保存获取到的源码        # 逐一解析数据    return datalist#得到指定URL的内容def AskUrl(url):    head = &amp;#123;#模拟浏览器头部信息        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;    &amp;#125;#用户代理，告诉豆瓣我们可以接受什么类型的文件内容，这里一定要用豆瓣网页的    request=urllib.request.Request(url,headers=head)    html=&quot;&quot;    try:        response=urllib.request.urlopen(request)        html=response.read().decode(&quot;utf-8&quot;)        print(html)    except urllib.error.URLError as e:        if hasattr(e,&quot;code&quot;):            print(e.code)        if hasattr(e,&quot;reason&quot;):            print(e.reason)    return htmlif __name__ == &quot;__main__&quot;:    main()                                                                     </code></pre><h2 id="BeautifulSoup用法"><a href="#BeautifulSoup用法" class="headerlink" title="BeautifulSoup用法"></a>BeautifulSoup用法</h2><p>BS4可以将文档归档四种类型：</p><ul><li>tag</li><li>navigaableString</li><li>beautifulsoup</li><li>comment</li></ul><p><a href="https://blog.csdn.net/m0_37623485/article/details/88324296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161176637016780299025194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161176637016780299025194&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-88324296.pc_search_result_before_js&utm_term=beautifulsoup&spm=1018.2226.3001.4187">具体用法</a></p><pre><code class="python">from bs4 import BeautifulSoupbs=BeautifulSoup(html,&quot;html.parser&quot;)#解析文件树print(bs.a)print(bs.title)print(bs.header)#这种方式访问标签内容，默认只拿到第一个内容#1.tag及其内容print(bs.title.string)#只知道标签内容，#2.navigableString标签里面的内容print(bs.a.atters)#拿到标签内部超链接以及标签内部的样式名称#获得整个文档内容print(bs)#整个文档print(bs.name)#documentprint(bs.attrs)#&amp;#123;&amp;#125;#3BeautifulSoupprint(ba.a.string)#这里拿到源码的注释的内容。没有注释的符号#文档的遍历#采用下标访问print(bs.head.contents[1])#文档的搜索#字符串过滤t_list=bs.find_all(&quot;a&quot;)#查找所有a标签print(bs.t_list)#正则表达式搜索import ret_list=bs.find_all(re.compile(&quot;a&quot;))#包含a字母的标签#传入一个函数，根据一个函数搜索def name_is_exists(tag):    return tag.has_atter(&quot;name&quot;)#包含name的标签，作为了解t_list=bs.find_all((name_is_exists))#kwargs参数搜索t_list=bs.find_all(id=&quot;head&quot;)#含有id=header的标签中所有内容t_list=bs.find_all(class_=True)#含有clas的标签以及子内容t_list=bs.find_all(href=&quot;http://baidu.com&quot;)#含有此链接的标签t_list=bs.find_all(text=[&quot;百度&quot;,&quot;贴吧&quot;])#3文本参数搜索，将会搜索出文本t_list=bs.find_all(text=re.compile(&quot;\d&quot;))#用正则表达式搜索特点文本内容(标签内字符串）#limit参数t_list=bs.find_all(&quot;a&quot;,limit=3)#限定搜索三个#css选择器t_list=bs.select(&quot;title&quot;)#通过标签查找t_list=bs.select(&quot;.class&quot;)#类名查找t_list=bs.select(&quot;#id&quot;)#id查找t_list=bs.select(&quot;head&gt;title&quot;)#查找子标签t_list=bs.select(&quot;。mnav~.bri&quot;)#查找兄弟标签print(t_list[0].get_text())#找到标签包含的文本内容</code></pre><h2 id="开始爬取"><a href="#开始爬取" class="headerlink" title="开始爬取"></a>开始爬取</h2><pre><code class="python">import refrom bs4 import BeautifulSoupimport urllib.requestimport xlwtfindLink=re.compile(r&#39;&lt;a href=&quot;(.*?)&quot;&gt;&#39;)findImg=re.compile(r&#39;&lt;img.*src=&quot;(.*?)&quot;&#39;,re.S)#忽略换行符findTitle=re.compile(r&#39;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#39;)findRating=re.compile(r&#39;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#39;)findJudge=re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;/span&gt;&#39;)findInq=re.compile(r&#39;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#39;)findBd=re.compile(r&#39;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#39;,re.S)def main():    baseUrl = &quot;https://movie.douban.com/top250?start=&quot;  # 基本网址    # 爬取网页    savePath = r&quot;.\豆瓣电影Top250.xls&quot;    # 逐一解析数据    # 保存数据    datalist=getData(baseUrl)# 爬取网页def getData(baseUrl):    datalist = []    for i in range(0,10):        url=baseUrl+str(i*25)        html=AskUrl(url) #保存获取到的源码        # 逐一解析数据        soup=BeautifulSoup(html,&quot;html.parser&quot;)        for i in soup.find_all(&#39;div&#39;,class_=&quot;item&quot;):#查找目标内容            # print(i) 测试查看全部信息            data=[]            i=str(i)            link=re.findall(findLink,i)[0]            data.append(link)            ImgSrc=re.findall(findImg,i)            data.append(ImgSrc)            titles=re.findall(findTitle,i)            if (len(titles))==2:                ctitle=titles[0]                data.append(ctitle)#添加中文                otitle=titles[1].replace(&quot;/&quot;,&#39;&#39;)#去掉无关的符号                data.append(otitle)#添加外文            else:                data.append(titles[0])                data.append(&#39;暂无外文名&#39;)#注释无外文名            rating=re.findall(findRating,i)[0]#评分            data.append(rating)            judgeNumber=re.findall(findJudge,i)[0]            data.append(judgeNumber)#评价人数            inq=re.findall(findInq,i)            if len(inq)!=0:                inq=inq[0].replace(&quot;。&quot;,&#39;&#39;)#去掉句号            else:                inq=&quot;暂无简介&quot;            data.append(inq)#但是不是每一部都有概述            bd=re.findall(findBd,i)[0]            bd=re.sub(&#39;&lt;br(\s+)?&gt;(\s+)?&#39;,&quot; &quot;,bd)#去掉br            bd=re.sub(&#39;/&#39;,&quot;—&quot;,bd)            data.append(bd.strip())#去掉前后空格            datalist.append(data)#处理好的信息放入列表    print(datalist)    return datalist#得到指定URL的内容def AskUrl(url):    head = &amp;#123;#模拟浏览器头部信息        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;    &amp;#125;#用户代理，告诉豆瓣我们可以接受什么类型的文件内容，这里一定要用豆瓣网页的    request=urllib.request.Request(url,headers=head)    html=&quot;&quot;    try:        response=urllib.request.urlopen(request)        html=response.read().decode(&quot;utf-8&quot;)        # print(html)    except urllib.error.URLError as e:        if hasattr(e,&quot;code&quot;):            print(e.code)        if hasattr(e,&quot;reason&quot;):            print(e.reason)    return htmlif __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><h3 id="xlwt用法"><a href="#xlwt用法" class="headerlink" title="xlwt用法"></a>xlwt用法</h3><pre><code class="python">import xlwtworkbook=xlwt.Workbook(encoding=&quot;utf-8&quot;)#创建workbook对象worksheet=workbook.add_sheet(&#39;sheet1&#39;)#创建工作表worksheet.write(0,0,&quot;hellow&quot;)#向第一个元素写入hellow第一个是行，第二个个是列workbook.save(&quot;表格.xls&quot;)</code></pre><p><a href="https://blog.csdn.net/wangkai_123456/article/details/50457284?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161182435616780261935226%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161182435616780261935226&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-50457284.pc_search_result_before_js&utm_term=xlwt+%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">参考1</a></p><p><a href="https://my.oschina.net/kalnkaya/blog/3020078">参考2</a></p><p>案例：写入九九乘法表</p><pre><code class="python">import xlwtworkbook=xlwt.Workbook(encoding=&quot;utf-8&quot;)#创建workbook对象worksheet=workbook.add_sheet(&#39;sheet1&#39;)#创建工作表for i in range(9):    for j in range(i+1):        worksheet.write(i,j,&quot;%d * %d = %d&quot;%(i+1,j+1,(i+1)*(j+1)))workbook.save(&quot;表格.xls&quot;)</code></pre><h3 id="爬取数据写入"><a href="#爬取数据写入" class="headerlink" title="爬取数据写入"></a>爬取数据写入</h3><pre><code class="python">import refrom bs4 import BeautifulSoupimport urllib.requestimport xlwtfindLink=re.compile(r&#39;&lt;a href=&quot;(.*?)&quot;&gt;&#39;)findImg=re.compile(r&#39;&lt;img.*src=&quot;(.*?)&quot;&#39;,re.S)#忽略换行符findTitle=re.compile(r&#39;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#39;)findRating=re.compile(r&#39;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#39;)findJudge=re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;/span&gt;&#39;)findInq=re.compile(r&#39;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#39;)findBd=re.compile(r&#39;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#39;,re.S)def main():    baseUrl = &quot;https://movie.douban.com/top250?start=&quot;  # 基本网址    # 爬取网页    savePath = r&quot;豆瓣电影Top250.xls&quot;    # 逐一解析数据    # 保存数据    datalist=getData(baseUrl)    SaveData(datalist,savePath)# 爬取网页def getData(baseUrl):    datalist = []    for i in range(0,10):        url=baseUrl+str(i*25)        html=AskUrl(url) #保存获取到的源码        # 逐一解析数据        soup=BeautifulSoup(html,&quot;html.parser&quot;)        for i in soup.find_all(&#39;div&#39;,class_=&quot;item&quot;):#查找目标内容            # print(i) 测试查看全部信息            data=[]            i=str(i)            link=re.findall(findLink,i)[0]            data.append(link)            ImgSrc=re.findall(findImg,i)            data.append(ImgSrc)            titles=re.findall(findTitle,i)            if (len(titles))==2:                ctitle=titles[0]                data.append(ctitle)#添加中文                otitle=titles[1].replace(&quot;/&quot;,&#39;&#39;)#去掉无关的符号                data.append(otitle)#添加外文            else:                data.append(titles[0])                data.append(&#39;暂无外文名&#39;)#注释无外文名            rating=re.findall(findRating,i)[0]#评分            data.append(rating)            judgeNumber=re.findall(findJudge,i)[0]            data.append(judgeNumber)#评价人数            inq=re.findall(findInq,i)            if len(inq)!=0:                inq=inq[0].replace(&quot;。&quot;,&#39;&#39;)#去掉句号            else:                inq=&quot;暂无简介&quot;            data.append(inq)#但是不是每一部都有概述            bd=re.findall(findBd,i)[0]            bd=re.sub(&#39;&lt;br(\s+)?&gt;(\s+)?&#39;,&quot; &quot;,bd)#去掉br            bd=re.sub(&#39;/&#39;,&quot;—&quot;,bd)            data.append(bd.strip())#去掉前后空格            datalist.append(data)#处理好的信息放入列表    print(datalist)    return datalist#得到指定URL的内容def AskUrl(url):    head = &amp;#123;#模拟浏览器头部信息        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;    &amp;#125;#用户代理，告诉豆瓣我们可以接受什么类型的文件内容，这里一定要用豆瓣网页的    request=urllib.request.Request(url,headers=head)    html=&quot;&quot;    try:        response=urllib.request.urlopen(request)        html=response.read().decode(&quot;utf-8&quot;)        # print(html)    except urllib.error.URLError as e:        if hasattr(e,&quot;code&quot;):            print(e.code)        if hasattr(e,&quot;reason&quot;):            print(e.reason)    return htmldef SaveData(datalist,savePath):    film = xlwt.Workbook(encoding=&quot;utf-8&quot;,style_compression=0)  # 创建workbook对象    filmSheet = film.add_sheet(&#39;豆瓣电影250&#39;,cell_overwrite_ok=True)  # 创建工作表 覆盖以前内容    col=(&quot;电影详情链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片外国名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)    for i in range(8):        filmSheet.write(0,i,col[i])#写入第一行    for i in range(250):        print(&quot;第%d条&quot;%i)        data=datalist[i]        for j in range(8):            filmSheet.write(i+1,j,data[j])    film.save(savePath) #保存if __name__ == &quot;__main__&quot;:    main()</code></pre><p>效果如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_561600886733012992.html?v=1611825690000" alt="最终效果图"></p><p><strong>至此基本的网页爬取技巧结束了</strong>，关于爬虫更加深入的引用后面会补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-爬虫笔记&quot;&gt;&lt;a href=&quot;#Python-爬虫笔记&quot; class=&quot;headerlink&quot; title=&quot;Python 爬虫笔记&quot;&gt;&lt;/a&gt;Python 爬虫笔记&lt;/h1&gt;&lt;p&gt;为了学习机器学习时方便获取数据以及日后的web开发&lt;/p&gt;
&lt;p&gt;这</summary>
      
    
    
    
    <category term="web" scheme="http://sweetheart.nefu.site/categories/web/"/>
    
    <category term="Python" scheme="http://sweetheart.nefu.site/categories/web/Python/"/>
    
    <category term="爬虫" scheme="http://sweetheart.nefu.site/categories/web/Python/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="http://sweetheart.nefu.site/tags/Python/"/>
    
    <category term="爬虫" scheme="http://sweetheart.nefu.site/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>神经网络与深度学习练习</title>
    <link href="http://sweetheart.nefu.site/2021/01/19/Python%E5%9F%BA%E7%A1%80%E6%81%A2%E5%A4%8D/"/>
    <id>http://sweetheart.nefu.site/2021/01/19/Python%E5%9F%BA%E7%A1%80%E6%81%A2%E5%A4%8D/</id>
    <published>2021-01-19T07:29:51.000Z</published>
    <updated>2021-02-24T11:04:46.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络与深度学习作业"><a href="#神经网络与深度学习作业" class="headerlink" title="神经网络与深度学习作业"></a>神经网络与深度学习作业</h1><p>大垃圾一年没写python辣（其实去年也学的稀烂），今年要机器学习不得不捡起py开始学</p><p>为了逐步把自己的算法水平移植到py上，于是决定开始Py恢复训练(<strong>其实就是重新学</strong>)</p><p>然后这个笔记主要是存放西安科技大学的神经网络与深度学习的作业代码</p><p>然后也会放一些自己在kaggle或者其他网站数据分析的练习</p><h2 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a>练习1：</h2><blockquote><p>( 20分 )</p><p>作业题1</p><p>要求用户输入一个1-100之间的整数。在屏幕上输出1-1000中所有可以被这个输入数字整除的整数，并把它们写入文本文件中。</p><p><strong>1.基本要求：</strong></p><p>(1) 接收用户输入，并判断是否为1-100之间的整数。如果输入符合要求，则继续执行第(2)步，否则结束程序。</p><p>(2) 根据用户输入，在屏幕上输出1-1000中，所有可以被这个数字整除的数字，并打印序号。序号从1开始，依次加1.</p><p>例如，用户输入20，的情况：</p><p> 请输入一个1-100之间的整数：20</p><p>1 20</p><p>2 40</p><p>3 60</p><p>4 80</p><p>5 100</p><p>……</p><p>46 920</p><p>47 940</p><p>48 960</p><p>49 980</p><p>50 1000</p><p>(3)将第(2)步的输出结果，写入C盘根目录下的文本文件中，文件名为“x的倍数.txt”，例如，输入20，则文件名为：“20的倍数.txt”。</p><p>(4) 添加必要的注释，说明程序设计思路。</p><p><strong>2.提高要求：</strong></p><p>(1) 如果输入不符合要求，则要求用户重新输入，并给出提示信息。具体要求参见第4讲单元作业1。</p><p>(2) 将基本要求中的(1)和(2)，通过函数实现。</p><p>(3) 在程序中需要的地方，捕捉异常，或使用with语句管理资源。</p><p>说明：提交一份程序代码即可。根据实现功能综合得分。</p><p>满足基本要求最高14分，满足提高要求最高20分。</p></blockquote><p>代码：</p><pre><code class="python">print(&quot;请输入1-100之间的整数&quot;)while True:    str=input()    if not str.isdigit():        print(&quot;输入有误,不是整数，请继续&quot;)        continue    elif int(str)&gt;100:        print(&quot;输入有误，不在范围内，请继续&quot;)        continue    elif int(str)&lt;1:        print(&quot;输入有误，不在范围内，请继续&quot;)        continue    else:        print(&quot;输入正确，继续程序&quot;)        with open(&quot;记录用文件.txt&quot;,&quot;w&quot;) as f:            count=1;            for i in range(1,10001):                if i%int(str)==0:                    f.write(&#39;%d: %s \n&#39;%(count,i))                    count+=1        with open(&quot;记录用文件.txt&quot;,&quot;r&quot;) as f:            content=f.readlines()            for i in content:                print(i)</code></pre><h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><blockquote><p>( 10分 )</p><p>生成一个[0,1)之间均匀分布的随机数数组，包含1000个元素， 随机种子为612。接收用户输入一个1-100之间的数字。打印随机数组中所有索引值可以被输入整数整除的数字，并打印序号和索引值。序号从1开始，依次加1. 例如，用户输入50，则打印数组中索引值为0,50,100…1000的随机数。</p><p><strong>程序运行示例：</strong></p><p>请输入一个1-100之间的整数：50</p><p>序号 索引值 随机数</p><p>1   50    0.685693777029538</p><p>2   100   0.8447931162144151</p><p>3   150   0.7043694996423318</p><p>……</p><p>19  950   0.5979676151428348</p><p>20  1000  0.5714978209525051</p><p>提示：输出时可以使用制表符”\t”，对齐各列。</p></blockquote><p>代码：</p><pre><code class="python">import numpy as npnum=int(input(&quot;请输入一个整数，我将会打印打印随机数组中所有索引值可以被输入整数整除的数字：&quot;))np.random.seed(612)a=np.random.rand(1000)count=0for i in range(1,1002):    if i%num ==0:        count += 1        print(&quot;%d\t%d\t%f\n&quot;%(count,i,a[i]))</code></pre><h2 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a>练习3：</h2><blockquote><p>已知:</p><p>x=[ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03]</p><p>y=[ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84]</p></blockquote><p>利用最小二乘法求x与y的回归曲线,代码如下：</p><pre><code class="python">import numpy as npx1=[ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03]y1=[ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84]x=np.array(x1)y=np.array(y1)_x=np.sum(x,axis=0)/np.size(x)_y=np.sum(y,axis=0)/np.size(y)x=x-_xy=y-_yCovXY=np.sum(x*y,axis=0)DX=np.sum(x*x,axis=0)w=CovXY/DXb=_y-w*_xprint(&quot;y=%.3f*x+%.3f&quot;%(w,b))</code></pre><h2 id="练习4："><a href="#练习4：" class="headerlink" title="练习4："></a>练习4：</h2><blockquote><p>己知:</p><p>x0是一个包含长度为10、元素值全部为1的一维数组</p><p>x1=[ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03]</p><p>x2=[2,3,4,2,3,4,2,4,1,3]</p><p>y=[ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84]</p><p>要求:</p><p>(1)将x0、x1、x2堆叠为一个10x3的二维数组X，其中 x0、x1、x2依次是第1列，第2列和第3列;</p><p>​    将y变换为10x1的二维数组Y。</p><p>(2)计算: w=(XTx)1xTY，并回答: w 的shape 属性结果是什么?</p><p>(3)分别输出X，Y和W。</p></blockquote><p>（1）</p><pre><code class="python">import numpy as npx0=np.ones(10)x1=np.array([ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03])x2=np.array([2,3,4,2,3,4,2,4,1,3])y=np.array([ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84])X=np.stack((x0,x1,x2),axis=1)Y=y.reshape(10,1)print(X)print(&quot;\n&quot;)print(Y)</code></pre><p>（2）</p><pre><code class="python">import numpy as npx0=np.ones(10)x1=np.array([ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03])x2=np.array([2,3,4,2,3,4,2,4,1,3])y=np.array([ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84])X=np.stack((x0,x1,x2),axis=1)Y=y.reshape(10,1)X=np.mat(X)Y=np.mat(Y)W=(X.T*X).I*X.T*Yprint(W.shape)#输出（3,1）</code></pre><p>（3）</p><pre><code class="python">import numpy as npx0=np.ones(10)x1=np.array([ 64.3,99.6,145.45,63.75,135.46,92.85,86.97,144.76,59.3,116.03])x2=np.array([2,3,4,2,3,4,2,4,1,3])y=np.array([ 62.55,82.42,132.62,73.31,131.05,86.57,85.49,127.44,55.25,104.84])X=np.stack((x0,x1,x2),axis=1)Y=y.reshape(10,1)X=np.mat(X)Y=np.mat(Y)W=(X.T*X).I*X.T*Yprint(W.shape)print(X,&#39;\n&#39;,Y,&#39;\n&#39;,W)</code></pre><h2 id="练习5："><a href="#练习5：" class="headerlink" title="练习5："></a>练习5：</h2><blockquote><p>( 20分 )</p><p>按下列要求完成程序。</p><p>(1) 下载波士顿数据集，读取全部506条数据，放在NumPy数组x、y中（x：属性，y：标记）。(5分)</p><p>(2) 使用全部506条数据，实现波士顿房价数据集可视化，如图1所示。(10分)</p><p>(3) 要求用户选择属性，如图2所示，根据用户的选择，输出对应属性的散点图，如图3所示。(5分)</p></blockquote><p><img src="https://edu-image.nosdn.127.net/8BC5482320FC3D941D619B74F6B882EE.png?imageView&thumbnail=890x0&quality=100" alt="图1"></p><p><img src="https://edu-image.nosdn.127.net/6DCA15B83A8137CAB44E778A8B31DEC9.png?imageView&thumbnail=890x0&quality=100" alt="图2"></p><p><img src="https://edu-image.nosdn.127.net/B351B147036FFA401C16F27AC536B8B8.png?imageView&thumbnail=890x0&quality=100" alt="图3"></p><p>代码：</p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as pltboston_housing=tf.keras.datasets.boston_housing(x_train,y_tain),(x_test,y_test)=boston_housing.load_data(test_split=0)plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falsetitles = [&quot;CRIM&quot;,&quot;ZN&quot;,&quot;INDUS&quot;,&quot;CHAS&quot;,&quot;NOX&quot;,&quot;RM&quot;,&quot;AGE&quot;,&quot;DIs&quot;,&quot;RAD&quot;,&quot;TAX&quot;,&quot;PTRATIO&quot;,&quot;B-1000&quot;,&quot;LSTAT&quot;,&quot;MEDV&quot;]plt.figure(figsize=(12,15))for i in range(13):    plt.subplot(4,4,(i+1))    plt.scatter(x_train[:,i],y_tain)    plt.xlabel(titles[i])    plt.ylabel(&quot;Price&quot;)    plt.title(str(i+1)+&#39;.&#39;+titles[i]+&#39;-Price&#39;)plt.tight_layout()plt.suptitle(&quot;各个属性与房价的关系&quot;,x=0.5,y=1.02, fontsize=20)plt.show() </code></pre><p>实现用户交互功能：</p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as pltboston_housing=tf.keras.datasets.boston_housing(x_train,y_tain),(x_test,y_test)=boston_housing.load_data(test_split=0)plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falsetitles = [&quot;CRIM&quot;,&quot;ZN&quot;,&quot;INDUS&quot;,&quot;CHAS&quot;,&quot;NOX&quot;,&quot;RM&quot;,&quot;AGE&quot;,&quot;DIs&quot;,&quot;RAD&quot;,&quot;TAX&quot;,&quot;PTRATIO&quot;,&quot;B-1000&quot;,&quot;LSTAT&quot;,&quot;MEDV&quot;]plt.figure(figsize=(12,12))print(&quot;现在有如下属性与索引值：\n&quot;)for i in titles:    print(&quot;%d      %s\n&quot;%(titles.index(i),i))user=int(input(&quot;请输入您想查询的属性与房价的关系(请输入数字):&quot;))print(&quot;显示关系如图：&quot;)plt.scatter(x_train[:,user],y_tain)plt.xlabel(titles[user])plt.ylabel(&quot;Price&quot;)plt.title(titles[user]+&quot;与房价的关系图&quot;)plt.show()</code></pre><p>这里有一个实践上的问题，需要vpn代理开启全局模式才能正常下载数据集，否则无法下载</p><h2 id="练习6："><a href="#练习6：" class="headerlink" title="练习6："></a>练习6：</h2><p>( 20分 )</p><p>使用鸢尾花数据集，绘制如下图形，其中对角线为属性的直方图。</p><p><img src="https://edu-image.nosdn.127.net/AE671975EBF9545FCA03C9576D3FFA7A.png?imageView&thumbnail=890x0&quality=100" alt="示例"></p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitimport numpy as npiris=load_iris()x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0)plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;] = Falseplt.figure(&quot;鸢尾花数据集&quot;, figsize=(15, 15))plt.subplot(&quot;鸢尾花数据图像\nBlue-&gt;Setosa|Red-&gt;Versicolor|Green-&gt;Virginica&quot;)for i in range(4):    for j in range(4):        plt.subplot(4, 4, 4 * i + j + 1)        if j != i:            plt.scatter(x_train[:, j], x_train[:, i], c=y_train, cmap=&#39;brg&#39;)        else:            plt.hist(x_train[:i], align=mid, color=&quot;g&quot;)        if i == 0:            plt.title(COLUN_NAMES[j])        if j == 0:            plt.title(COLUN_NAMES[i])plt.tight_layout(rect=[0, 0, 1, 0.93])plt.show()</code></pre><h2 id="练习7："><a href="#练习7：" class="headerlink" title="练习7："></a>练习7：</h2><p>( 20分 )</p><p>按下列要求完成程序，随机显示MNIST数据集中的样本，效果如图1所示。</p><p><img src="https://edu-image.nosdn.127.net/AAB2FE1BD3009B10E3B80BB7492B64CC.png?imageView&thumbnail=890x0&quality=100" alt="图1"></p><p>要求：</p><p>(1)下载手写数字数据集，读取训练集和测试集数据，放在NumPy数组train_x、train_y、test_x、test_y中；（train_x：训练集图像，train_y：训练集标签，test_x：测试集图像，test_y：测试集标签）</p><p>(2)随机从所有测试集数据中显示16幅数字图像；</p><p>(3)16幅图像按照4×4方式排列在一张画布中，每幅图像的子标题为该图像的标签值，字体大小为14，全局标题为“MNIST测试集样本”，字体大小为20，颜色为红色。</p><p>代码如下：</p><pre><code class="python">import tensorflow as tfimport  numpy as npimport matplotlib.pyplot as pltmnist=tf.keras.datasets.mnist(x1,y1),(x2,y2)=mnist.load_data()plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falsefor i in range(16):    num=np.random.randint(1,5000)    plt.subplot(4,4,i+1)    plt.axis(&quot;off&quot;)    plt.imshow(x1[i],cmap=&quot;gray&quot;)    plt.title(y1[i])plt.tight_layout()plt.suptitle(&quot;手写数字样本 &quot;,x=0.5,y=1.02, fontsize=20)plt.show()</code></pre><h2 id="练习8："><a href="#练习8：" class="headerlink" title="练习8："></a>练习8：</h2><blockquote><p> 15分 )</p><p>使用TensorFlow张量运算计算w和b，并输出结果。</p><p>已知： </p><p>x=[ 64.3, 99.6, 145.45, 63.75, 135.46, 92.85, 86.97, 144.76, 59.3, 116.03]</p><p>y=[ 62.55, 82.42, 132.62, 73.31, 131.05, 86.57, 85.49, 127.44, 55.25, 104.84]</p><p>计算：</p></blockquote><p><img src="https://edu-image.nosdn.127.net/424E0B9805AEEFD7B6682360C6CA2F26.png?imageView&thumbnail=890x0&quality=100" alt="图片"></p><blockquote><p>(3)分别输出W和b的结果。</p><p>提示：</p><p>正确的输出结果为</p><p>w= 0.83215……</p><p>b= 10.2340…….</p></blockquote><p>代码如下：</p><pre><code class="python">import tensorflow as tfx=tf.constant([ 64.3, 99.6, 145.45, 63.75, 135.46, 92.85, 86.97, 144.76, 59.3, 116.03])y=tf.constant([ 62.55, 82.42, 132.62, 73.31, 131.05, 86.57, 85.49, 127.44, 55.25, 104.84])_x=tf.reduce_mean(x)_y=tf.reduce_mean(y)w=tf.reduce_sum((x-_x)*(y-_y))/tf.reduce_sum(tf.square(x-_x))b=_y-w*_xprint(&quot;W的值是：&quot;,w)print(&quot;b的值是：&quot;,b)#输出#W的值是： tf.Tensor(0.83215153, shape=(), dtype=float32)#b的值是： tf.Tensor(10.234009, shape=(), dtype=float32)</code></pre><h2 id="练习9："><a href="#练习9：" class="headerlink" title="练习9："></a>练习9：</h2><blockquote><p>( 15分 )</p><p>使用TensorFlow张量运算计算w和b，并输出结果。</p><p>已知： </p><p>x=[ 64.3, 99.6, 145.45, 63.75, 135.46, 92.85, 86.97, 144.76, 59.3, 116.03]</p><p>y=[ 62.55, 82.42, 132.62, 73.31, 131.05, 86.57, 85.49, 127.44, 55.25, 104.84]</p><p>计算：</p></blockquote><p><img src="https://edu-image.nosdn.127.net/E0ACECBF9E75F5992C9722C4B4E1C7C7.png?imageView&thumbnail=890x0&quality=100"></p><p>(3)分别输出W和b的结果。</p><p>代码如下：</p><pre><code class="python">import tensorflow as tfx=tf.constant([ 64.3, 99.6, 145.45, 63.75, 135.46, 92.85, 86.97, 144.76, 59.3, 116.03])y=tf.constant([ 62.55, 82.42, 132.62, 73.31, 131.05, 86.57, 85.49, 127.44, 55.25, 104.84])w=(len(x)*tf.reduce_sum(x*y)-tf.reduce_sum(x)*tf.reduce_sum(y))/(len(x)*tf.reduce_sum(tf.square(x))-tf.square(tf.reduce_sum(x)))b=(tf.reduce_sum(y)-w*tf.reduce_sum(x))/len(x)print(&quot;W的值是：&quot;,w)print(&quot;b的值是：&quot;,b)# 输出# W的值是： tf.Tensor(0.83215135, shape=(), dtype=float32)# b的值是： tf.Tensor(10.234021, shape=(), dtype=float32)</code></pre><p>可见结果同上一题，说明这是最小二乘法变式</p><p>注意tf.size()无法获取张量元素数（准确说的返回值不是数字），这里用len 来表示</p><h2 id="练习10："><a href="#练习10：" class="headerlink" title="练习10："></a>练习10：</h2><blockquote><p>下载lena.tiff图像（见7.2小节课件），将R、G、B三通道分离，采用灰度图表示颜色的亮度，并分别对各个通道按要求进行处理，结果显示在如图1所示的画布中。</p><p><img src="https://edu-image.nosdn.127.net/14BD7293AF3873250E1366CFC141517E.png?imageView&thumbnail=890x0&quality=100"></p><p>要求：</p><p>(1)将R通道的图像缩小为50×50，显示在子图1中，子标题为:“R-缩放”，字体大小为14；</p><p>(2)将G通道的图像先水平镜像，再顺时针旋转90度，显示在子图2中，子标题为:“G-镜像+旋转”，字体大小为14，并显示坐标轴；</p><p>(3)对B通道的图像进行裁剪，裁剪位置：左上角(0, 0) 右下角(150, 150)，显示在子图3中，子标题为:“B-裁剪”，字体大小为14；</p><p>(4)将原始的R、G、B通道的图像合并，显示在子图4中，子标题显示图像的色彩模式，字体大小为14；</p><p>(5)将要求(4)的处理结果保存为PNG格式的图片，路径为当前工作目录，文件名为“test.png”，如图2所示；</p><p>(6)将以上生成的4幅图像显示在2×2的画布中，全局标题为“图像基本操作”，标题字体大小为20，颜色为蓝色。</p><p>代码如下：</p></blockquote><pre><code class="python">from PIL import Imageimport matplotlib.pyplot as pltlenna=Image.open(&quot;Lenna.jpg&quot;)lenna_r,lenna_g,lenna_b=lenna.split()plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falseplt.figure(figsize=(10,10))plt.subplot(221)plt.axis(&quot;off&quot;)r_resize=lenna_r.resize((50,50))plt.imshow(r_resize,cmap=&quot;gray&quot;)plt.title(&quot;R-缩放&quot;,fontsize=14)plt.subplot(222)g_trans=lenna_g.transpose(Image.FLIP_LEFT_RIGHT).transpose(Image.ROTATE_270)plt.imshow(g_trans,cmap=&quot;gray&quot;)plt.title(&quot;G-镜像+旋转&quot;,fontsize=14)plt.subplot(223)plt.axis(&quot;off&quot;)b_sub=lenna_b.crop((0,0,150,150))plt.imshow(b_sub,cmap=&quot;gray&quot;)plt.title(&quot;B-剪切&quot;,fontsize=14)plt.subplot(224)plt.axis(&quot;off&quot;)merge=Image.merge(&quot;RGB&quot;,[lenna_r,lenna_g,lenna_b])plt.imshow(merge)plt.title(&quot;RGB&quot;,fontsize=14)plt.tight_layout()plt.suptitle(&quot;图像基本操作 &quot;,x=0.5,y=1.02, fontsize=20,color=&quot;blue&quot;)plt.show()plt.savefig(&quot;test.png&quot;)</code></pre><p>展示图片如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_565779590795227136.html?v=1612821971000" alt="lenna图"></p><p>这里用的图是网上下载的，所以出来的结果和展示不一样（尺寸问题）</p><h2 id="练习11："><a href="#练习11：" class="headerlink" title="练习11："></a>练习11：</h2><blockquote><p>使用9.5小节中的“商品房销售记录表”作为样本数据，编程实现一个房价预测系统。</p><p>要求：</p><p>\1. 矩阵运算部分采用TensorFlow实现，数据加载、输入、输出等可以根据需要采用Python/NumPy来实现。</p><p>\2. 提示用户输入商品房面积和房间数，并进行输入校验。合理的输入如下：</p><p>面积：20-500之间的实数</p><p>房间数：1-10之间的整数</p><p>如果输入正确，根据模型估计房价，并显示。</p><p>如果输入数据类型错误，或者输入数据范围不合理，根据错误类型提示，并等待用户重新输入。</p><p>\3. 可视化数据以及预测超平面</p><p>提示：TensorFlow中矩阵求逆函数tf.linalg.inv(）</p><p>数据（符合对应关系）：</p><p>面积：[137.97,104.50,100.00,124.32,79.20,99.00,124.00,114.00,106.69,138.05,53.75,46.91,68.00,63.02,81.26,86.21]</p><p>房间数：</p><p>[3,2,2,3,1,2,3,2,2,3,1,1,1,1,2,2]</p><p>销售价格：</p><p>[145.00,110.00,93.00,116.00,65.32,104.00,118.00,91.00,62.00,133.00,51.00,45.00,78.50,69.65,75.69,95.30]</p></blockquote><p>代码如下：</p><p>解析法：</p><pre><code class="python">import numpy as  npimport tensorflow as tfimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]x1=np.array([137.97,104.50,100.00,124.32,79.20,99.00,124.00,114.00,106.69,138.05,53.75,46.91,68.00,63.02,81.26,86.21])x2=np.array([3,2,2,3,1,2,3,2,2,3,1,1,1,1,2,2])y=np.array([145.00,110.00,93.00,116.00,65.32,104.00,118.00,91.00,62.00,133.00,51.00,45.00,78.50,69.65,75.69,95.30])x0=np.ones(len(x1))X=np.stack((x0,x1,x2),axis=1)Y=np.array(y).reshape(-1,1)Xt=np.transpose(X)XtX_1=np.linalg.inv(np.matmul(Xt,X))XtX_1Xt=np.matmul(XtX_1,Xt)W=np.matmul(XtX_1Xt,Y)W=W.reshape(-1)Y_pre=W[1]*x1+W[2]*x2+W[0]X=np.arange(20,150.1)Y=np.arange(1,10,0.1)X,Y=np.meshgrid(X,Y)Z=W[1]*X+W[2]*Y+W[0]fig=plt.figure()ax3d=Axes3D(fig)surf=ax3d.plot_surface(X,Y,Z,cmap=&quot;rainbow&quot;)ax3d.set_xlabel(&quot;X&quot;,color=&quot;r&quot;,fontsize=14)ax3d.set_ylabel(&quot;Y&quot;,color=&quot;r&quot;,fontsize=14)ax3d.set_zlabel(&quot;price&quot;,color=&quot;r&quot;,fontsize=14)ax3d.scatter(x1,x2,y,color=&quot;b&quot;,marker=&quot;*&quot;,label=&quot;label&quot;)ax3d.scatter(x1,x2,Y_pre,color=&quot;r&quot;,marker=&quot;+&quot;,label=&quot;pred&quot;)plt.suptitle(&quot;回归图&quot;,fontsize=20)print(&quot;请输入商品房面积和房间数,要求符合：\n面积：20-150之间的实数\n房间数：1-10之间的整数&quot;)a=float(input(&quot;请输入面积：&quot;))b=int(input(&quot;请输入房间数：&quot;))# 懒得做输入校验了pred=W[1]*a+W[2]*b+W[0]print(&quot;预测的价格是：%.3f&quot;%pred)ax3d.scatter(a,b,pred,color=&quot;g&quot;,label=&quot;U_pred&quot;)plt.legend()plt.show()</code></pre><p>结果如下：</p><blockquote><p>请输入商品房面积和房间数,要求符合：<br>面积：20-150之间的实数<br>房间数：1-10之间的整数<br>请输入面积：&gt;? 120<br>请输入房间数：&gt;? 4<br>预测的价格是：133.480</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_565801624826130432.html?v=1612827291000" alt="图片1"></p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_565801623249072128.html?v=1612827322000" alt="图片1"></p></blockquote><p>梯度下降法：</p><pre><code class="python">import numpy as  npimport tensorflow as tfimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]area=np.array([137.97,104.50,100.00,124.32,79.20,99.00,124.00,114.00,106.69,138.05,53.75,46.91,68.00,63.02,81.26,86.21])room=np.array([3,2,2,3,1,2,3,2,2,3,1,1,1,1,2,2])price=np.array([145.00,110.00,93.00,116.00,65.32,104.00,118.00,91.00,62.00,133.00,51.00,45.00,78.50,69.65,75.69,95.30])num=len(area)x0=np.ones(num)#归一化处理x1=(area-area.min())/(area.max()-area.min())x2=(room-room.min())/(room.max()-room.min())X=np.stack((x0,x1,x2),axis=1)Y=price.reshape(-1,1)learn_rate=0.2epoch=50display_step=5np.random.seed(612)W=tf.Variable(np.random.randn(3,1))mse=[]for i in range(0,epoch+1):    with tf.GradientTape() as tape:        Pred=tf.matmul(X,W)        Loss=0.5*tf.reduce_mean(tf.square(Y-Pred))    mse.append(Loss)    dL_dw=tape.gradient(Loss,W)    W.assign_sub(learn_rate*dL_dw)    if i % display_step==0:        print(&quot;第%d轮的损失为：%f&quot;%(i,Loss))plt.figure(figsize=(20,8),dpi=120)n=range(0,epoch+1)plt.plot(n,mse,label=&quot;损失函数&quot;)plt.legend(loc=&quot;best&quot;)plt.suptitle(&quot;损失曲线&quot;)plt.show()</code></pre><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_567790281488953344.html?v=1613301355000" alt="损失可视化"></p><h2 id="练习12："><a href="#练习12：" class="headerlink" title="练习12："></a>练习12：</h2><blockquote><p>( 20分 )</p><p>使用波士顿房价数据集中的“低收入人口比例”属性，来训练和测试一元线性回归模型，并对模型进行可视化。</p><p>要求：程序+文本（记录下超参数的调试过程，并简要总结。）</p></blockquote><p>结论就是线性回归train不起来</p><p>首先，这个数据长这个样子：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_567849056738590720.html?v=1613315371000"></p><p>我用线性回归硬train了一发，然后显示预测数据nan（无穷大），然后查看损失，损失可视化显示训练到某一轮的时候突然增大，大概是梯度下降的时候出现问题了</p><p>怀疑是数据的问题，然后我就改了下，选择的数据改成了房间数（就改了数据集切片其他一点也没动）</p><p>然后成功了</p><pre><code class="python">import numpy as  npimport tensorflow as tfimport matplotlib.pyplot as pltboston_housing=tf.keras.datasets.boston_housing(train_x,train_y),(test_x,test_y)=boston_housing.load_data()x_train=train_x[:,5]y_train=train_yx_test=test_x[:,5]y_test=test_ylearn_rate=0.04epoch=2000display_step=200np.random.seed(612)w=tf.Variable(np.random.randn(),dtype=tf.float32)b=tf.Variable(np.random.randn(),dtype=tf.float32)mse_train=[]mse_test=[]for i in range(0,epoch+1):    with tf.GradientTape() as tape:        pred_train=w*x_train+b        loss=0.5*tf.reduce_mean(tf.square(y_train-pred_train))        pred_test=w*x_test+b        loss_=0.5*tf.reduce_mean(tf.square(y_test-pred_test))    mse_train.append(loss)    mse_test.append(loss_)    dl_dw,dl_db=tape.gradient(loss,[w,b])    w.assign_sub(learn_rate*dl_dw)    b.assign_sub(learn_rate*dl_db)plt.figure(figsize=(15,10),dpi=150)plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.subplot(221)plt.scatter(x_train,y_train,color=&quot;blue&quot;,label=&quot;data&quot;)plt.plot(x_train,pred_train,color=&quot;red&quot;,label=&quot;predict&quot;)plt.legend(loc=&quot;upper right&quot;)plt.title(&quot;数据与预测曲线&quot;)plt.subplot(222)plt.plot(mse_train,color=&quot;blue&quot;,linewidth=3,label=&quot;train loss&quot;)plt.plot(mse_test,color=&quot;red&quot;,linewidth=1.5,label=&quot;test loss&quot;)plt.legend(loc=&quot;upper right&quot;)plt.title(&quot;损失可视化&quot;)plt.subplot(223)plt.plot(y_train,color=&quot;blue&quot;,marker=&quot;*&quot;,label=&quot;true_price&quot;)plt.plot(pred_train,color=&quot;red&quot;,marker=&quot;.&quot;,label=&quot;predict&quot;)plt.legend()plt.title(&quot;训练集对照&quot;)plt.subplot(224)plt.plot(y_test,color=&quot;blue&quot;,marker=&quot;*&quot;,label=&quot;true_price&quot;)plt.plot(pred_test,color=&quot;red&quot;,marker=&quot;.&quot;,label=&quot;predict&quot;)plt.legend()plt.title(&quot;测试集对照&quot;)plt.tight_layout()plt.show()</code></pre><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_567850538144219136.html?v=1613315720000"></p><h2 id="练习13："><a href="#练习13：" class="headerlink" title="练习13："></a>练习13：</h2><blockquote><p>使用波士顿房价数据集中的所有属性，训练和测试多元线性回归模型，并可视化模型。</p><p>要求：程序+文本（记录下超参数的调试过程，并简要总结）</p></blockquote><pre><code class="python">import numpy as  npimport tensorflow as tfimport matplotlib.pyplot as pltboston_housing=tf.keras.datasets.boston_housing(train_x,train_y),(test_x,test_y)=boston_housing.load_data()x_train=(train_x-train_x.min(axis=0))/(train_x.max(axis=0)-train_x.min(axis=0))y_train=train_yx_test=(test_x-test_x.min(axis=0))/(test_x.max(axis=0)-test_x.min(axis=0))y_test=test_yx0_train=np.ones(len(train_x)).reshape(-1,1)x0_test=np.ones(len(test_x)).reshape(-1,1)X_train=tf.cast(tf.concat([x0_train,x_train],axis=1),tf.float32)X_test=tf.cast(tf.concat([x0_test,x_test],axis=1),tf.float32)Y_train=tf.constant(y_train.reshape(-1,1),tf.float32)Y_test=tf.constant(y_test.reshape(-1,1),tf.float32)learn_rate=0.01epoch=2000np.random.seed(612)w=tf.Variable(np.random.randn(14,1),dtype=tf.float32)b=tf.Variable(np.random.randn(14,1),dtype=tf.float32)mse_train=[]mse_test=[]for i in range(0,epoch+1):    with tf.GradientTape() as tape:        pred_train=tf.matmul(X_train,w)        loss=0.5*tf.reduce_mean(tf.square(Y_train-pred_train))        pred_test=tf.matmul(X_test,w)        loss_=0.5*tf.reduce_mean(tf.square(Y_test-pred_test))    mse_train.append(loss)    mse_test.append(loss_)    dl_dw=tape.gradient(loss,w)    w.assign_sub(learn_rate*dl_dw)plt.figure(figsize=(15,4),dpi=150)plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.subplot(131)plt.plot(mse_train,color=&quot;blue&quot;,linewidth=3,label=&quot;train loss&quot;)plt.plot(mse_test,color=&quot;red&quot;,linewidth=1.5,label=&quot;test loss&quot;)plt.legend(loc=&quot;upper right&quot;)plt.title(&quot;损失可视化&quot;)plt.subplot(132)plt.plot(y_train,color=&quot;blue&quot;,marker=&quot;*&quot;,label=&quot;true_price&quot;)plt.plot(pred_train,color=&quot;red&quot;,marker=&quot;.&quot;,label=&quot;predict&quot;)plt.legend()plt.title(&quot;训练集对照&quot;)plt.subplot(133)plt.plot(y_test,color=&quot;blue&quot;,marker=&quot;*&quot;,label=&quot;true_price&quot;)plt.plot(pred_test,color=&quot;red&quot;,marker=&quot;.&quot;,label=&quot;predict&quot;)plt.legend()plt.title(&quot;测试集对照&quot;)plt.tight_layout()plt.show()</code></pre><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_567855084990627840.html?v=1613316805000"></p><p>可见预测比单一数据要好</p><h2 id="练习14："><a href="#练习14：" class="headerlink" title="练习14："></a>练习14：</h2><blockquote><p>( 15分 )</p><p>选择不同的2种属性组合，区分山鸢尾和维吉尼亚鸢尾，编写程序，记录并分析结果，给出总结。</p><p>(1) 编写代码 (8分)</p><p>(2) 记录结果 (5分)</p><p>  比较选择不同属性组合时的学习率、迭代次数、以及在训练集和测试集上的交叉熵损失和准确率，以表格或合适的图表形式展示。</p><p>(3) 总结 (2分)</p><p>  采用不同的属性组合效果是否相同，如果相同或者不同，对你有什么启发。</p></blockquote><p><img src="https://edu-image.nosdn.127.net/AE671975EBF9545FCA03C9576D3FFA7A.png?imageView&thumbnail=890x0&quality=100" alt="示例"></p><p>由这张之前的图（蓝色和绿色是我们想区分的，可见还是很容易的）</p><p>于是我们选取花瓣长与花瓣宽开始训练</p><p>代码如下：</p><pre><code class="python">import numpy as  npimport tensorflow as tfimport matplotlib.pyplot as pltimport matplotlib as mplfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;] = Falseiris=load_iris()x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=22)x_train=x_train[y_train!=1][:,2:4]y_train=y_train[y_train!=1]for i in range(len(y_train)):    if y_train[i]==2:        y_train[i]=1x_test=x_test[y_test!=1][:,2:4]y_test=y_test[y_test!=1]for i in range(len(y_test)):    if y_test[i]==2:        y_test[i]=1#数据处理区分x_train=x_train-np.mean(x_train,axis=0)#中心化数据x0_train=np.ones(len(x_train)).reshape(-1,1)X=tf.cast(tf.concat((x0_train,x_train),axis=1),tf.float32)Y=tf.cast(y_train.reshape(-1,1),tf.float32)learn_rate=0.2epoch=100display_step=30np.random.seed(612)W=tf.Variable(np.random.randn(3,1),dtype=tf.float32)ce =[]acc=[]for i in range(0,epoch):    with tf.GradientTape() as tap:        Pred=1/(1+tf.exp(-tf.matmul(X,W)))        Loss=-tf.reduce_mean(Y*tf.math.log(Pred)+(1-Y)*tf.math.log(1-Pred))    accuracy=tf.reduce_mean(tf.cast(tf.equal(tf.where(Pred.numpy()&lt;0.5,0.,1.),Y),tf.float32))    ce.append(Loss)    acc.append(accuracy)    dL_dW=tap.gradient(Loss,W)    W.assign_sub(learn_rate*dL_dW)    if i % display_step ==0:        print(&quot;i: %d, Acc:%f, Loss:%f&quot;%(i,accuracy,Loss))plt.figure(figsize=(20,8),dpi=150)plt.subplot(121)plt.plot(ce,color=&quot;b&quot;,label=&quot;Loss&quot;)plt.plot(acc,color=&quot;r&quot;,label=&quot;acc&quot;)plt.legend()plt.title(&quot;损失与准确率&quot;)plt.show()plt.subplot(122)cm_pt=mpl.colors.ListedColormap([&quot;blue&quot;,&quot;red&quot;])plt.scatter(x_train[:,0],x_train[:,1],c=y_train,cmap=cm_pt)x_=[-1.5,1.5]y_=-(W[1]*x_+W[0])/W[2]plt.plot(x_,y_,color=&#39;r&#39;)plt.title(&quot;数据与决策平面&quot;)plt.tight_layout()plt.show()</code></pre><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_567881528459591680.html?v=1613323111000" alt="数据可视化结果"></p><h2 id="练习15："><a href="#练习15：" class="headerlink" title="练习15："></a>练习15：</h2><blockquote><p>( 20分 )</p><p>分别选择2种、3种和4种属性，编写程序，区分变色鸢尾、山鸢尾和维吉尼亚鸢尾。记录和分析实验结果，并给出总结。</p></blockquote><p>这里属于多分类，这里我们 同样选取花瓣长与花瓣宽</p><pre><code class="python">import matplotlib.pyplot as pltimport  tensorflow as tfimport  numpy as npimport  matplotlib as mplfrom sklearn.datasets import  load_irisfrom sklearn.model_selection import train_test_splitplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;] = Falseiris=load_iris()x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=22)x_train=x_train[:,2:4]y_train=y_trainx_test=x_test[:,2:4]y_test=y_test#数据处理区分x0_train=np.ones(len(x_train)).reshape(-1,1)x0_test=np.ones(len(x_test)).reshape(-1,1)X_train=tf.cast(tf.concat([x0_train,x_train],axis=1),tf.float32)Y_train=tf.one_hot(tf.constant(y_train,dtype=tf.int32),3)Y_test=tf.one_hot(tf.constant(y_test,dtype=tf.int32),3)X_test=tf.cast(tf.concat([x0_test,x_test],axis=1),tf.float32)#处理数据learn_rate=0.2epoch=500display_step=100np.random.seed(612)W=tf.Variable(np.random.randn(3,3),dtype=tf.float32)acc=[]cce=[]acc_=[]cce_=[]for i in range(epoch+1):    with tf.GradientTape() as tape:        pred=tf.nn.softmax(tf.matmul(X_train,W))        Loss_train=-tf.reduce_mean(Y_train*tf.math.log(pred))    pred_= tf.nn.softmax(tf.matmul(X_test, W))    Loss_test = -tf.reduce_mean(Y_test * tf.math.log(pred_))    accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(pred.numpy() ,axis=1), y_train), tf.float32))    accuracy_= tf.reduce_mean(tf.cast(tf.equal(tf.argmax(pred_.numpy(), axis=1), y_test), tf.float32))    #argmax()返回最大值索引号,所以这里校验时不用独热码而是用原始数据    acc.append(accuracy)    cce.append(Loss_train)    acc_.append(accuracy_)    cce_.append(Loss_test)    dl_dw=tape.gradient(Loss_train,W)    W.assign_sub(learn_rate*dl_dw)    if i%display_step ==0:        print(&quot;i: %d, trainAcc:%f, trainLoss:%f&quot;%(i,accuracy,Loss_train))        print(&quot;        testAcc:%f,  testLoss:%f&quot; % (accuracy_, Loss_test))plt.figure(figsize=(20,24),dpi=150)plt.subplot(221)plt.plot(cce,color=&quot;b&quot;,label=&quot;训练集损失&quot;)plt.plot(cce_,color=&quot;r&quot;,label=&quot;测试集损失&quot;)plt.legend()plt.title(&quot;数据集损失&quot;)plt.subplot(222)plt.plot(cce,color=&quot;b&quot;,label=&quot;训练集准确率&quot;)plt.plot(cce_,color=&quot;r&quot;,label=&quot;测试集准确率&quot;)plt.legend()plt.title(&quot;数据集准确率&quot;)plt.subplot(223)M=500x1_min,x2_min=x_train.min(axis=0)x1_max,x2_max=x_train.max(axis=0)t1=np.linspace(x1_min,x1_max,M)t2=np.linspace(x2_min,x2_max,M)m1,m2=np.meshgrid(t1,t2)m0=np.ones(M*M)X_=tf.cast(np.stack((m0,m1.reshape(-1),m2.reshape(-1)),axis=1),tf.float32)Y_=tf.nn.softmax(tf.matmul(X_,W))Y_=tf.argmax(Y_.numpy(),axis=1)n=tf.reshape(Y_,m1.shape)cm_bg=mpl.colors.ListedColormap([&quot;#A0FFA0&quot;,&quot;#FFA0A0&quot;,&quot;#A0A0FF&quot;])plt.pcolormesh(m1,m2,n,cmap=cm_bg)plt.scatter(x_train[:,0],x_train[:,1],c=y_train,cmap=&quot;brg&quot;)plt.title(&quot;训练数据与决策平面&quot;)plt.subplot(224)cm_bg_=mpl.colors.ListedColormap([&quot;#A0FFA0&quot;,&quot;#FFA0A0&quot;,&quot;#A0A0FF&quot;])plt.pcolormesh(m1,m2,n,cmap=cm_bg)plt.scatter(x_test[:,0],x_test[:,1],c=y_test,cmap=&quot;brg&quot;)plt.title(&quot;测试数据与决策平面&quot;)plt.tight_layout()plt.show()</code></pre><blockquote><p>输出如下：</p><p>i: 0, trainAcc:0.366667, trainLoss:1.422851<br>        testAcc:0.200000,  testLoss:1.845798<br>i: 100, trainAcc:0.683333, trainLoss:0.237928<br>        testAcc:0.666667,  testLoss:0.234590<br>i: 200, trainAcc:0.808333, trainLoss:0.194367<br>        testAcc:0.833333,  testLoss:0.200174<br>i: 300, trainAcc:0.858333, trainLoss:0.170748<br>        testAcc:0.866667,  testLoss:0.180454<br>i: 400, trainAcc:0.875000, trainLoss:0.155550<br>        testAcc:0.900000,  testLoss:0.167200<br>i: 500, trainAcc:0.916667, trainLoss:0.144651<br>        testAcc:0.933333,  testLoss:0.157360</p></blockquote><p>画出来图如下，有点丑了，但还算能看：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_568862217696559104.html?v=1613556927000"></p><p>现在有个问题，就是这个决策平面显然并不是我们想要的，直觉告诉我，应该平面像是这样分类的准确性才会高一点：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_568863457222438912.html?v=1613557222000"></p><p>特别是在蓝绿两个类之间，不该是贯穿的切法，而应该是横切，认为是训练不充分，于是把训练轮数提高8倍到4000轮：</p><p>结果是：</p><blockquote><p>i: 0, trainAcc:0.366667, trainLoss:1.422851<br>        testAcc:0.200000,  testLoss:1.845798<br>i: 100, trainAcc:0.683333, trainLoss:0.237928<br>        testAcc:0.666667,  testLoss:0.234590<br>i: 200, trainAcc:0.808333, trainLoss:0.194367<br>        testAcc:0.833333,  testLoss:0.200174<br>i: 300, trainAcc:0.858333, trainLoss:0.170748<br>        testAcc:0.866667,  testLoss:0.180454<br>i: 400, trainAcc:0.875000, trainLoss:0.155550<br>        testAcc:0.900000,  testLoss:0.167200<br>i: 500, trainAcc:0.916667, trainLoss:0.144651<br>        testAcc:0.933333,  testLoss:0.157360</p><p>​                             ……………….</p><p>i: 3800, trainAcc:0.966667, trainLoss:0.068734<br>        testAcc:0.933333,  testLoss:0.081017<br>i: 3900, trainAcc:0.966667, trainLoss:0.067992<br>        testAcc:0.933333,  testLoss:0.080229<br>i: 4000, trainAcc:0.966667, trainLoss:0.067277<br>        testAcc:0.933333,  testLoss:0.079468 </p></blockquote><p>虽然训练集上升并且没有产生过拟合但是测试集的准确率已经不动了（可能因为测试的数据少）,不过loss在下降，往后非常慢的降</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_568866095669407744.html?v=1613557851000"></p><p>某种意义上是往着我们期望的方向发展，应该是达到了目的，也许会有更好的方法</p><h2 id="练习16："><a href="#练习16：" class="headerlink" title="练习16："></a>练习16：</h2><blockquote><p>使用多层神经网络实现鸢尾花分类，编写程序，尝试改变隐含层层数、隐含层中节点数以及其他超参数，记录并分析实验结果，给出总结。</p><p>要求：</p><p>（1）编写程序（7分）</p><p>（2）记录超参数的调整过程和结果（3分）</p><p>（3）总结（5分）</p><p>比较时间代价、分析不同超参数对结果准确性的影响</p></blockquote><pre><code class="python">import matplotlib.pyplot as pltimport  tensorflow as tfimport  numpy as npimport  matplotlib as mplfrom sklearn.datasets import  load_irisfrom sklearn.model_selection import train_test_splitplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;] = Falseiris=load_iris()x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=22)x_train=x_train[:,0:4]y_train=y_trainx_test=x_test[:,0:4]y_test=y_test#数据处理区分x_train=x_train-np.mean(x_train,axis=0)x_test=x_test-np.mean(x_test,axis=0)X_train=tf.cast(x_train,tf.float32)Y_train=tf.one_hot(tf.constant(y_train,dtype=tf.int32),3)Y_test=tf.one_hot(tf.constant(y_test,dtype=tf.int32),3)X_test=tf.cast(x_test,tf.float32)#处理数据learn_rate=0.2epoch=4000display_step=100np.random.seed(612)W1=tf.Variable(np.random.randn(4,16),dtype=tf.float32)B1=tf.Variable(tf.zeros([16]),dtype=tf.float32)W2=tf.Variable(np.random.randn(16,3),dtype=tf.float32 )B2=tf.Variable(tf.zeros([3]),dtype=tf.float32)acc=[]cce=[]acc_=[]cce_=[]for i in range(epoch+1):    with tf.GradientTape() as tape:        Hidden_train=tf.nn.relu(tf.matmul(X_train,W1)+B1)        pred=tf.nn.softmax(tf.matmul(Hidden_train,W2)+B2)        Loss_train=tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_train,y_pred=pred))        Hidden_test = tf.nn.relu(tf.matmul(X_test, W1) + B1)        pred_= tf.nn.softmax(tf.matmul(Hidden_test, W2) + B2)        Loss_test = tf.reduce_mean(tf.keras.losses.categorical_crossentropy(y_true=Y_test, y_pred=pred_))    accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(pred.numpy() ,axis=1), y_train), tf.float32))    accuracy_= tf.reduce_mean(tf.cast(tf.equal(tf.argmax(pred_.numpy(), axis=1), y_test), tf.float32))    #argmax()返回最大值索引号,所以这里校验时不用独热码而是用原始数据    acc.append(accuracy)    cce.append(Loss_train)    acc_.append(accuracy_)    cce_.append(Loss_test)    grade=tape.gradient(Loss_train,[W1,B1,W2,B2])    W1.assign_sub(learn_rate*grade[0])    B1.assign_sub(learn_rate * grade[1])    W2.assign_sub(learn_rate * grade[2])    B2.assign_sub(learn_rate * grade[3])        if i&gt;0 and cce_[i]&gt;cce_[i-1]:        print(&quot;--------------------stop at %d epoch-----------------------&quot;%i)        break    if i%display_step ==0:        print(&quot;i: %d, trainAcc:%f, trainLoss:%f&quot;%(i,accuracy,Loss_train))        print(&quot;        testAcc:%f,  testLoss:%f&quot; % (accuracy_, Loss_test))plt.figure(figsize=(20,8),dpi=150)plt.subplot(121)plt.plot(cce,color=&quot;b&quot;,label=&quot;训练集损失&quot;)plt.plot(cce_,color=&quot;r&quot;,label=&quot;测试集损失&quot;)plt.legend()plt.title(&quot;数据集损失&quot;)plt.subplot(122)plt.plot(acc,color=&quot;b&quot;,label=&quot;训练集准确率&quot;)plt.plot(acc_ ,color=&quot;r&quot;,label=&quot;测试集准确率&quot;)plt.legend()plt.title(&quot;数据集准确率&quot;)plt.tight_layout()plt.show()</code></pre><p>这次同样训练了4k轮，结果很amzing啊</p><p>过拟合了</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571008578306138112.html?v=1614068655000"></p><p>看起来使用relu优化的两层神经网络好像没有在感知机中表现的好………，因为最后测试集的准确率连80%都没有</p><p>不过relu下降的倒是很快，现在用early_stopping的方法控制，即当验证集损失开始上升时停止训练（这里就把测试集当验证集了</p><pre><code class="python">  if i&gt;0 and cce_[i]&gt;cce_[i-1]:        print(&quot;--------------------stop at %d epoch-----------------------&quot;%i)        break</code></pre><p>输出是：</p><blockquote><p>i: 0, trainAcc:0.450000, trainLoss:2.028374<br>        testAcc:0.233333,  testLoss:2.409625<br>——————–stop at 30 epoch———————–</p></blockquote><p>30轮就训练完了，可见下降相当之快啊,就是最后泛化性有点差</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571013689459200000.html?v=1614069875000"></p><h2 id="练习17："><a href="#练习17：" class="headerlink" title="练习17："></a>练习17：</h2><blockquote><p>使用TensorFlow中的keras库，实现Minist手写数字识别。编写程序，尝试调整神经网络的层数、节点个数以及优化器等参数，记录并分析实验结果，保存最佳训练模型，给出总结。</p><p>要求：</p><p>(1)编写程序（7分）</p><p>(2)记录参数的调整过程和结果（3分）</p><p>(3)总结。（5分）</p><p>从准确率、时间效率等方面对实验结果进行分析</p></blockquote><pre><code class="python">import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltmnist=tf.keras.datasets.mnist(train_x,train_y),(test_x,test_y)=mnist.load_data()# X_train=train_x.reshape((60000,28*28))# X_test=test_x.reshape((10000,28*28))#如果没有拉伸的层就用这个语句X_train,X_test=tf.cast(train_x/255.0,tf.float32),tf.cast(test_x/255.0,tf.float32)Y_train,Y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)model=tf.keras.Sequential()model.add(tf.keras.layers.Flatten(input_shape=(28,28)))model.add(tf.keras.layers.Dense(128,activation=&quot;relu&quot;))model.add(tf.keras.layers.Dense(10,activation=&quot;softmax&quot;))model.compile(optimizer=&quot;adam&quot;,loss=&quot;sparse_categorical_crossentropy&quot;,metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(X_train,Y_train,batch_size=64,epochs=5,validation_split=0.2)model.evaluate(X_test,Y_test,verbose=2)y_pred=model.predict_classes(X_test[0:1000])plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falseplt.figure(dpi=150)for i in range(25):    num=np.random.randint(0,1000)    plt.subplot(5,5,i+1)    plt.axis(&quot;off&quot;)    plt.imshow(test_x[num],cmap=&quot;gray&quot;)    title=&quot;y=&quot;+str(test_y[num])+&quot;\ny_pred=&quot;+str(y_pred[num])    plt.title(title)plt.tight_layout()plt.suptitle(&quot;手写数字样本预测 &quot;,x=0.5,y=1.02, fontsize=20)plt.show()</code></pre><p>训练5轮的结果：</p><blockquote><p>Epoch 1/5<br>750/750 [==============================] - 2s 2ms/step - loss: 0.5641 - sparse_categorical_accuracy: 0.8408 - val_loss: 0.1859 - val_sparse_categorical_accuracy: 0.9454<br>Epoch 2/5<br>750/750 [==============================] - 1s 1ms/step - loss: 0.1547 - sparse_categorical_accuracy: 0.9554 - val_loss: 0.1272 - val_sparse_categorical_accuracy: 0.9621<br>Epoch 3/5<br>750/750 [==============================] - 1s 1ms/step - loss: 0.1054 - sparse_categorical_accuracy: 0.9691 - val_loss: 0.1139 - val_sparse_categorical_accuracy: 0.9653<br>Epoch 4/5<br>750/750 [==============================] - 1s 1ms/step - loss: 0.0788 - sparse_categorical_accuracy: 0.9764 - val_loss: 0.0931 - val_sparse_categorical_accuracy: 0.9721<br>Epoch 5/5<br>750/750 [==============================] - 1s 1ms/step - loss: 0.0609 - sparse_categorical_accuracy: 0.9825 - val_loss: 0.0902 - val_sparse_categorical_accuracy: 0.9720<br>313/313 - 0s - loss: 0.0823 - sparse_categorical_accuracy: 0.9748</p></blockquote><p>可见下降很快</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571308404708585472.html?v=1614140140000"></p><p>训练加到100轮后，几次训练集达到100%准确率，时间太长就不展示了</p><p>总的来说使用tensorflow的高阶api不仅代码量少了很多而且更加准确</p><h2 id="练习18："><a href="#练习18：" class="headerlink" title="练习18："></a>练习18：</h2><blockquote><p>( 10分 )</p><p>编写程序，使用作业1中训练好的模型，实现对自制手写数字数据集的识别。</p><p>要求：</p><p>(1) 将下面名为<strong>“自制手写数字.zip”</strong>压缩包中自制的手写数字转换为28*28的数组形式，并将数字放在图片中心。（5分）</p><p>(2) 加载作业1中训练好的模型，使用该模型对要求(1)中的手写数字进行识别。（5分）</p><p><strong>提示：</strong></p><p>图像操作部分可参考第7讲“数字图像基础”</p><p>可能用到的函数：</p><p>裁剪图像：crop() </p><p>转换成二值图像 ：convert()</p><p>改变大小：resize()</p></blockquote><p>训练模型：</p><pre><code class="python">import tensorflow as tfimport numpy as npmnist=tf.keras.datasets.mnist(train_x,train_y),(test_x,test_y)=mnist.load_data()X_train,X_test=tf.cast(train_x/255.0,tf.float32),tf.cast(test_x/255.0,tf.float32)Y_train,Y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)model=tf.keras.Sequential()model.add(tf.keras.layers.Flatten(input_shape=(28,28)))model.add(tf.keras.layers.Dense(128,activation=&quot;relu&quot;))model.add(tf.keras.layers.Dense(10,activation=&quot;softmax&quot;))model.compile(optimizer=&quot;adam&quot;,loss=&quot;sparse_categorical_crossentropy&quot;,metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(X_train,Y_train,batch_size=64,epochs=100,validation_split=0.2)#训练100轮，由于没有用GPU加速所以每轮用了1smodel.evaluate(X_test,Y_test,verbose=2)model.save(&quot;mist_model.h5&quot;)</code></pre><p>使用模型：</p><pre><code class="python">import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltmnist=tf.keras.datasets.mnist(train_x,train_y),(test_x,test_y)=mnist.load_data()X_train,X_test=tf.cast(train_x/255.0,tf.float32),tf.cast(test_x/255.0,tf.float32)Y_train,Y_test=tf.cast(train_y,tf.int16),tf.cast(test_y,tf.int16)model=tf.keras.models.load_model(&quot;mist_model.h5&quot;)y_pred=model.predict_classes(X_test[0:1000])plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falseplt.figure(dpi=150)for i in range(25):    num=np.random.randint(0,1000)    plt.subplot(5,5,i+1)    plt.axis(&quot;off&quot;)    plt.imshow(test_x[num],cmap=&quot;gray&quot;)    title=&quot;y=&quot;+str(test_y[num])+&quot;\ny_pred=&quot;+str(y_pred[num])    plt.title(title)plt.tight_layout()plt.suptitle(&quot;手写数字样本预测 &quot;,x=0.5,y=1.02, fontsize=20)plt.show()</code></pre><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571374154019880960.html?v=1614155820000"></p><p>说明保存成功，并且可以应用了</p><p>现在开始实际应用：</p><p>首先这是我们的测试样本：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571375447424217088.html?v=1614156125000"></p><p>我们先处理下图片：</p><p>基本处理操作包括：</p><ul><li>加载图像</li><li>处理图像尺寸变成28*28</li><li>二值化图像</li><li>必要时对图像反色处理（因为这里是黑笔写的所以与MNIST不同）</li></ul><p>这里用了下os库，用于读写文件</p><pre><code class="python">import matplotlib.pyplot as pltfrom PIL import Imageimport tensorflow as tfplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=Falseplt.figure(figsize=(10,4),dpi=150)MyData=[]for i in range(9):    path=&quot;D:\code\ML\data\手写数字\\&quot;+str(i+1)+&quot;.png&quot;    MyData.append(Image.open(path))for i in range(9):    plt.subplot(2,5,i+1)    plt.axis(&quot;off&quot;)    plt.imshow(MyData[i], cmap=&quot;gray&quot;)</code></pre><p>单个图片数据的形状：</p><pre><code class="python">for i in range(9):    print(MyData[0].shape)</code></pre><blockquote><p>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)<br>(93, 73, 4)</p></blockquote><p>可见这是一个尺寸93*73的rgba彩色文件，我们的目标是要把每个文件处理成28x28的二值文件</p><pre><code class="python">import matplotlib.pyplot as pltfrom PIL import Imageimport tensorflow as tfimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=FalseMyData=[]for i in range(9):    path=&quot;D:\code\ML\data\手写数字\\&quot;+str(i+1)+&quot;.png&quot;    Img=Image.open(path)    Img=Img.convert(&quot;1&quot;)#二值化图片    Img=Img.resize((28,28))#转换尺寸    Img=np.array(Img)    MyData.append(Img)for i in range(9):    plt.subplot(2,5,i+1)    plt.axis(&quot;off&quot;)    plt.imshow(MyData[i], cmap=&quot;gray&quot;)</code></pre><p>但是，加载出来的图片却是这样的：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571390714891927552.html?v=1614159768000"></p><p>这是个啥玩意。。。。。。，噪声太多了</p><p>看来不是变成二值化啊，于是转换成灰度图</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571391504861474816.html?v=1614159954000"></p><p>效果好很多了，但不是我们想要的，因为我们训练的模型使用的数据是数字白，背景黑，而我们目标数据是数字黑背景白，所以要进行一个反色处理，结果就是这样</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571392683166363648.html?v=1614160236000" alt="与MNIST几乎一样了"></p><p>然后就可以套用模型辣</p><p>结果是：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571395575248957440.html?v=1614161232000"></p><p>这机器学了个寂寞啊。。。。。。</p><p>但是在测试集上准确率的确是我们想要的，为什么应用起来就有问题了呢</p><p>观察了下手写数字样本：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571399258676772864.html?v=1614161804000"></p><p>和我们处理的图片比，可见图片中数字的部分占比比我们制作图的要大，应该是我的图还缺少一个裁切主体的部分</p><p>于是把图片裁剪了下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571392683166363648.html?v=1614160236000" alt="裁剪前"></p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571403782689386496.html?v=1614162881000" alt="裁剪后"></p><p>然后预测。。。。。</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571404697690816512.html?v=1614163099000" alt="裁剪处理后的"></p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_571405484810211328.html?v=1614163287000" alt="对比之前"></p><p>好歹对了一个……….准确率从10%提升到了20%,可喜可贺可喜可贺（泪目）</p><p>现在分析问题原因可能在于我所用的数据笔画太细，而训练用的数据笔画太粗，也就是说训练的时候学到了不该考虑进去的征兆，很可能是训练次数过大</p><p>调低训练次数到30次，再使用模型，但是并没有用。。。。。。</p><p>可能还是有不足吧，以后学习了更多在再来挑战</p><p>代码在这</p><pre><code class="python">import matplotlib.pyplot as pltfrom PIL import Imageimport tensorflow as tfimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.rcParams[&#39;axes.unicode_minus&#39;]=FalseMyData=[]for i in range(9):    path=&quot;D:\code\ML\data\手写数字\\&quot;+str(i+1)+&quot;.png&quot;    Img=Image.open(path)    Img=Img.convert(&quot;L&quot;)#二值化图片    Img=Img.resize((73,73))#转换尺寸    Img=Img.crop((9,9,63,63))    Img = Img.resize((28, 28))  # 转换尺寸    Img=np.array(Img)    Img = 255 - Img  # 图像反色    MyData.append(Img)MyData=np.array(MyData)MyData=tf.cast(MyData/255.0,tf.float32)#归一化处理model=tf.keras.models.load_model(&quot;mist_model.h5&quot;)y_pred=np.argmax(model.predict(MyData[0:9]),axis=1)for i in range(9):    plt.subplot(2,5,i+1)    plt.axis(&quot;off&quot;)    path = &quot;D:\code\ML\data\手写数字\\&quot; + str(i + 1) + &quot;.png&quot;    Img = Image.open(path)    plt.imshow(Img,cmap=&quot;gray&quot;)    title=&quot;pred=&quot;+str(y_pred[i])    plt.title(title)plt.tight_layout()plt.suptitle(&quot;自制手写数字样本预测 &quot;,x=0.5,y=1.02, fontsize=20)plt.show()</code></pre><p>自此整个课程的作业就结束了，接下来要学习的是北京大学的Tensorflow课程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;神经网络与深度学习作业&quot;&gt;&lt;a href=&quot;#神经网络与深度学习作业&quot; class=&quot;headerlink&quot; title=&quot;神经网络与深度学习作业&quot;&gt;&lt;/a&gt;神经网络与深度学习作业&lt;/h1&gt;&lt;p&gt;大垃圾一年没写python辣（其实去年也学的稀烂），今年要机器学习不</summary>
      
    
    
    
    <category term="Python" scheme="http://sweetheart.nefu.site/categories/Python/"/>
    
    
    <category term="Python" scheme="http://sweetheart.nefu.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习笔记</title>
    <link href="http://sweetheart.nefu.site/2021/01/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.nefu.site/2021/01/15/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-14T16:57:47.000Z</published>
    <updated>2021-01-14T16:58:45.287Z</updated>
    
    
    
    
    <category term="machin learning" scheme="http://sweetheart.nefu.site/categories/machin-learning/"/>
    
    
    <category term="machin learning" scheme="http://sweetheart.nefu.site/tags/machin-learning/"/>
    
  </entry>
  
  <entry>
    <title>寒假算法训练</title>
    <link href="http://sweetheart.nefu.site/2021/01/14/%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    <id>http://sweetheart.nefu.site/2021/01/14/%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/</id>
    <published>2021-01-14T09:51:53.000Z</published>
    <updated>2021-02-18T15:24:06.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寒假算法练习"><a href="#寒假算法练习" class="headerlink" title="寒假算法练习"></a>寒假算法练习</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​    作为转专业fw自认为算法功底不如土著，本人认为对于计算机专业来说蓝桥杯的重要性大于美赛（事实上是因为美赛只剩下20天了参加也是白给，还不如参加两个月后的蓝桥杯，总之并不希望白给两场比赛），再加上刚学完数据结构，要是不好好进阶恐怕会忘干净，于是这个寒假决定好好训练下自己的算法功底，总之希望能以一天五道题的练习量坚持下去，望各位监督辽~（虽然并不会有人看）</p><p>习题来源：牛客网</p><h2 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h2><p>今天是<strong>2021/1/15</strong></p><p>然而写下这个的时候是2021/2/18</p><p>。。。。。懒人本懒了</p><h3 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h3><blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/problem/50911">https://ac.nowcoder.com/acm/problem/50911</a><br>来源：牛客网</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从 1∼n1\sim n1∼n这 n (n≤16)(n \leq 16)(n≤16) 个整数中随机选取任意多个，输出所有可能的选择方案。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>一个整数n。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>每行一种方案。同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。对于没有选任何数的方案，输出空行。本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>3</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>322 311 31 21 2 3</code></pre></blockquote><pre><code class="c++">/*                   _ooOoo_                  o8888888o                  88&quot; . &quot;88                  (| -_- |)                  O\  =  /O               ____/`---&#39;\____             .&#39;  \\|     |//  `.            /  \\|||  :  |||//  \           /  _||||| -:- |||||-  \           |   | \\\  -  /// |   |           | \_|  &#39;&#39;\---/&#39;&#39;  |   |           \  .-\__  `-`  ___/-. /         ___`. .&#39;  /--.--\  `. . __      .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.     | | :  `- \`.;`\ _ /`;.`/ - ` : | |     \  \ `-.   \_ __\ /__ _/   .-` /  /======`-.____`-.___\_____/___.-`____.-&#39;======                   `=---=&#39;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^            佛祖保佑       永无BUG            @Author: xiaomu            @Time: 2021/2/18 8:13            @Project_NAME：_Algorithm_training            @FileName: NC50911.cpp            @IDE: CLion*/#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int pre[20];int n;void print(int len)&amp;#123;    for(int i=0;i&lt;len;i++)    &amp;#123;        printf(&quot;%d%c&quot;,pre[i],i==len-1?&#39;\n&#39;:&#39; &#39;);    &amp;#125;    if(len==0)        puts(&quot; &quot;);&amp;#125;//升序输出void dfs(int pr,int dep)&amp;#123;    for(int i =pr+1;i&lt;=n;i++)    &amp;#123;        pre[dep]=i;        dfs(i,dep+1);    &amp;#125;    print(dep);&amp;#125;int main()&amp;#123;    cin&gt;&gt;n;    dfs(0,0);    return 0;&amp;#125;</code></pre><p>这道题目主要是为了考察了深度遍历树的建立</p><h3 id="递归实现组合型枚举-·"><a href="#递归实现组合型枚举-·" class="headerlink" title="递归实现组合型枚举    ·"></a>递归实现组合型枚举    ·</h3><blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/problem/50918">https://ac.nowcoder.com/acm/problem/50918</a><br>来源：牛客网</p><h2 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>两个整数n，m。</code></pre><h2 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>按照从小到大的顺序输出所有方案，每行1个。首先，同一行内的数升序排列，相邻两个数用一个空格隔开。其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 9 12排在1 3 10 11前面）。</code></pre><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code>5 3</code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code>1 2 31 2 41 2 51 3 41 3 51 4 52 3 42 3 52 4 53 4 5</code></pre></blockquote><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n,m;//n表示1-n,m表示行数；int pre[20];void print()&amp;#123;    for (int i = 1; i &lt;=m ; ++i) &amp;#123;        cout&lt;&lt;pre[i]&lt;&lt;&#39; &#39;;    &amp;#125;    cout&lt;&lt;&#39;\n&#39;;&amp;#125;void dfs(int node,int deep)&amp;#123;    if(deep&lt;=m&amp;&amp;node&lt;=n)    &amp;#123;   while(deep&lt;=m&amp;&amp;node&lt;=n)        &amp;#123;        pre[deep]=node;        dfs(node+1,deep+1);        if(deep==m) &amp;#123;            print();        &amp;#125;        node++;        &amp;#125;    &amp;#125;    else        return;&amp;#125;int main()&amp;#123;    cin&gt;&gt;n&gt;&gt;m;    dfs(1,1);    return 0;&amp;#125;</code></pre><p>这里考察递归栈的使用</p><p>第一个没看题解自己写出来的题目<del>~</del>开心</p><h3 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h3><blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/problem/50919">https://ac.nowcoder.com/acm/problem/50919</a><br>来源：牛客网</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>把 1∼n1\sim n1∼n 这 n(n&lt;10)(n \lt 10)(n&lt;10)个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h2 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>一个整数n。</code></pre><h2 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</code></pre><p>示例1</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><pre><code>3</code></pre><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><pre><code>1 2 31 3 22 1 32 3 13 1 23 2 1</code></pre></blockquote><pre><code class="c++">#include&lt;stdio.h&gt;int a[11],n,used[11];void dfs(int dep)&amp;#123;    int i;    if(dep == n + 1)&amp;#123;                 printf(&quot;%d&quot;,a[1]);        for(i = 2; i &lt;= n; i++)            printf(&quot; %d&quot;,a[i]);       printf(&quot;\n&quot;);        return ;    &amp;#125;    for(i = 1; i &lt;= n; i++)        if(!used[i])&amp;#123;            used[i] = 1, a[dep] = i;            dfs(dep + 1);            used[i] = 0;        &amp;#125;&amp;#125;int main()&amp;#123;    scanf(&quot;%d&quot;,&amp;n);    dfs(1);    return 0;&amp;#125;</code></pre><p>这次的退栈比较巧妙</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寒假算法练习&quot;&gt;&lt;a href=&quot;#寒假算法练习&quot; class=&quot;headerlink&quot; title=&quot;寒假算法练习&quot;&gt;&lt;/a&gt;寒假算法练习&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写</summary>
      
    
    
    
    <category term="算法" scheme="http://sweetheart.nefu.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://sweetheart.nefu.site/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="c++" scheme="http://sweetheart.nefu.site/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>css前端页面布局</title>
    <link href="http://sweetheart.nefu.site/2021/01/02/css%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://sweetheart.nefu.site/2021/01/02/css%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</id>
    <published>2021-01-02T10:38:03.000Z</published>
    <updated>2021-01-14T09:51:00.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css前端页面布局"><a href="#css前端页面布局" class="headerlink" title="css前端页面布局"></a>css前端页面布局</h1><p>前端三件套里面除了javascript之外，比较难学的就是css的页面布局操作，可以说css掌握好布局那么基本上就能写出一个一般通俗的静态页面了，其他都可以现学现抄</p><p>开始前补充关于div几个比较重要的知识点：</p><ul><li>div独占一行，所以第二个div默认情况下永远在div的下面，纵向排列</li><li>即使div设置了宽高，依旧会根据孩子进行宽高调整，而我们设置的宽高只是背景颜色范围，这也是为什么很多时候子div看起来溢出了页面的原因</li><li>div有自身的固有属性，比如总是会有8px的margin，为了美观记得消除margin等效果</li></ul><h2 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h2><p>浮动布局指：</p><ul><li>将元素排除在普通流之外</li><li>元素不在页面占据空间</li><li>将浮动元素放置在包含框的左右边</li><li>浮动元素依旧位于包含框之内</li></ul><p>浮动的框可以向左或者向右移动，直到外边缘碰到包含框或另一个浮动边框为止</p><ul><li>浮动元素的外边缘不会超过其父元素的内边缘</li><li>浮动元素不会相互重叠</li><li>浮动元素不会上下浮动</li><li>任何一个元素浮动，display属性完全失效，并且不会独占一行</li></ul><p>语法：</p><ul><li>float:none/left/right;</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        #box&amp;#123;            width: 600px;            height: 600px;            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;box&quot;&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果图如下:</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513261589626880.html?v=1610374614000"></p><p>倘若设置浮动：</p><pre><code class="css">    &lt;style&gt;        #box&amp;#123;            width: 600px;            height: 600px;            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513256077426688.html?v=1610374826000"></p><p>说明float碰到边缘停止，</p><p>打个比方，大的div外边框相当于七巧板的框</p><p>而不浮动的div相当于七巧板的框内花纹，而浮动的div相当于七巧板，碰到同样的七巧板或者边框就停止</p><p>原有的行容不下div的时候，会自动到下一行找更大空间</p><p>覆盖关系由孩子关系决定</p><ul><li>div的本质属性是不设置宽度的时候独占一行，</li><li>span标签的特点是没有宽高属性，并且不会独占一行</li><li>如果设置了float，给无宽高属性的元素会生效宽高属性</li></ul><p>如果父元素没有设置宽高，而子元素有设置宽高，那么父元素会根据子元素调整自己的宽高属性</p><p>例如：</p><pre><code class="css">  &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            /* float: right; */        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            /* float: right; */        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下，说明:</p><ul><li>div的本质属性是不设置宽度的时候独占一行，<ul><li>所以父元素占了一整行</li><li>子元素虽然宽没有满行，但是依旧占了一整行，导致排成一列</li></ul></li><li>父div根据子div调整宽高</li></ul><p>如果给部分元素恢复浮动，如下：</p><pre><code class="css">    &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;        &amp;#125;    &lt;/style&gt;</code></pre><p>效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513241930924032.html?v=1610374864000"></p><p>那么说明在有浮动条件下div感受根据浮动调整，可以认为外边框是一个可伸缩的长方形边框</p><p>内部元素float的情况下，父亲感知不到内元素高度</p><p>解决方法：</p><ul><li><p>设置父元素宽高</p></li><li><p>父元素设置overflow:hidden;</p><p>如下：</p><pre><code class="css">  &lt;style&gt;        #box&amp;#123;            /* width: 600px;            height: 600px; */            background: deeppink;            overflow: hidden;        &amp;#125;        #box&gt;div:first-child&amp;#123;            width: 200px;            height: 200px;            background: green;            float: right;        &amp;#125;        #box&gt;div:nth-child(2)        &amp;#123;            width: 200px;            height: 200px;            background: blue;            float: right;        &amp;#125;        #box&gt;div:nth-child(3        )        &amp;#123;            width: 200px;            height: 200px;            background:red;            float: right;        &amp;#125;    &lt;/style&gt;</code></pre><p>如下图所示：</p></li><li><p>父类设置浮动,兄弟元素清除浮动clear</p></li></ul><p>注意浮动是优先在行内操作</p><p>假设现在有一个div，宽度不比行内宽度小，所以不足以移到下一行，若想移到下一行，则要设置</p><pre><code class="css">clear:both;/*清除两边浮动*/</code></pre><p>这个可以抵消其他元素浮动对当前元素的影响</p><p>属性：clear</p><p>值：left,right,both</p><h2 id="头部布局以及font字体图标使用"><a href="#头部布局以及font字体图标使用" class="headerlink" title="头部布局以及font字体图标使用"></a>头部布局以及font字体图标使用</h2><p>网页布局的时候一般是先水平再垂直，头部布局一般适用于网页导航栏</p><p>这里先学习导航栏的布局：</p><p>html：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/style.css&quot;/&gt;        &lt;!-- 这里引入css文件 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>引入的css文件：</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    background: red;&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    background: green;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    background: aqua;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;&amp;#125;</code></pre><p>初步的效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513260343988224.html?v=1610374496000"></p><p>但是注意到由于div独占一行的原因</p><p>这里pink的div出来了，说明等待解决问题</p><p>利用上次学到的浮动属性，让pink和aqua在green里面浮动：</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    background: red;&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    background: green;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    background: aqua;    float: left;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;    float: right;&amp;#125;</code></pre><p>效果图如下：</p><p>​                                                               图丢了</p><p>这时首页头部的基本框架搭好了，取消父类容器颜色，并且加入子类文字：</p><p>html:</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/style.css&quot;/&gt;        &lt;!-- 这里引入css文件 --&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                    &lt;div &gt;                        &lt;span &gt;                            我是头部                        &lt;/span&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>css:</p><pre><code class="css">#header&amp;#123;    width: 100%;    height: 40px;    /* background: red; */&amp;#125;.header&amp;#123;    width: 50%;    height: 40px;    /* background: green; */    border:1px solid #FF0000;&amp;#125;.header_left&amp;#123;    width: 200px;    height: 40px;    /* background: aqua; 取消父类容器颜色*/    float: left;&amp;#125;.header_right&amp;#123;    width: 300px;    height: 40px;    background: pink;    float: right;&amp;#125;.header_left&gt;div&amp;#123;    float: left;    line-height: 40px;    color: dimgray;    /* 设置字体颜色，在父类中 */&amp;#125;.header_left&gt;div&gt;span&amp;#123;    font-weight: bold;    /* 设置字体加粗 */&amp;#125;</code></pre><p>效果如下</p><p>​                                                                            图又无了</p><p>设置超链接：</p><pre><code class="html">&lt;div &gt;    &lt;a href=&quot;&quot;&gt;        &lt;img src=&quot;&quot; alt=&quot;&quot; &gt;        核心产品        &lt;i&gt;&lt;/i&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><p>为了清除原有超链接丑不拉几的样式，css里面设置为</p><pre><code class="css">a&amp;#123;    text-decoration: none;&amp;#125;</code></pre><p>这样去掉了下划线的样式</p><p>然后设置添加图片</p><p>html:</p><pre><code class="html">&lt;body&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;header&quot;&gt;                &lt;div class=&quot;header_left&quot;&gt;                    &lt;div &gt;                        &lt;span &gt;                            我是头部                        &lt;/span&gt;                    &lt;/div&gt;                    &lt;div &gt;                        &lt;a href=&quot;&quot;&gt;                            &lt;img src=&quot;./img/imag.png&quot; alt=&quot;&quot; &gt;                            核心产品                            &lt;i&gt;&lt;/i&gt;                        &lt;/a&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;header_right&quot;&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;</code></pre><p>css:</p><pre><code class="css">.header&gt;div:nth-child(2)&gt;a,.header_left&gt;div:nth-child(2)&gt;a&gt;img,.header_left&gt;div:nth-child(2)&gt;a&gt;i&amp;#123;    float: left;&amp;#125;.header_left&gt;div:nth-child(2)&gt;a&gt;img&amp;#123;    width: 17px;&amp;#125;</code></pre><p>这里全部设置为浮动布局，并且调整了图片大小如图：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513259392987136.html?v=1610374390000"></p><p>下面是给文字添加图标：</p><p>阿里图标库，找到想要的图标后</p><ul><li><p>点击加入购物车</p></li><li><p>点击购物车添加到项目</p></li><li><p>点击项目更新代码</p></li><li><p>复制更新后的链接，引入到页面的css的link，这样：</p><pre><code class="css">&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;//at.alicdn.com/t/font_2076021_pp0wtm9fh8j.css&quot;/&gt;</code></pre></li><li><p>复制好想要的图标的代码后，如下(注意复制好代码后再标注iconfont才能显示出来)：</p><pre><code class="html">&lt;div &gt;    &lt;a href=&quot;&quot;&gt;        &lt;img src=&quot;./img/imag.png&quot; alt=&quot;&quot; &gt;        核心产品        &lt;i class=&quot;icon-arrow-down iconfont&quot;&gt;&lt;/i&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre></li><li><p>取消i标签的浮动(不取消浮动i标签跑前面去)，并且修改超链接字体颜色：</p><p>去除样式的一篇参考blog:<a href="https://blog.csdn.net/hl_qianduan/article/details/84964511?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161037371816780266298133%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161037371816780266298133&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-84964511.pc_search_result_cache&utm_term=%E5%8E%BB%E9%99%A4%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F">去除css中的默认样式</a></p><pre><code class="css">.header&gt;div:nth-child(2)&gt;a,.header_left&gt;div:nth-child(2)&gt;a&gt;img,&amp;#123;    float: left;    color:dimgrey;&amp;#125;.header_left&gt;div:nth-child(2)&gt;a&gt;img&amp;#123;    width: 17px;&amp;#125; a&amp;#123;text-decoration: none;color:#333;&amp;#125; a:hover, a:visited, a:link, a:active &amp;#123;    color:dimgrey;    // 设置使所有a标签的四种状态都和本身颜色保持一致，样式代码自己写&amp;#125;</code></pre></li></ul><p>最终的效果图如下：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_555513257500176384.html?v=1610374336000"></p><h2 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h2><p>接下来由于时间原因进行总结性概括，不再进行详细描述，反正csdn都能找到</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>相对于div原有位置进行的定位，相对于自己</p><pre><code class="css">position:relative;top:200px;left:200;</code></pre><p>会占有原有位置</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位相对于整个大的div的右上角定位</p><pre><code class="css">position:absolute;top:200px;left:200;</code></pre><p>不会占有原有位置</p><h3 id="相对父容器的绝对定位"><a href="#相对父容器的绝对定位" class="headerlink" title="相对父容器的绝对定位"></a>相对父容器的绝对定位</h3><p>由于决定定位是全局的，若要设置局部绝对</p><p>父类（外层谁设置相对谁）的position设置为相对，或者absulute（非static默认</p><p>子类为absolute；</p><p>可以实现子类相对于父类的绝对定位</p><p>如果元素外层没有一个设置为定位，那么参考点就是body</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>很多吧不随滚动条移动的效果就是用这个做出来的</p><p>视差网页也是这样</p><pre><code class="css">position:fixed;right:200px;top:200px;</code></pre><h3 id="堆叠顺序"><a href="#堆叠顺序" class="headerlink" title="堆叠顺序"></a>堆叠顺序</h3><p>z-index</p><ul><li>一旦修改了元素的定位方式，则元素可能会发生堆叠</li><li>可以使用z-index属性来控制元素框出现的重叠顺序</li><li>z-index仅能在定位的元素上生效</li><li>z-index属性:<ul><li><strong>值为数值，数值越大表示堆叠顺序越高，即离用户越近</strong></li><li>可以设置为负值，表示离用户更远，一般不要设置</li><li><strong>Z-index仅能在定位元素上奏效</strong></li></ul></li></ul><p>比如当元素进行absolute定位产生堆叠的时候</p><p>写法如下：</p><pre><code class="css">z-index:1;z-index:2;z-index:3;</code></pre><h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>根据CSS规范的规定，每一个网页元素都有一个display属性，用于确定该元素的类型，每一个元素都有默认的display属性值，比如div元素，它的默认display属性值为“block”，称为块元素，而span元素的默认display属性值为“inline”，称为“行内”元素。</p><p>块元素与行元素是可以转换的，也就是说display的属性值可以由我们来改变</p><p>display常见属性值：</p><ul><li><ol><li>none:隐藏对象，<strong>体积同样消失，不占据原有位置</strong><ul><li>visibility：hidden同样可以隐藏，但是占据空间</li><li>opacity：50%设置透明度</li><li>怎么隐藏怎么显示</li></ul></li><li>inline:指定对象为内联元素<strong>在行内布局，没有宽高属性</strong></li><li>block:指定对象为块元素<strong>独占一行</strong></li><li>inline-block:指定对象为内联块元素<strong>让几个div在行内并列显示，有宽高属性</strong></li><li>table-cell:指定对象作为表格单元格<strong>同上</strong></li><li><strong>flex:弹性盒</strong></li></ol></li></ul><h2 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h2><p>盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。W3C组织建议把网页上元素看成是一个个盒子。盒模型主要定义四个区域:内容(content)内边距(padding)、边框(border)、外边距(margin)。转换到我们日常生活中，可以拿手机盒来对比，手机=内容，内边距=盒子中的填充物，边框-盒子的厚度，外边距两个手机盒之间的距离。</p><p>通常我们设置的宽和高是指“手机”content的宽高，一整个盒子还包含了“填充物”、盒子、盒子与盒子的距离</p><p>关系如图：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_556533883375620096.html?v=1610617629000" alt="示意图"></p><p>margin与padding的写法不再赘述；自己查csdn；</p><h3 id="关于margin"><a href="#关于margin" class="headerlink" title="关于margin"></a>关于margin</h3><ul><li><p>利用margin可以设置块状元素居中</p><pre><code class="css"> margin:10px auto;</code></pre><p>上下10px,内部居中</p></li><li><p>上下margin会合并<strong>无左右合并</strong></p><p>比如上容器margin-bottom：150px；下容器margin-top=50px;但是这两者间距是150px，取最大值margin</p><p>浮动元素不合并；</p></li><li><p><strong>包含式margin合并</strong></p><p>子容器的margin并不会导致与父容器内部产生距离，而是会让父容器也有一个margin</p><p>建议父容器padding或者bottom;</p></li><li><p>margin可以负值</p></li></ul><h3 id="关于border"><a href="#关于border" class="headerlink" title="关于border"></a>关于border</h3><ul><li><p>写法见csdn：宽度 样式 颜色</p></li><li><p>style（实线或者虚线）属性为空，边框不出现</p></li><li><p>style取值：</p><ul><li>点：dotted</li><li>实线：solid</li><li>双线：double（需要三像素以上</li><li>虚线：dashed</li><li>无边框：none</li></ul></li></ul><h3 id="关于padding"><a href="#关于padding" class="headerlink" title="关于padding"></a>关于padding</h3><ul><li><p>简写：</p><ul><li>padding :value(四个方向相同);</li><li>padding: value(上下) value(左右);</li><li>padding: value (上) value(左右)vadue(下);</li><li>padding: value(上) value(右) value(下）value(左);</li></ul></li><li><p>当内边距挤压子容器的时候，内边距会扩大外部容器，并不会覆盖子容器，border也是</p><p>所以容器原始大小设置因为padding与border改动,margin不会</p></li></ul><h2 id="怪异盒子模型"><a href="#怪异盒子模型" class="headerlink" title="怪异盒子模型"></a>怪异盒子模型</h2><p>适配ie浏览器的盒子模型，</p><p>特点是padding与border不会改变盒子大小</p><p>其他不赘述</p><h2 id="浏览器私有前缀"><a href="#浏览器私有前缀" class="headerlink" title="浏览器私有前缀"></a>浏览器私有前缀</h2><p>根据不同的浏览器内核，css前缀会有不同。最基本的浏览器内核有如下四种，其它的内核都是基于此四种进行再研发的。</p><ul><li><ol><li>Gecko内核    前缀为-moz-火狐浏览器</li><li>Webkit内核    前缀为-webkit-也叫谷歌内核，chrome浏览器最先开发使用，safari浏览器也使用,该内核。国内很多浏览器也使用了webkit内核，如360极速、世界之窗、猎豹等。</li><li>Trident内核   前缀为-ms-也称IE内核</li><li>Presto内核  前缀-o-目前只有opera采用</li></ol></li></ul><p>为了适配不同浏览器，如果写法是css3实验性阶段的语句，保险起见不但要吧所有浏览器前缀写一遍，还要再写一次原属性</p><p>但是如果都是css2标准就不用啦~~</p><h2 id="圆角边框与阴影渐变"><a href="#圆角边框与阴影渐变" class="headerlink" title="圆角边框与阴影渐变"></a>圆角边框与阴影渐变</h2><p>这里给出一个好用的圆角边框生成网站,以及参考blog：</p><p><a href="https://neumorphism.io/#586d79">懒癌专用</a></p><p><a href="https://blog.csdn.net/qq_42221334/article/details/87806624?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161060780016780277083403%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161060780016780277083403&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-87806624.pc_search_result_cache&utm_term=css%E9%98%B4%E5%BD%B1&spm=1018.2226.3001.4187">具体阴影调整写法</a></p><p><a href="https://blog.csdn.net/qq_42039281/article/details/82153805?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161060796616780255218050%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161060796616780255218050&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-82153805.pc_search_result_cache&utm_term=css%E6%B8%90%E5%8F%98&spm=1018.2226.3001.4187">渐变设置</a></p><p>好了你已经学完了</p><h2 id="hover应用之小标签实战"><a href="#hover应用之小标签实战" class="headerlink" title="hover应用之小标签实战"></a>hover应用之小标签实战</h2><p>CSS部分：</p><pre><code class="css">#box&amp;#123;    /* border: 1px solid blue; */    float: left;    position: relative;&amp;#125;/* 父容器设置相对定位,让子容器能对父容器定位 */#box&gt;div&amp;#123;    /* border: 1px solid green; */    float: left;    padding: 10px 20px;    color: #fff;    font-weight: bold;&amp;#125;/* 每个头标签的基本配置 */#box&gt;div:first-child&amp;#123;    background-color: #009764;&amp;#125;#box&gt;div:nth-child(2)&amp;#123;    background-color:#da1941;&amp;#125;#box&gt;div:last-child&amp;#123;    background-color: #eab719;&amp;#125;#box&gt;div&gt;div&amp;#123;    position: absolute;/*     border: #DA1941 solid 1px; */    top: 40px;    left: 0px;    padding: 20px;    width: 205px;    height: 80px;    display: none;&amp;#125;/* 先将块元素隐藏,absolu下标签会一个一个覆盖 */#box&gt;div:hover&gt;div&amp;#123;    display: block;&amp;#125;/* 当鼠标移到标签的时候,设置展示 */#box&gt;div:first-child&gt;div&amp;#123;    background:linear-gradient(50deg,#009764,#009764);&amp;#125;#box&gt;div:nth-child(2)&gt;div&amp;#123;    background:linear-gradient(50deg,#da1941,#da1941);&amp;#125;#box&gt;div:last-child&gt;div&amp;#123;    background:linear-gradient(50deg,#eab719,#eab719);&amp;#125;</code></pre><p>HTML部分：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;小标签&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/style.css&quot;/&gt;        &lt;!-- 这里引入css文件 --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_2076021_pp0wtm9fh8j.css&quot;/&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;box&quot;&gt;            &lt;div &gt;                标签1                &lt;div &gt;                    标签1的内容                &lt;/div&gt;            &lt;/div&gt;            &lt;div &gt;                标签2                &lt;div&gt;                    标签2的内容                &lt;/div&gt;            &lt;/div&gt;            &lt;div &gt;                标签3                &lt;div&gt;                    标签3的内容                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>最后效果如图：</p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_556533843555368960.html?v=1610617723000" alt="鼠标不触碰div"></p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_556533879492800512.html?v=1610617775000" alt="鼠标移到div上"></p><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_556533902329606144.html?v=1610617834000" alt="鼠标移到div上"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;css前端页面布局&quot;&gt;&lt;a href=&quot;#css前端页面布局&quot; class=&quot;headerlink&quot; title=&quot;css前端页面布局&quot;&gt;&lt;/a&gt;css前端页面布局&lt;/h1&gt;&lt;p&gt;前端三件套里面除了javascript之外，比较难学的就是css的页面布局操作，可以</summary>
      
    
    
    
    <category term="web" scheme="http://sweetheart.nefu.site/categories/web/"/>
    
    <category term="前端" scheme="http://sweetheart.nefu.site/categories/web/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="html" scheme="http://sweetheart.nefu.site/tags/html/"/>
    
    <category term="css" scheme="http://sweetheart.nefu.site/tags/css/"/>
    
    <category term="前端" scheme="http://sweetheart.nefu.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>tensoflow基础</title>
    <link href="http://sweetheart.nefu.site/2020/11/11/tensoflow%E5%9F%BA%E7%A1%80/"/>
    <id>http://sweetheart.nefu.site/2020/11/11/tensoflow%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-11T09:57:31.000Z</published>
    <updated>2021-01-12T09:39:08.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tensorflow基础"><a href="#Tensorflow基础" class="headerlink" title="Tensorflow基础"></a>Tensorflow基础</h1><p>​    TensorFlow是现在比较火爆的一个深度学习的框架，内部集成了多种优化算法还有模型框架，所以对初学者十分友好，所以今天起开始自己的TensorFlow第一步</p><h2 id="训练自己的第一个神经网络"><a href="#训练自己的第一个神经网络" class="headerlink" title="训练自己的第一个神经网络"></a>训练自己的第一个神经网络</h2><p>代码如下</p><ul><li><p>第一次上手tensorflow结果发现憨憨的自己抄的代码是temsoflow1.0的版本</p><p>但是安装的tensorflow版本是2.1.3，在咨询了下csdn后在原代码的基础上做了下版本转换</p><p>然而只是试水了下而已，个人认为tensorflow2.0版本更加友好，更简洁，没有session这种操作，后面都会用tensorflow2.0版本实现,指导课程为北大</p></li></ul><pre><code class="python">import tensorflow.compat.v1 as tfimport numpy as nptf.disable_v2_behavior()# create datax_data = np.random.rand(100).astype(np.float32)##随机生成100个数据y_data = x_data * 0.1 + 0.3 #随机生成y# create tensorflow struct start 新建Weights = tf.Variable(tf.random_uniform((1,), -1.0, 1.0))#随机生成权重biases = tf.Variable(tf.zeros((1,)))#初始化Biasesy = Weights * x_data + biases#定义函数loss = tf.reduce_mean(tf.square(y - y_data))#根据均方根差进行梯度下降optimizer = tf.train.GradientDescentOptimizer(0.5)#梯度下降，设置学习率为0.5train = optimizer.minimize(loss)init = tf.initialize_all_variables()# 创建sessionsess = tf.Session()#session是一个对话控制，对sess.run(init)for step in range(201):#训练200轮    sess.run(train)    if step % 20 == 0:        print(step, sess.run(Weights), sess.run(biases), sess.run(loss))        ##每20轮输出一次训练后的权重还有偏差还有损失</code></pre><p>输出如下：</p><pre><code class="python">0 [-0.00268313] [0.5169402] 0.02760824420 [0.0633762] [0.32074773] 0.0001312771540 [0.09214579] [0.3044495] 6.037642e-0660 [0.0983156] [0.30095425] 2.7768752e-0780 [0.09963877] [0.30020466] 1.2771677e-08100 [0.09992254] [0.3000439] 5.874353e-10120 [0.09998339] [0.30000943] 2.7032572e-11140 [0.09999646] [0.300002] 1.2318857e-12160 [0.09999923] [0.30000046] 6.0014216e-14180 [0.09999982] [0.3000001] 3.7214676e-15200 [0.09999991] [0.30000007] 1.2079227e-15##可见训练次数越多</code></pre><p>进行线性回归预测</p><pre><code class="python">##懒得下数据集了，所以就自己生成了一个数据集##线性回归import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tfx_data = np.random.rand(100).astype(np.float32)y_data = x_data * 0.1 + 0.3  # 很显然这个是个非常明显的线性回归plt.scatter(x_data, y_data)    #绘制数据集的形状，是一个严格符合线性回归的散点图# 建立顺序模型model = tf.keras.Sequential()  # 实例化一个模型model.add(tf.keras.layers.Dense(1, input_shape=(1,)))#定义神经元的数目，由于输入的维度就一个就定义一个输入model.compile(    optimizer=&#39;adam&#39;, loss=&#39;mse&#39;)#选择优化算法，这里我们选择adam优化的梯度下降算法，基于均方根差model.fit(x_data,y_data,epochs=10)#对模型训练10轮print(model.predict(x_data))#这时训练结束，对输入X进行预测</code></pre><h2 id="神经网络计算"><a href="#神经网络计算" class="headerlink" title="神经网络计算"></a>神经网络计算</h2><h3 id="神经网络设计过程"><a href="#神经网络设计过程" class="headerlink" title="神经网络设计过程"></a>神经网络设计过程</h3><p>鸢尾花设计分类</p><p>Y=x*w+b 一般神经网络的设计过程</p><pre><code class="python">import tensorflow as tfw=tf.Variable(tf.constant(5,dtype=tf.float32))#设置w的随机初始值为5lr=0.2#学习率epoch=40#迭代次数for i in range(epoch):#在每一次的迭代中    with  tf.GradientTape() as tape:#执行梯度下降算法        loss=tf.square(w+1)#损失函数定义为loss=(w+1)^2    grads=tape.gradient(loss,w)#告知对w求偏导    w.assign_sub((lr*grads))#每次减去学习率乘上导数    print(&quot;在%s 次迭代后,w变为%f ,loss变为 %f&quot;%(epoch,w.numpy(),loss))</code></pre><p>结果如下：</p><p>在1 次迭代后,w变为2.600000 ,loss变为 36.000000<br>在2 次迭代后,w变为1.160000 ,loss变为 12.959999<br>在3 次迭代后,w变为0.296000 ,loss变为 4.665599<br>在4 次迭代后,w变为-0.222400 ,loss变为 1.679616<br>在5 次迭代后,w变为-0.533440 ,loss变为 0.604662<br>在6 次迭代后,w变为-0.720064 ,loss变为 0.217678<br>在7 次迭代后,w变为-0.832038 ,loss变为 0.078364<br>在8 次迭代后,w变为-0.899223 ,loss变为 0.028211<br>在9 次迭代后,w变为-0.939534 ,loss变为 0.010156<br>在10 次迭代后,w变为-0.963720 ,loss变为 0.003656<br>在11 次迭代后,w变为-0.978232 ,loss变为 0.001316<br>在12 次迭代后,w变为-0.986939 ,loss变为 0.000474<br>在13 次迭代后,w变为-0.992164 ,loss变为 0.000171<br>在14 次迭代后,w变为-0.995298 ,loss变为 0.000061<br>在15 次迭代后,w变为-0.997179 ,loss变为 0.000022<br>在16 次迭代后,w变为-0.998307 ,loss变为 0.000008<br>在17 次迭代后,w变为-0.998984 ,loss变为 0.000003<br>在18 次迭代后,w变为-0.999391 ,loss变为 0.000001<br>在19 次迭代后,w变为-0.999634 ,loss变为 0.000000<br>在20 次迭代后,w变为-0.999781 ,loss变为 0.000000<br>                                    …..</p><p>​                                    …..<br>在40 次迭代后,w变为-1.000000 ,loss变为 0.000000</p><p>多次改变学习率，发现结果不一样，</p><p>学习率过小时，40次loss都没达到0</p><p>学习率过大时也找不到</p><h3 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h3><h4 id="张量含义"><a href="#张量含义" class="headerlink" title="张量含义"></a>张量含义</h4><p>tensorflow中的tensor就是指张量的意思，多维数组和列表的意思</p><p>0-D的张量表示一个单独的数 1,2,3,4…..</p><p>1-D的张量表示一个向量 [1,2,3,4,…..]</p><p>2-D的张量表示一个矩阵[[1,2,3],[4,5,6],……]</p><p>3-D的张量表示一个立方，每一层是一个矩阵</p><p>[[[1,2,3],[3,4,5]],</p><p>[[8,9,0],[7,8,5]]]</p><p>n-D以此类推……</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>tf.int,tf.float…….</p><ul><li>tf.int32,tf.float32,tf.float64</li></ul></li><li><p>tf.bool</p><ul><li>tf.constant([True,False])</li></ul></li><li><p>tf.string</p><ul><li>tf.constant(“hollow”)</li></ul></li></ul><h4 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h4><p>直接创建：</p><pre><code class="python">import tensorflow as tfa=tf.constant([1,5],dtype=tf.int64)#实例化一个张量print(a)print(a.dtyppe)print(a.shape)</code></pre><p>numpy转换：</p><pre><code class="python">import tensorflow as tfimport numpy as npa=np.arange(0,5)b=tf.convert_to_tensor(a,dtype=tf.int64)#将numpy格式转换成tf张量格式print(a)print(b)#[0 1 2 3 4]#tf.Tensor([0 1 2 3 4], shape=(5,), dtype=int64)</code></pre><p>一维直接写个数，二维用行列，三维用[n,m,j,k,…..]</p><pre><code class="python">#tf.zreos(维度)#tf.fill(维度，指定值)#tf.ones(维度)a=tf.zeros([2,3])b=tf.fill([2,2],9)</code></pre><p>其他生成张量：</p><pre><code class="python">#tf.random.normal(维度，meaan=均值，stddv=标准差)#生成符合正态分布的张量#tf.random.truncated_normal(维度，均值，标准差)#生成截断式分布的随机数，保证生成数在2sitar之间a=tf.random.normal([2,2],mean=0.5,stddev=1)b=tf.random.truncated_normal([2,2],mean=0.5,stddev=1)#结果如下tf.Tensor([[ 1.1104964  -0.04805636] [ 0.00457174 -0.14143777]], shape=(2, 2), dtype=float32)tf.Tensor([[ 2.312311    1.8229972 ] [-0.07491392  0.20661339]], shape=(2, 2), dtype=float32)a=tf.random.uniform([2,2],minval=0,maxval=1)#生成平均分布的随机数print(a)#结果如下tf.Tensor([[0.33741152 0.5539886 ] [0.8860432  0.18990982]], shape=(2, 2), dtype=float32)</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="张量操作"><a href="#张量操作" class="headerlink" title="张量操作"></a>张量操作</h4><h5 id="tf-cast-tf-reduce"><a href="#tf-cast-tf-reduce" class="headerlink" title="tf.cast()/tf.reduce"></a>tf.cast()/tf.reduce</h5><pre><code class="python">tf.cast(a,dtype=iny64)#转换数据类型用tf.reduce_min(a)#计算张量上的最小值#同理tf.reduce_操作 还有其他的方法，</code></pre><p>轴axis:</p><p>axis=0:表示纵轴</p><p>axis=1:表示横轴，</p><p>则可用其表示求解均值还有最大值的方向</p><p>不指定axis时，对所有元素进行操作</p><pre><code class="python">x=tf.constant([[1,2,3],[2,2,3]])print(x)print(tf.reduce_mean(x))print(tf.reduce_mean(x,axis=1))#结果如下：tf.Tensor([[1 2 3] [2 2 3]], shape=(2, 3), dtype=int32)tf.Tensor(2, shape=(), dtype=int32)tf.Tensor([2 2], shape=(2,), dtype=int32)</code></pre><h5 id="tf-Variable"><a href="#tf-Variable" class="headerlink" title="tf.Variable"></a>tf.Variable</h5><p>tf.Variable将变量标记为可训练，被标记的变量会在反向传播中记录梯度信息，神经网络中，常用该函数标记待训练参数</p><p>tf.Variable(初始值)</p><pre><code class="python">w=tf.Variable(tf.random.normal([2,2],mean=0,stddev=1))</code></pre><h4 id="数学运算操作"><a href="#数学运算操作" class="headerlink" title="数学运算操作"></a>数学运算操作</h4><h5 id="四则运算函数"><a href="#四则运算函数" class="headerlink" title="四则运算函数"></a>四则运算函数</h5><pre><code class="python">x=tf.constant([[1,2],[2,5]])x=tf.cast(x,dtype=float)y=tf.random.normal([2,2],mean=1,stddev=0.5)print(x)print(y)print(tf.add(x,y))print(tf.subtract(x,y))print(tf.multiply(x,y))print(tf.divide(x,y))</code></pre><p>结果如下：</p><pre><code class="python">tf.Tensor([[1. 2.] [2. 5.]], shape=(2, 2), dtype=float32)tf.Tensor([[1.2040572  0.82556653] [0.49909478 1.6746361 ]], shape=(2, 2), dtype=float32)tf.Tensor([[2.2040572 2.8255665] [2.4990947 6.674636 ]], shape=(2, 2), dtype=float32)tf.Tensor([[-0.20405722  1.1744335 ] [ 1.5009053   3.3253639 ]], shape=(2, 2), dtype=float32)tf.Tensor([[1.2040572  1.6511331 ] [0.99818957 8.37318   ]], shape=(2, 2), dtype=float32)tf.Tensor([[0.83052534 2.4225788 ] [4.007255   2.9857233 ]], shape=(2, 2), dtype=float32)</code></pre><p>注意只有维度相同的张量才可以进行四则运算，所以是点乘点加，不是矩阵运算</p><h5 id="幂操作"><a href="#幂操作" class="headerlink" title="幂操作"></a>幂操作</h5><pre><code class="python">x=tf.constant([[1,2],[2,5]])x=tf.cast(x,dtype=float)print(x)print(tf.pow(x,3))print(tf.square(x))print(tf.sqrt(x))#结果如下：tf.Tensor([[1. 2.] [2. 5.]], shape=(2, 2), dtype=float32)tf.Tensor([[  1.   8.] [  8. 125.]], shape=(2, 2), dtype=float32)tf.Tensor([[ 1.  4.] [ 4. 25.]], shape=(2, 2), dtype=float32)tf.Tensor([[1.        1.4142135] [1.4142135 2.236068 ]], shape=(2, 2), dtype=float32)</code></pre><p>以上都是矩阵的点操作</p><h5 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h5><pre><code class="python">tf.matmul(矩阵1，矩阵2)</code></pre><p>要符合矩阵运算</p><h4 id="训练操作"><a href="#训练操作" class="headerlink" title="训练操作"></a>训练操作</h4><h5 id="特征与标签配对的函数"><a href="#特征与标签配对的函数" class="headerlink" title="特征与标签配对的函数"></a>特征与标签配对的函数</h5><pre><code class="python">data=tf.data.Dataset.from_tensor_slices((输入特征，标签))</code></pre><p>举例如下</p><pre><code class="python">features = tf.constant([12,23,10,17])labels = tf.constant([0,1,1,0])dataset= tf.data.Dataset.from_tensor_slices((features, labels))print(dataset)for element in dataset:    print(element)#结果如下&lt;TensorSliceDataset shapes: ((), ()), types: (tf.int32, tf.int32)&gt;(&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=23&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=10&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=17&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)</code></pre><h5 id="求取梯度"><a href="#求取梯度" class="headerlink" title="求取梯度"></a>求取梯度</h5><p>tf.GradientTape（）</p><pre><code class="python">with  tf.GradientTape() as tape:#执行梯度下降算法    w=tf.Variable(tf.constant(3.0))    loss=tf.square(w+1)#损失函数定义为loss=(w+1)^2grad=tape.gradient(loss,w)print(grad)#结果如下：tf.Tensor(8.0, shape=(), dtype=float32)</code></pre><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>enumerate是python内建的函数，可以遍历每个列表元素</p><p>组合为索引 元素</p><pre><code class="python">seq=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]for i,element in enumerate(seq):    print(i,element)</code></pre><h5 id="独热码"><a href="#独热码" class="headerlink" title="独热码"></a>独热码</h5><p>tf.one_hot 特征向量形式表示分类</p><p>tf.one_hot(待转换数据，depth=几分类)</p><pre><code class="python">classes=3label=tf.constant([1,0,2])output=tf.one_hot(label,depth=classes)print(output)#表示如下tf.Tensor([[0. 1. 0.] [1. 0. 0.] [0. 0. 1.]], shape=(3, 3), dtype=float32)</code></pre><h5 id="使符合概率分布"><a href="#使符合概率分布" class="headerlink" title="使符合概率分布"></a>使符合概率分布</h5><p>归一化处理：softmax()</p><p>让输出的每个分类的概率和为1</p><pre><code class="python">y=tf.constant([1.01,2.01,-0.66])y_pro=tf.nn.softmax(y)print(&quot;归一化处理后为：&quot;,y_pro)#归一化处理后为： tf.Tensor([0.25598174 0.69583046 0.04818781], shape=(3,), dtype=float32)</code></pre><h5 id="参数自更新"><a href="#参数自更新" class="headerlink" title="参数自更新"></a>参数自更新</h5><p>相当于c语言中的++或者–</p><pre><code class="python">w=tf.Variable(4)#标记为可训练才能更新w.assign_sub(1)print(w)#即w-1</code></pre><h5 id="返回索引"><a href="#返回索引" class="headerlink" title="返回索引"></a>返回索引</h5><p>tf.argmax(张量名，axis=操作轴)</p><pre><code class="python">test=np.array([[1,2,3],[2,3,4],[4,5,3],[8,7,2]])print(test)print(tf.argmax(test,axis=0))#纵向最大值索引print(tf.argmax(test,axis=1))#横向最大值索引#结果如下[[1 2 3] [2 3 4] [4 5 3] [8 7 2]]tf.Tensor([3 3 1], shape=(3,), dtype=int64)tf.Tensor([2 2 1 0], shape=(4,), dtype=int64)</code></pre><h3 id="鸢尾花数据集读入"><a href="#鸢尾花数据集读入" class="headerlink" title="鸢尾花数据集读入"></a>鸢尾花数据集读入</h3><p>通过sklearn中的dataset数据集引入</p><pre><code class="python">import tensorflow as tffrom sklearn import datasetsimport pandas as pdfrom  pandas import DataFramex_data=datasets.load_iris().data#.data 返回鸢尾花的输入特征y_data=datasets.load_iris().target#.target返回鸢尾花的所有标签print(&quot;x_data:\n&quot;,x_data)print(&quot;y_data:\n&quot;,y_data)x_data=DataFrame(x_data,columns=[&quot;花萼长&quot;,&quot;花萼宽&quot;,&quot;花瓣长&quot;,&quot;花瓣宽&quot;])#把数据变成表格形式，增加可读性pd.set_option(&#39;display.unicode.east_asian_width&#39;,True)#设置列名对齐print(&quot;x_data and index:\n&quot;,x_data)x_data[&#39;类别&#39;]=y_data#给增加一个类别标签print(&quot;x_data add a colum:\n&quot;,x_data)</code></pre><p>展示如下：</p><pre><code>x_data: [[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2]         .......... [6.5 3.  5.2 2. ] [6.2 3.4 5.4 2.3] [5.9 3.  5.1 1.8]]y_data: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]x_data and index:      花萼长  花萼宽  花瓣长  花瓣宽0       5.1     3.5     1.4     0.21       4.9     3.0     1.4     0.22       4.7     3.2     1.3     0.23       4.6     3.1     1.5     0.24       5.0     3.6     1.4     0.2..      ...     ...     ...     ...145     6.7     3.0     5.2     2.3146     6.3     2.5     5.0     1.9147     6.5     3.0     5.2     2.0148     6.2     3.4     5.4     2.3149     5.9     3.0     5.1     1.8[150 rows x 4 columns]x_data add a colum:      花萼长  花萼宽  花瓣长  花瓣宽  类别0       5.1     3.5     1.4     0.2     01       4.9     3.0     1.4     0.2     02       4.7     3.2     1.3     0.2     03       4.6     3.1     1.5     0.2     04       5.0     3.6     1.4     0.2     0..      ...     ...     ...     ...   ...145     6.7     3.0     5.2     2.3     2146     6.3     2.5     5.0     1.9     2147     6.5     3.0     5.2     2.0     2148     6.2     3.4     5.4     2.3     2149     5.9     3.0     5.1     1.8     2[150 rows x 5 columns]</code></pre><h3 id="神经网络实现鸢尾花分类"><a href="#神经网络实现鸢尾花分类" class="headerlink" title="神经网络实现鸢尾花分类"></a>神经网络实现鸢尾花分类</h3><ul><li><p>准备数据</p><ul><li>数据集读入</li><li>数据集乱序</li><li>生成测试集和训练集</li><li>标签配对，每次读入一个batch</li></ul></li><li><p>搭建网络</p><ul><li>定义神经网络中所有可训练参数</li></ul></li><li><p>参数优化</p><ul><li>嵌套迭代循环，with结构更新参数，显示当前loss</li></ul></li><li><p>测试效果</p><ul><li>计算当前参数前向传播后的准确率，显示当前acc</li></ul></li><li><p>acc/loss可视化</p><ul><li>matplotlib库使用</li></ul></li></ul><p>以下是训练用代码，只用一层网络进行训练，Mooc的要求是都能把代码背下来</p><pre><code class="python"># -*- coding: UTF-8 -*-# 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线# 导入所需模块import tensorflow as tffrom sklearn import datasetsfrom matplotlib import pyplot as pltimport numpy as np# 导入数据，分别为输入特征和标签x_data = datasets.load_iris().datay_data = datasets.load_iris().target# 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）# seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）np.random.seed(116)  # 使用相同的seed，保证输入特征和标签一一对应np.random.shuffle(x_data)np.random.seed(116)np.random.shuffle(y_data)tf.random.set_seed(116)# 将打乱后的数据集分割为训练集和测试集，训练集为前120行，测试集为后30行x_train = x_data[:-30]y_train = y_data[:-30]x_test = x_data[-30:]y_test = y_data[-30:]# 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错x_train = tf.cast(x_train, tf.float32)x_test = tf.cast(x_test, tf.float32)# from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)# 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元# 用tf.Variable()标记参数可训练# 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))lr = 0.1  # 学习率为0.1train_loss_results = []  # 将每轮的loss记录在此列表中，为后续画loss曲线提供数据test_acc = []  # 将每轮的acc记录在此列表中，为后续画acc曲线提供数据epoch = 500  # 循环500轮loss_all = 0  # 每轮分4个step，loss_all记录四个step生成的4个loss的和# 训练部分for epoch in range(epoch):  #数据集级别的循环，每个epoch循环一次数据集    for step, (x_train, y_train) in enumerate(train_db):  #batch级别的循环 ，每个step循环一个batch        with tf.GradientTape() as tape:  # with结构记录梯度信息            y = tf.matmul(x_train, w1) + b1  # 神经网络乘加运算            y = tf.nn.softmax(y)  # 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）            y_ = tf.one_hot(y_train, depth=3)  # 将标签值转换为独热码格式，方便计算loss和accuracy            loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失函数mse = mean(sum(y-out)^2)            loss_all += loss.numpy()  # 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确        # 计算loss对各个参数的梯度        grads = tape.gradient(loss, [w1, b1])        # 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad        w1.assign_sub(lr * grads[0])  # 参数w1自更新        b1.assign_sub(lr * grads[1])  # 参数b自更新    # 每个epoch，打印loss信息    print(&quot;Epoch &amp;#123;&amp;#125;, loss: &amp;#123;&amp;#125;&quot;.format(epoch, loss_all/4))    train_loss_results.append(loss_all / 4)  # 将4个step的loss求平均记录在此变量中    loss_all = 0  # loss_all归零，为记录下一个epoch的loss做准备    # 测试部分    # total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0    total_correct, total_number = 0, 0    for x_test, y_test in test_db:        # 使用更新后的参数进行预测        y = tf.matmul(x_test, w1) + b1        y = tf.nn.softmax(y)        pred = tf.argmax(y, axis=1)  # 返回y中最大值的索引，即预测的分类        # 将pred转换为y_test的数据类型        pred = tf.cast(pred, dtype=y_test.dtype)        # 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)        # 将每个batch的correct数加起来        correct = tf.reduce_sum(correct)        # 将所有batch中的correct数加起来        total_correct += int(correct)        # total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数        total_number += x_test.shape[0]    # 总的准确率等于total_correct/total_number    acc = total_correct / total_number    test_acc.append(acc)    print(&quot;Test_acc:&quot;, acc)    print(&quot;--------------------------&quot;)# 绘制 loss 曲线plt.figure(figsize=(20,8),dpi=120)plt.title(&#39;Loss Function Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x轴变量名称plt.ylabel(&#39;Loss&#39;)  # y轴变量名称plt.plot(train_loss_results, label=&quot;$Loss$&quot;)  # 逐点画出trian_loss_results值并连线，连线图标是Lossplt.legend()  # 画出曲线图标plt.show()  # 画出图像# 绘制 Accuracy 曲线plt.title(&#39;Acc Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x轴变量名称plt.ylabel(&#39;Acc&#39;)  # y轴变量名称plt.plot(test_acc, label=&quot;$Accuracy$&quot;)  # 逐点画出test_acc值并连线，连线图标是Accuracyplt.legend()plt.show()plt.savefig(&quot;./firstNetwork.png&quot;)#保存图片</code></pre><h2 id="神经网络优化"><a href="#神经网络优化" class="headerlink" title="神经网络优化"></a>神经网络优化</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="tf-where"><a href="#tf-where" class="headerlink" title="tf.where()"></a>tf.where()</h4><ul><li><p>条件语句真返回A，条件语句假返回B</p></li><li><p>tf.where(条件语句,真返回A，假返回B)</p><pre><code class="python">a=tf.constant([1,2,3,1,1])b=tf.constant([0,1,3,4,5])c=tf.where(tf.greater(a,b), a, b)  若a&gt;b，返  回a对应位置的元素,否则  返回b对应位置的元素print(&quot;c:&quot;,c)  运行结果:c:tf.Tensor([1 2345], shape=(5,), dtype=int32)</code></pre></li></ul><h4 id="np-random-RandomState-rand"><a href="#np-random-RandomState-rand" class="headerlink" title="np.random.RandomState.rand()"></a>np.random.RandomState.rand()</h4><ul><li>返回一个[0,1)之间的随机数</li><li>np.random.RandomState.rand(维度)<br>维度为空，返回标量</li></ul><pre><code class="python">import numpy as nprdm=np.random.RandomState(seed:1) #seed=常数每次生成随机数相同a=rdm.rand()#返回一个随机标量b=rdm.rand(2,3)#返回维度为2行3列随机数矩阵print(&quot;a:&quot;,a)print(&quot;b:&quot;,b)#运行结果:a: 0.417022004702574b: [[7.20324493e-01 1.14374817e-04 3.02332573e-01][1.46755891e-01 9.23385948e-02 1.86260211e-01]]</code></pre><h4 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a>np.vstack()</h4><ul><li>将两个数组按垂直方向叠加np.vstack(数组1，数组2)</li></ul><pre><code class="python">import numpy as npa=np.array([1,2,3])b = np.array([4,5,6])C=np.vstack((a,b))np.vstack()print(&quot;c:ln&quot;,c)运行结果:c:        [[1,2,3],         [4,5,6]]</code></pre><h4 id="np-mgrid-ravel-np-c"><a href="#np-mgrid-ravel-np-c" class="headerlink" title="np.mgrid[ ]     .ravel()     np.c_[]"></a>np.mgrid[ ]     .ravel()     np.c_[]</h4><p>生成网格坐标点</p><ul><li>np.mgrid[起始值:结束值:步长，起始值:结束值:步长，…]</li><li>x.ravel() 将x变为一维数组，“把.前变量拉直”</li><li>np.c [1使返回的间隔数值点配对<br>np.c_[数组1，数组2，….]</li></ul><pre><code class="python">- import numpy as np  X, y= np.mgrid[1:3:1,2:4:0.5]  grid =np.c_[x.ravel(), y.ravel  print(&quot;x:&quot;,x)  print(&quot;y:&quot;,y)  print(&#39;grid:\n&quot;, grid)</code></pre><h3 id="复杂学习率"><a href="#复杂学习率" class="headerlink" title="复杂学习率"></a>复杂学习率</h3><h4 id="神经网络（NN）复杂度"><a href="#神经网络（NN）复杂度" class="headerlink" title="神经网络（NN）复杂度"></a>神经网络（NN）复杂度</h4><ul><li><p>√NN复杂度:多用NN层数和NN参数的个数表示</p><ul><li><p>空间复杂度:</p><ul><li>√层数=隐藏层的层数+1个输出层左图为2层NN</li><li>√总参数=总w＋总b</li></ul></li><li><p>时间复杂度:</p><ul><li>√乘加运算次数</li></ul></li></ul></li></ul><h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p>可以先用较大的学习率，快速得到较优的解，然后逐步减小学习率，使模型后期稳定</p><p>指数衰减学习率=初始学习率*当习率衰减率（当前轮数/多少轮衰减一次）</p><pre><code class="python">epoch=40LR BASE =0.2LR DECAY =0.99LR STEP =1for epoch in range (epoch):    lr = LR BASE *LR DECAY **(epoch / LR STEP)    with tf.GradientTape()as tape:        loss = tf.square(w +1)    grads = tape.gradient (loss, w)    w.assign sub (lr *grads)    print (&quot;After s epoch,w is %f,loss is %f,lr is %f&quot;%(epoch, w.numpy() , loss,lr))</code></pre><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="√优秀的激活函数"><a href="#√优秀的激活函数" class="headerlink" title="√优秀的激活函数:"></a>√优秀的激活函数:</h4><ul><li><p>非线性:激活函数非线性时，多层神经网络可逼近所有函数(只有网络是非线性的时候才不会被单层网络替代)</p></li><li><p>可微性:优化器大多用梯度下降更新参数</p></li><li><p>单调性:当激活函数是单调的，能保证单层网络的损失函数是凸函数（保证单层网络的损失函数是凸函数）</p></li><li><p>近似恒等性:f(x)sx当参数初始化为随机小值时，神经网络更稳定</p></li></ul><h4 id="√激活函数输出值的范围"><a href="#√激活函数输出值的范围" class="headerlink" title="√激活函数输出值的范围:"></a>√激活函数输出值的范围:</h4><ul><li>激活函数输出为有限值时，基于梯度的优化方法更稳定（权重对特征的影响更加显著）</li><li>激活函数输出为无限值时，建议调小学习</li></ul><h4 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h4><h5 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h5><p>近年来用sigmoid作为激活函数的网络越来越少，因为深层神经网络进行链式求导的时候，需要从输出层到输入层逐层进行链式求导，但是sigmoid函数的导数是0到0.25之间的小数，链式求导需要多层连续相乘，会出现多个0到0.25之间的连续相乘，结果将会趋于0,产生梯度消失，让参数无法继续更新</p><p>我们希望输入每层神经网络的特征是以0为均值的小数，但是sigmoid后的都是正数，收敛变慢，幂运算计算复杂度大训练时间长</p><ul><li>容易造成梯度消失</li><li>输出非0均值，收敛慢</li><li>幂运算复杂，训练时间长</li></ul><h5 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h5><ul><li>输出0均值</li><li>同样梯度消失</li><li>幂运算复杂，训练时间长</li></ul><h5 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h5><p>tf.nn.relu(x)</p><p>是个分段函数，</p><p>优点：</p><ul><li>解决了梯度消失问题</li><li>只需判断输入是否大于0，计算速度快</li><li>收敛远远快于前两者</li></ul><p>缺点：</p><ul><li>输出不是0均值，收敛慢</li><li>dead ReIU问题：当激活特征是负数时，某些神经元无法被激活，导致参数无法被更新<ul><li>设置更小学习率</li><li>减少参数分布的巨大变化</li></ul></li></ul><h5 id="Leaky-Relu"><a href="#Leaky-Relu" class="headerlink" title="Leaky Relu"></a>Leaky Relu</h5><p>tf.nn.leaky_relu(x)</p><p>为了解决relu负区间为0引起神经元死亡而设置的，使其负区间斜率不为0，无完全证明标书leaky relu比relu更好</p><p>但一般都用relu</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>首选relu激活函数;</li><li>√学习率设置较小值;</li><li>输入特征标准化,即让输特征满足以0为均值,1为标准差的正态分布;</li><li>初始参数中心化，即让随机生成的参数满足以0为均值,根下输入特征分之2为标准差的正态分布</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数（loss） :预测值（y)与已知答案（y_）的差距</p><p>NN优化目标:loss最小</p><p>主流的损失函数：</p><ul><li><p>mse (Mean Squared Error)</p></li><li><p>自定义</p></li><li><p>ce(Cross Entropy)交叉熵</p></li></ul><h4 id="均方误差mse"><a href="#均方误差mse" class="headerlink" title="均方误差mse:"></a>均方误差mse:</h4><pre><code class="python">loss_mse = tf.reduce_mean(tf.square(y_-y))</code></pre><h4 id="自定义损失函数："><a href="#自定义损失函数：" class="headerlink" title="自定义损失函数："></a>自定义损失函数：</h4><p>对不同的损失赋予不同的惩罚</p><pre><code class="python">loss zdy= tf.reduce _sum(where :(tf.greatery,y_b, cOST(y -y_),PROFT(y_-y))</code></pre><h4 id="交叉熵："><a href="#交叉熵：" class="headerlink" title="交叉熵："></a>交叉熵：</h4><p>√交叉嫡损失函数CE(Cross Entropy):表征两个概率分布之间的距离</p><p>eg.二分类已知答案y_=(1,0)预测y,=(0.6, 0.4)y2=(0.8, 0.2)哪个更接近标准答案?</p><p>H1((1.0),(0.6,0.4))=-(1<em>ln0.6+O</em>ln0.4)~~(-0.511 ＋0)=0.511</p><p>H2((1,0).(0.8,0.2))=-(1<em>ln0.8+O</em>ln0.2)~~(-0.223+0)=0.223</p><p>因为H&gt;H，所以y,预测更准</p><pre><code class="python">tf.losses.categorical_crossentropy(y ,y)loss_ce1=tf.losses.categorical_ crossentropy([1,0],[0.6,0.4])loss_ce1=tf.losses.categorical_ crossentropy([1,0],[0.8,0.2])print(&quot;loss_ce1:&quot;, loss_ce1)print(&quot;loss_ce2:&quot;, loss_ce2)</code></pre><p>softmax与交叉结合</p><p>√输出先过softmax函数，再计算第y与y_的交叉嫡损失函数。</p><pre><code class="python">tf.nn.softmax_cross_entropy_with_logits(y_,y)Y_= np.array([[1, 0, 0],[0,1,0],[0, 0,1],[1,0,0],[0,1,0]])y = np.array([[12,3,2],[3,10,1],[1,2, 5],[4,6.5,1.2],[3,6, 1]])y_pro= tf.nn.softmax(y)loss_ce1 = tf.losses.categorical_crossentropy(y_,y_pro)loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_y)print(&#39;分步计算的结果:ln&#39;, loss_ce1)print(&#39;结合计算的结果:ln&#39;, loss_ce2)</code></pre><h3 id="缓解过拟合"><a href="#缓解过拟合" class="headerlink" title="缓解过拟合"></a>缓解过拟合</h3><p>过拟合把数据点记住了，导致模型过度训练，泛化性弱</p><h4 id="欠拟合的解决方法："><a href="#欠拟合的解决方法：" class="headerlink" title="欠拟合的解决方法："></a>欠拟合的解决方法：</h4><ul><li>增加输入特征</li><li>增加网络参数</li><li>减少正则化参数</li></ul><h4 id="过拟合的解决方法："><a href="#过拟合的解决方法：" class="headerlink" title="过拟合的解决方法："></a>过拟合的解决方法：</h4><ul><li>数据清洗减少噪声</li><li>增大训练集</li><li>采用正则项</li><li>增大正则化参数</li></ul><p>下面详细介绍正则化：</p><p>正则化就是在损失函数中引入模型复杂度指标：，给每个参数w加上权重，抑制训练集中的噪声(一般不正则化b)</p><p>loss = loss(y与y)+ REGULARIZER * loss(w)</p><p>loss(y与y)是模型中所有参数的损失函数<br>超参数REGULARIZER给出参数w在总loss中的比例，即正则化的权重<br>w是需要正则化的参数</p><p>一般：</p><ul><li>L1正则：loss(w)=lwI</li><li>L2正则：loss 2(w)=sum(w^2)</li></ul><p>√正则化的选择：</p><ul><li><p>L1正则化大概率会使很多参数变为零,<br>因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度。</p></li><li><p>L2正则化会使参数很接近零但不为零,<br>因此该方法可通过减小参数<br>值的大小降低复杂度。</p><p>下面是代码：</p><pre><code class="python">with tf.GradientTape() as tape:    hl = tf.matmul(x train, wl)+ b1    h1 = tf.nn.relu(hl)    y = tf.matmul(h1, w2)+ b2    loss mse = tf.reduce mean (tf.square(y train - y))    loss regularization = []    loss regularization.append (tf.nn.l2_loss(wl))    loss regularization. append (tf.nn. l2_ loss(w2))    loss regularization = tf.reduce sum (loss regularization)    loss = loss mse + 0.03 *loss regularizationvariables = [w1,b1， w2，b2]grads = tape. gradient (loss, variables)</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tensorflow基础&quot;&gt;&lt;a href=&quot;#Tensorflow基础&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow基础&quot;&gt;&lt;/a&gt;Tensorflow基础&lt;/h1&gt;&lt;p&gt;​    TensorFlow是现在比较火爆的一个深度学习的</summary>
      
    
    
    
    <category term="machinlearning" scheme="http://sweetheart.nefu.site/categories/machinlearning/"/>
    
    
    <category term="DeepLearning" scheme="http://sweetheart.nefu.site/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之sklearn</title>
    <link href="http://sweetheart.nefu.site/2020/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn/"/>
    <id>http://sweetheart.nefu.site/2020/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn/</id>
    <published>2020-10-21T06:59:54.000Z</published>
    <updated>2020-10-22T15:56:06.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习笔记之sklearn"><a href="#机器学习笔记之sklearn" class="headerlink" title="机器学习笔记之sklearn"></a>机器学习笔记之sklearn</h1><p>  sklearn是机器学习中重要的测试数据集来源之一，并且可以提供特征提取以及降维聚类等功能</p><p>   蒟蒻从今天起开始机器学习调库调参的第一步，</p><h3 id="sklearn数据集介绍"><a href="#sklearn数据集介绍" class="headerlink" title="sklearn数据集介绍"></a>sklearn数据集介绍</h3><h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><p>数据集的操作有:</p><ul><li>load_*获取自带的较小的数据集</li><li>fetchg_*获取外部的较大的数据集</li></ul><pre><code class="python">import sklearn.datasets from sklearn.datasets import load_iris //导入鸢尾花数据集iris=load_iris()print(&quot;鸢尾花的数据集返回值&quot;,iris)print(&quot;鸢尾花数据的描述&quot;,iris[&quot;DESCR&quot;])print(&quot;鸢尾花数据的特征值&quot;,iris.data)print(&quot;鸢尾花的目标值&quot;,iris.target)print(&quot;鸢尾花的特征值名字&quot;,iris.data.shape)print(&quot;鸢尾花的特征值名字&quot;,iris.feture_name)</code></pre><p>sklearn返回值介绍：</p><ul><li>load 和fetch返回的是字典格式<ul><li>data：特征数据集</li><li>target:标签数据</li><li>DESCR:数据描述</li><li>feature_names:特征名字，新闻数据，手写数字，回归数据集没有</li><li>target_name:标签名</li></ul></li></ul><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><p>进行机器学习的时候我们要对数据集进行划分，划分成训练集和测试集</p><p>​    一般来说，测试集所占比例比较少：</p><ul><li>一般：测试集一般占比20%~30%{sklearn库中划分函数默认25%}</li><li>训练集特征值，测试集特征值，训练集特征值。测试目标集特征值分别是：x_train x_test  y_train y_test</li></ul><p>训练集划分api：</p><pre><code class="python">from sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitiris=load_iris()print(&quot;鸢尾花的数据集返回值&quot;, iris)print(&quot;鸢尾花数据的描述&quot;, iris[&quot;DESCR&quot;])print(&quot;鸢尾花数据的特征值&quot;, iris.data)print(&quot;鸢尾花的目标值&quot;, iris.target)print(&quot;鸢尾花的特征值名字&quot;, iris.data.shape)print(&quot;鸢尾花的特征值名字&quot;, iris.feature_names)x_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=22)//第一个参数：数据集x的特征值，第二个参数数据集y的特征值，测试集的占比,第三个随机分配时数种子//返回：训练集特征值，测试集特征值，训练集目标值，测试集目标值</code></pre><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>即是对一些非数值的数据，比如对文本语音图像等，将其转换成数值化，便于进行矩阵运算</p><p>特征提取用于降维等等</p><p>特征工程：</p><p>一般用sklearn进行特征提取、</p><p>而用pandas进行数据清洗，数据抽取，等预处理工作</p><ul><li><p>目标</p><ul><li>应用DicVectorizer实现对类别特征进行数值化离散化</li><li>应用CountVectorizer实现对文本特征进行数值化</li><li>应用TfidVectorizer实现对文本特征进行数值化</li></ul></li><li><p>特征提取api</p><pre><code class="python">sklearn.feature_extraction</code></pre></li></ul><h4 id="对字典进行数值化抽取"><a href="#对字典进行数值化抽取" class="headerlink" title="对字典进行数值化抽取"></a>对字典进行数值化抽取</h4><pre><code class="python">from sklearn.feature_extraction import DictVectorizerdef dict_demo():    data = [&amp;#123;&#39;city&#39;: &#39;beijing&#39;, &#39;number&#39;: 1&amp;#125;, &amp;#123;&#39;city&#39;: &#39;guangdong&#39;, &#39;number&#39;: 4&amp;#125;, &amp;#123;&#39;city&#39;: &#39;shanghai&#39;, &#39;number&#39;: 3&amp;#125;]    transfer = DictVectorizer()  # 实例化转换器    data_new = transfer.fit_transform(data)    print(&quot;data_new:&quot;, data_new)    print(&quot;data_new的名字:&quot;, transfer.feature_names_)#查看矩阵各列代表属性    return Noneif __name__ == &quot;__main__&quot;:    dict_demo()</code></pre><p>返回的矩阵：</p><pre><code>data_new:   (0, 0)    1.0  (0, 3)    1.0  (1, 1)    1.0  (1, 3)    4.0  (2, 2)    1.0  (2, 3)    3.0返回的是一个稀疏矩阵，当把稀疏矩阵转换成矩阵形式的时候，设置稀疏矩阵falsetransfer = DictVectorizer(sparse=False)输出：data_new: [[1. 0. 0. 1.] [0. 1. 0. 4.] [0. 0. 1. 3.]] data_new的名字: [&#39;city=beijing&#39;, &#39;city=guangdong&#39;, &#39;city=shanghai&#39;, &#39;number&#39;]</code></pre><h4 id="文本特征提取"><a href="#文本特征提取" class="headerlink" title="文本特征提取"></a>文本特征提取</h4><pre><code class="python">from sklearn.feature_extraction.text import CountVectorizerdef count_demo():    data = [&quot;lfe is short l like python&quot;, &quot;life is short ,code more&quot;]    transfer = CountVectorizer()    data_new = transfer.fit_transform(data)    print(&quot;data_new:\n&quot;, data_new)     print(&quot;特征名字：\n&quot;,transfer.get_feature_names())#调用此方法获取矩阵的值    return Noneif __name__ == &quot;__main__&quot;:    count_demo()</code></pre><p>同样返回的是一个稀疏矩阵：</p><pre><code class="python">data_new:   (0, 2)    1  (0, 1)    1  (0, 7)    1  (0, 4)    1  (0, 6)    1  (1, 1)    1  (1, 7)    1  (1, 3)    1  (1, 0)    1  (1, 5)    1  特征名字： [&#39;code&#39;, &#39;is&#39;, &#39;lfe&#39;, &#39;life&#39;, &#39;like&#39;, &#39;more&#39;, &#39;python&#39;, &#39;short&#39;]    #可见过滤了I等低频词汇    #若对中文进行词频抽取，要用空格隔开词语</code></pre><h4 id="中文文本抽取"><a href="#中文文本抽取" class="headerlink" title="中文文本抽取"></a>中文文本抽取</h4><p>from sklearn.feature_extraction.text import CountVectorizer(stop_word=[])</p><p>这里的stop_word是跳过词，抽取时忽略这个词，自然语言处理时用停顿词表进行无关词语忽略</p><p>这里把把is和like作为停顿词</p><pre><code class="python">transfer = CountVectorizer(stop_words=[&#39;is&#39;, &#39;like&#39;])</code></pre><p>输出特征名字：<br> [‘code’, ‘lfe’, ‘life’, ‘more’, ‘python’, ‘short’]</p><p>中文文本抽取：</p><p>由于中文文本在CountVectorizer中使用必需分词，所以要调用jieba的分词函数</p><pre><code class="python">import jieba  # 对中文文本进行分词处理def cut_word(text):    # 中文文本分词函数    text = &quot;&quot;.join(list(jieba.cut(text)))    # jibe分词函数-&gt;转化成；列表—&gt;转化成字符串    return textdef count_Chinese():    data = [&quot;一种还是一种今天很残酷，明天更加残酷，但是对大部分人来说&quot;, &quot;进行机器学习的时候我们要对数据集进行划分，划分成训练集和测试集&quot;, &quot;一般来说，测试集所占比例比较少&quot;,            &quot;训练集特征值，测试集特征值，训练集特征值。测试目标集特征值分别是：x_train x_test  y_train y_test&quot;]    data_new = []    for i in data:        data_new.append(cut_word(i))    print(data_new)    return Noneif __name__ == &quot;__main__&quot;:    count_Chinese()</code></pre><p>然后对生成列表进行特征抽取</p><p>然而这样的特征抽取没有突出高频率词汇，所以要对高频率词汇进行提取</p><p>但是有些词比较辣鸡，不该作为信息抽取</p><h4 id="文本特征抽取2"><a href="#文本特征抽取2" class="headerlink" title="文本特征抽取2"></a>文本特征抽取2</h4><p>关键词：在某一个类别的文章中出现次数多，但在其他文章中出现次数少的词汇，标志了一个文本的特征</p><p>Tf-idf文本特征抽取原理即是如此</p><p>tf:词频</p><p>idf:逆向文本频率:</p><p>由文本文件数目除以包含词语的文件的数目，再将得到的商取以10为底的对数</p><p>Tf-idf=tf*idf</p><p>举例：</p><p>语料库：1000文章</p><p>100文章有非常</p><p>10偏有经济</p><p>两篇文章：</p><p>​    A文章（100词）：经济10词</p><p>​        ‘经济’：</p><p>​            tf=0.1</p><p>​            idf=log 10 1000/10=2</p><p>​            Tf-idf=0.2</p><p>​    B文章（100词）：非常10词</p><p>​        ‘非常’：</p><p>​        tf=0.1</p><p>​        idf=log 10 1000/100=1</p><p>​        Tf-idf=0.1</p><p>ApI</p><pre><code class="python">from sklearn.feature_extraction.text import TfidfVectorizerdef Tfidf_demo():    data = [&quot;lfe is short l like python&quot;, &quot;life is short ,code more&quot;]    transfer = TfidfVectorizer(stop_words=[&#39;is&#39;, &#39;like&#39;])    data_new = transfer.fit_transform(data)    print(&quot;data_new:\n&quot;, data_new)    print(&quot;特征名字：\n&quot;, transfer.get_feature_names())    return None#就实例化的时候改了下转换器的名字if __name__ == &quot;__main__&quot;:    Tfidf_demo()</code></pre><p>实例化和提取操作类似于CountVectorizer，同样有停顿词功能</p><p>返回：</p><pre><code class="python">data_new:   (0, 4)    0.6316672017376245  (0, 5)    0.4494364165239821  (0, 1)    0.6316672017376245  (1, 3)    0.534046329052269  (1, 0)    0.534046329052269  (1, 2)    0.534046329052269  (1, 5)    0.37997836159100784特征名字： [&#39;code&#39;, &#39;lfe&#39;, &#39;life&#39;, &#39;more&#39;, &#39;python&#39;, &#39;short&#39;]</code></pre><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p>为了使数据更加适合算法模型处理</p><p>归一化就是在将数据处理在一定中范围内</p><p>如果不对数据进行归一化处理，那么数据将会由于某一个特征值过于巨大而导致其他特征值被忽略，（在聚类中的欧式距离计算中尤为明显）</p><p>所以要将几个数据项的值固定在一个统一的范围内：</p><p>数学上叫做无量纲化</p><p>公式</p><pre><code class="python">x&#39;=(x-min)/(max-min)x&#39;&#39;=x&#39;*(mx-mi)+mi</code></pre><p>例如有数据[90,60,75]</p><p>对于数据90：</p><p>x’=(90-60)/(90-60)=1</p><p>x”=1*(1)+0=1   #放缩到1-0区间，mx=1，mi=0</p><p>ApI:</p><pre><code class="python">import pandas as pd#调用pandas清洗函数from sklearn.preprocessing import MinMaxScaler#调用归一化函数def minmax():    data=pd.read_csv(&quot;titanic/test.csv&quot;)    data=data.iloc[:6, :2]    #截取数据前两列前6行    trans=MinMaxScaler()#实例化转换器    datanew=trans.fit_transform(data)    print(datanew)    return Noneif __name__ == &quot;__main__&quot;:    minmax()</code></pre><p>输出：</p><pre><code class="python">[[0.  1. ] [0.2 1. ] [0.4 0. ] [0.6 1. ] [0.8 1. ] [1.  1. ]]</code></pre><p>这样在处理聚类数据的时候可以减少特征值之间的差距</p><h4 id="标准化处理"><a href="#标准化处理" class="headerlink" title="标准化处理"></a>标准化处理</h4><p>当数据中有缺失值和异常值，做归一化处理得到的数据可能会有缺陷，这种方式鲁棒性较差，只适合传统的精确度小的数据处理</p><p>异常值通常是：</p><ul><li>最大值</li><li>最小值</li></ul><p>标准化定义</p><p>对原始数据变换将数据变为均值为0，标准差为1</p><p>公式：</p><p>x’=(x-mean)/std</p><p>std=标准差</p><p>API</p><pre><code class="python">from sklearn.preprocessing import MinMaxScaler,StandardScaler#即在原来归一化基础上实例的时候改了转换器就行def std_demo():    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:6, :2]    # 截取数据前两列前6行    trans = StandardScaler() # 实例化转换器    datanew = trans.fit_transform(data)    print(datanew)    return Noneif __name__ == &quot;__main__&quot;:    std_demo()</code></pre><p>返回：</p><pre><code class="python">[[-1.46385011  0.4472136 ] [-0.87831007  0.4472136 ] [-0.29277002 -2.23606798] [ 0.29277002  0.4472136 ] [ 0.87831007  0.4472136 ] [ 1.46385011  0.4472136 ]]</code></pre><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>降维是在某些限定的条件，降低随机特征的个数，得到一组不相关主变量的过程</p><p>维数：嵌套层数</p><ul><li>0维：标量</li><li>1维：向量</li><li>2维：矩阵</li></ul><p>降低的对象：二维数组</p><p>此处降维：降低列数</p><ul><li>相关特征：<ul><li>相对湿度与降雨量之间的关系</li><li>等等</li></ul></li></ul><blockquote><p>正是因为在进行训练的时候，我们都是使用特征进行学习的，如果有特征本身存在问题或者特征之间相关性比较强，对于算法学习的预测影响会比较大</p></blockquote><p>降维的两种方法：</p><ul><li>特征选择</li><li>主成分分析</li></ul><p>特征选择：</p><p>数据中包含冗余的或相关变量，希望在原有特征中找出主要特征</p><p>方法：</p><ul><li>filter过滤式<ul><li>方差选择法：低方差特征过滤（说明此属性共有不必要）</li><li>相关系数法：特征与特征之间的相关程度</li></ul></li><li>embeded嵌入式<ul><li>决策树</li><li>正则化</li><li>深度学习</li></ul></li></ul><h4 id="低方差特征过滤"><a href="#低方差特征过滤" class="headerlink" title="低方差特征过滤"></a>低方差特征过滤</h4><p>API</p><pre><code class="python">import pandas as pdfrom sklearn.feature_selection import VarianceThresholddef varianse_demo():    # 过滤低方差    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:5, :2]    transfer = VarianceThreshold()    data = transfer.fit_transform(data)    print(data)    return Noneif __name__ == &quot;__main__&quot;:    varianse_demo()</code></pre><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p>皮尔森相关系数:</p><p>公式略</p><p>特点：</p><ul><li>当r&gt;0正相关，R&lt;0负相关</li><li>当r=-1or1完全相关，r=0表示毫无关系</li><li>越近于1相关性越强</li><li>0.4&lt;abs(r)&lt;0.7说明有一定相关性</li></ul><p>Api:</p><pre><code class="python">import pandas as pdfrom scipy.stats import pearsonrdef varianse_demo():    # 过滤低方差    data = pd.read_csv(&quot;titanic/test.csv&quot;)    data = data.iloc[:5, :2]    r = pearsonr(data[&quot;pe_ratio&quot;], data[&quot;pb_ratio&quot;])    print(r)    return Noneif __name__ == &quot;__main__&quot;:    varianse_demo()</code></pre><p>如果特征与多个特征之间相关性很高：</p><ul><li><p>选取其中一个</p></li><li><p>加权求和</p></li><li><p>主成分分析</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习笔记之sklearn&quot;&gt;&lt;a href=&quot;#机器学习笔记之sklearn&quot; class=&quot;headerlink&quot; title=&quot;机器学习笔记之sklearn&quot;&gt;&lt;/a&gt;机器学习笔记之sklearn&lt;/h1&gt;&lt;p&gt;  sklearn是机器学习中重要的测试数据</summary>
      
    
    
    
    <category term="machine learning" scheme="http://sweetheart.nefu.site/categories/machine-learning/"/>
    
    
    <category term="sklearn" scheme="http://sweetheart.nefu.site/tags/sklearn/"/>
    
    <category term="machine learning" scheme="http://sweetheart.nefu.site/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>pandaa&amp;&amp;numpy学习笔记</title>
    <link href="http://sweetheart.nefu.site/2020/10/04/pandas-numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.nefu.site/2020/10/04/pandas-numpy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-04T08:02:15.000Z</published>
    <updated>2020-12-31T12:35:01.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="numpy-matplotlib-pandas以及文件批量操作"><a href="#numpy-matplotlib-pandas以及文件批量操作" class="headerlink" title="numpy,matplotlib,pandas以及文件批量操作"></a>numpy,matplotlib,pandas以及文件批量操作</h1><p>写在前面，由于自己python基础能力有点菜，并且基本上每上手一个框架都需要这四方面的操作以及掌握，所以我决定恶补这方面的不足，故有了这样一篇博客，持续更新中~</p><ul><li>环境：conda,jupyter notebook</li></ul><h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><p>绘图用库，进行数据可视化，</p><h3 id="练手项目1-初识matplotlib，绘制折线图"><a href="#练手项目1-初识matplotlib，绘制折线图" class="headerlink" title="练手项目1 初识matplotlib，绘制折线图"></a>练手项目1 初识matplotlib，绘制折线图</h3><h4 id="教学部分"><a href="#教学部分" class="headerlink" title="教学部分"></a>教学部分</h4><p>假设一天中每隔两个小时（range（2,26,2））的气温分别是：</p><p>[15,13,14,5,17,20,25,26,27,22,18,15]</p><pre><code class="python">from matplotlib import pyplot as plt#导入pyplot模块x = range(2, 26, 2)#设置x轴的步距以及上下限y = [15, 13, 14, 5, 17, 20, 25, 26, 27, 22, 18, 15]#y轴的数据，和x对应plt.plot(x, y)#执行方法plt.show()#show方法#最后画出一个折线图</code></pre><p>要点：x和y的数据量一定要一一对应，不然会直接报错，要求步长和上下限list的数据大小和y中一样</p><p>但是这样生成的图表示的数据很模糊，没有标注以及并不好看</p><p>目前存在以下几个问题：</p><ul><li>设置图片大小</li><li>保存到本地</li><li>描述信息，比如x轴和y轴表示什么，这个图表示什么</li><li>描述x或者y的刻度的间距</li><li>标记出特殊点的（比如最高以及最低点）</li><li>给图片添加一个水印（防伪）</li></ul><p>设置图片大小/保存图片：</p><pre><code class="python">from matplotlib import pyplot as pltfig = plt.figure(figsize=(20, 8), dpi=80)# figure图形图标的意思，这里指的是我们画的图，通过实例化一个figure并且传递参数，能够在后台自动使用该figure实例# dpi参数，让图片更加清楚x = range(2, 26, 2)y = [15, 13, 14.5, 17, 20, 25, 26, 26, 27, 22, 18, 15]plt.plot(x, y)# 或者这种方法_xtick_labels=[i/2 for i in range(2,50)]# plt.xticks(_xtick_labels)采用传入数组的方法式# plt.yticks(range(min(y),max(y)+1))步距自动为1plt.xticks(range(2, 25))  # 设置x轴显示步距plt.yticks(range(10, 30, 1))  # range,(start ,end,step)plt.savefig(&quot;./first.png&quot;)  # 在本地保存plt.show()</code></pre><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>如果a表示10到12点的每一分钟的气温，如何绘制折线观察每分钟的气温变化</p><p> a=[random.randint(20,35) for i in range(120)]</p><pre><code class="python">from matplotlib import pyplot as pltimport random as rd#记得导入随机数库a = [rd.randint(20, 35) for i in range(120)]#设置x，y轴x = range(1, 121)plt.plot(x, a)#实例化图形plt.xticks(range(1, 121))plt.yticks(range(15, 41))#设置xy轴参数plt.show()#显示plt.savefig(&quot;./firstproject.png&quot;)#保存</code></pre><p>现在这个代码有点问题，问题在于x轴并不能如实反映钟点数，而是10进制</p><h5 id="转化成时间形式"><a href="#转化成时间形式" class="headerlink" title="转化成时间形式"></a>转化成时间形式</h5><p>修改后</p><pre><code class="python">from matplotlib import pyplot as pltimport random as rda = [rd.randint(20, 35) for i in range(120)]x = range(1, 121)plt.figure(figsize=(20,8),dpi=80)#修改长宽比，修改像素 这是决定图片好看与否的一个因素plt.plot(x, a)_x = list(x)[::3]  # 修改步长变成3，要修改成列表形式 _xtick_label = [&quot;10:&amp;#123;&amp;#125;&quot;.format(i) for i in range(60)]_xtick_label += [&quot;11:&amp;#123;&amp;#125;&quot;.format(i) for i in range(60)]  # 追加列表尾plt.xticks(_x, _xtick_label[::3],rotation=300)  # rotation旋转的度数#前两个参数数量大小应该一样，则不能完全覆盖整个轴#第一个参数：上下限，是个列表，第二个参数吗，同样是个列表，表示参数注释，注释基本上没有中文plt.yticks(range(15, 41))plt.show()plt.savefig(&quot;./firstproject.png&quot;)</code></pre><h5 id="显示中文以及修改设置"><a href="#显示中文以及修改设置" class="headerlink" title="显示中文以及修改设置"></a>显示中文以及修改设置</h5><p>在pycharm中，ctrol加上鼠标可查看模块源码</p><p>比如修改matplotlib的绘图设置，可以</p><pre><code class="python">import matplotlibmatplotlib.rc</code></pre><p>然后点开源码，进行查看</p><pre><code class="python"> &quot;&quot;&quot;    Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,    for ``lines.linewidth`` the group is ``lines``, for    ``axes.facecolor``, the group is ``axes``, and so on.  Group may    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).    *kwargs* is a dictionary attribute name/value pairs, e.g.,::      rc(&#39;lines&#39;, linewidth=2, color=&#39;r&#39;)可以设置线条样式    sets the current `.rcParams` and is equivalent to::      rcParams[&#39;lines.linewidth&#39;] = 2      rcParams[&#39;lines.color&#39;] = &#39;r&#39;    The following aliases are available to save typing for interactive users:    =====   =================    Alias   Property    =====   =================    &#39;lw&#39;    &#39;linewidth&#39;    &#39;ls&#39;    &#39;linestyle&#39;    &#39;c&#39;     &#39;color&#39;    &#39;fc&#39;    &#39;facecolor&#39;    &#39;ec&#39;    &#39;edgecolor&#39;    &#39;mew&#39;   &#39;markeredgewidth&#39;    &#39;aa&#39;    &#39;antialiased&#39;    =====   =================    Thus you could abbreviate the above call as::          rc(&#39;lines&#39;, lw=2, c=&#39;r&#39;)    Note you can use python&#39;s kwargs dictionary facility to store    dictionaries of default parameters.  e.g., you can customize the    font rc as follows::      font = &amp;#123;&#39;family&#39; : &#39;monospace&#39;,或者这种字典写法，引入后一一对应              &#39;weight&#39; : &#39;bold&#39;,              &#39;size&#39;   : &#39;larger&#39;&amp;#125;      rc(&#39;font&#39;, **font)  # pass in the font dict as kwargs    This enables you to easily switch between several configurations.  Use    ``matplotlib.style.use(&#39;default&#39;)`` or :func:`~matplotlib.rcdefaults` to    restore the default `.rcParams` after changes.    Notes    -----    Similar functionality is available by using the normal dict interface, i.e.    ``rcParams.update(&amp;#123;&quot;lines.linewidth&quot;: 2, ...&amp;#125;)`` (but ``rcParams.update``    does not support abbreviations or grouping).    &quot;&quot;&quot;</code></pre><p>则可以</p><pre><code class="python">import matplotlibfont = &amp;#123;&#39;family&#39; : &#39;monospace&#39;              &#39;weight&#39; : &#39;bold&#39;,              &#39;size&#39;   : &#39;larger&#39;&amp;#125;matplotlib.rc(&#39;font&#39;, **font)</code></pre><p>或者通过此显示中文</p><pre><code class="python">from matplotlib import font_managermy_font=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\PingFang.ttc&quot;)#字体所在地址</code></pre><p>具体中文显示可以见此博客</p><p><a href="https://blog.csdn.net/fengdu78/article/details/111189331?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160933291616780265368901%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160933291616780265368901&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-111189331.pc_search_result_cache&utm_term=font_manager.FontProperties">使用matplotlib绘图时中文字体的解决方案</a></p><h5 id="给图添加描述信息"><a href="#给图添加描述信息" class="headerlink" title="给图添加描述信息"></a>给图添加描述信息</h5><pre><code class="python">plt.xlabel(&quot;Time&quot;)plt.ylabel(&quot;temperaturec&quot;)#x与y轴分别标注plt.title(&quot;10:00-12:00&quot;)#给图添加标题</code></pre><p>总结：</p><ul><li><p>学习了怎么绘图：</p><ul><li>from matplotlib import pyplot as plt</li><li>plt.plot(x,y)</li><li>plt.show()</li></ul><p>这三个是绘图的主要流程，即调库，导入数据，显示</p></li><li><p>对图形进行优化</p><ul><li>plt.figure(长宽比,像素)</li><li>_xtick_label实例化一个列表后，作为参数导入plt.xticks(）方法，从而对x轴进行优化、</li><li>plt.xlabel()和plt.ylabel(）解释参数plt.title()给图片命名</li><li>保存图片plt.savefig（）</li><li>字体设置，详见博客</li></ul></li></ul><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_551150525955559424.html?v=1609334127000" alt="课后作业"></p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltx = [i for i in range(11,31)]y = [1, 0, 1, 1, 2, 4, 3, 2, 3, 4, 4, 5, 6, 5, 4, 3, 3, 1, 1, 1]plt.figure(figsize=(20, 8), dpi=80)plt.plot(x, y)plt.xlabel(&quot;age&quot;)plt.ylabel(&quot;the number of girl(boy) friends&quot;)plt.title(&quot;my plot&quot;)_x = list(x)x_label= [&quot;&amp;#123;&amp;#125;year&quot;.format(i) for i in range(11,31)]y_label = [&quot;&amp;#123;&amp;#125; boys or girls&quot;.format(i) for i in y]plt.xticks(_x,x_label,rotation=300)plt.yticks(range(0,9))#注意名字不能写错，plt.show()</code></pre><h3 id="练手项目2-绘制散点图和折线图"><a href="#练手项目2-绘制散点图和折线图" class="headerlink" title="练手项目2 绘制散点图和折线图"></a>练手项目2 绘制散点图和折线图</h3><h4 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h4><p>假设通过爬虫你获取到了北京2016年3,10月份每天白天的最高气温(分别位于列表a,b),那么此时如何寻找出气温和随时间(天)变化的某种规律?</p><p>a =[11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]</p><p>b =[26,26,28,19,21,17,16,19,18,20,20,19,22,23,17,20,21,20,22,15,11,15,5,13,17,10,11,13,12,13,6]</p><p>三月单独绘制代码如下：</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managery_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22, 22,     23]y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13, 12,     13, 6]x=range(1,32)plt.scatter(x,y_3)plt.show()</code></pre><p>但是这时并没有达到我们想要的结果，我们想要绘制一个三月十月同时存在的图，并且有完整图例</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)y_3 = [11, 17, 16, 11, 12, 11, 12, 6, 6, 7, 8, 9, 12, 15, 14, 17, 18, 21, 16, 17, 20, 14, 15, 15, 15, 19, 21, 22, 22,       22,       23]y_10 = [26, 26, 28, 19, 21, 17, 16, 19, 18, 20, 20, 19, 22, 23, 17, 20, 21, 20, 22, 15, 11, 15, 5, 13, 17, 10, 11, 13,        12,        13, 6]x_3 = range(1, 32)x_10 = range(51, 82)plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.scatter(x_3, y_3,label=&quot;三月份&quot;)plt.scatter(x_10, y_10,label=&quot;十月份&quot;)_x = list(x_3) + list(x_10)_xticks_labels = [&quot;三月&amp;#123;&amp;#125;日&quot;.format(i) for i in x_3]_xticks_labels += [&quot;十月&amp;#123;&amp;#125;日&quot;.format(i - 50) for i in x_10]plt.legend(loc=&quot;upper left&quot;,prop=myfont)#添加图例plt.xticks(_x[::3], _xticks_labels[::3],fontProperties=myfont, rotation=300)plt.ylabel(&quot;气温C&quot;,fontProperties=myfont)plt.title(&quot;气温对照表&quot;,fontProperties=myfont)plt.show()</code></pre><p>之后会利用散点图绘制线性回归的拟合曲线</p><h4 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h4><p>a =[“战狼2”,”速度与激情8” “功夫瑜伽”∵”西游伏妖篇”,”变形金刚5∶最后的骑士”,”摔跤吧!爸爸” ,”加勒比海盗5∶死无对证”,”金刚:骷髅岛”,”极限特工:终极回归”,”生化危机6:终章”, “乘风破浪”∵”神偷奶爸3”,”智取威虎山”;”大闹天竺”,”金刚狼3∶殊死一战” ,”蜘蛛侠:英雄归来”,”悟空传”,”银河护卫队2”,”情圣”,”新木乃伊”,]</p><p>b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23]单位:亿</p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a = [&quot;战狼2&quot;,&quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;,&quot;西游伏妖篇&quot;,&quot;变形金刚5∶最后的骑士&quot;,&quot;摔跤吧!爸爸&quot; ]b = [56.01,26.94,17.53,16.49,15.45,12.96]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.bar(range(len(a)),b,width=0.3)plt.xticks(range(len(a)),a,fontProperties=myfont, rotation=300)plt.show()</code></pre><p>截断了前6个</p><p>但是我们更加希望是变成竖着的条形图，那么就改成barh,于是代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a = [&quot;战狼2&quot;,&quot;速度与激情8&quot;, &quot;功夫瑜伽&quot;,&quot;西游伏妖篇&quot;,&quot;变形金刚5∶最后的骑士&quot;,&quot;摔跤吧!爸爸&quot; ]b = [56.01,26.94,17.53,16.49,15.45,12.96]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别plt.barh(range(len(a)),b,height=0.3,color=&quot;red&quot;)#改成竖图后，wight应该改成hightplt.yticks(range(len(a)),a,fontProperties=myfont)plt.grid(alpha=0.3)#设置网格plt.show()</code></pre><h4 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h4><p>假设你知道了列表a中电影分别在2017-09-14(b_ 14), 2017-09 -15(b _15),2017-09-16(b _16)三天的票房，为了展示列表中电影本身的票房以及同其他假设你知道了列表a中电影分别在2017-09- -14(b14), 2017-09 -15(b15),<br>2017-09- 16(b16)三天的票房，为了展示列表中电影本身的票房以及同其他电影的数据对比情况,应该如何更加直观的呈现该数据?<br>a= [“猩球崛起3:终极之战”,”敦刻尔克”，”蜘蛛侠:英雄归来”,”战狼2”]<br>b16 = [15746,312,4497,319]<br>b15 = [12357,156,2045,168]<br>b14 = [2358,399,2358,362]</p><p>代码如下</p><pre><code class="python">from matplotlib import pyplot as pltfrom matplotlib import font_managermyfont=font_manager.FontProperties(fname=&quot;C:\Windows\Fonts\STKAITI.TTF&quot;)a= [&quot;猩球崛起3:终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠:英雄归来&quot;,&quot;战狼2&quot;]b16 = [15746,312,4497,319]b15 = [12357,156,2045,168]b14 = [2358,399,2358,362]plt.figure(figsize=(20, 8), dpi=120)#与绘制折线图唯一的区别x_14=list(range(len(a)))x_15=[i+0.2 for i in x_14]x_16=[i+0.4 for i in x_14]plt.bar(range(len(a)),b14,width=0.2,color=&quot;red&quot;,label=&quot;九月14&quot;)plt.bar(x_15,b15,width=0.2,color=&quot;orange&quot;,label=&quot;九月15&quot;)plt.bar(x_16,b16,width=0.2,color=&quot;blue&quot;,label=&quot;九月16&quot;)#改成竖图后，wight应该改成hightplt.legend(prop=myfont)plt.xticks(range(len(a)),a,fontProperties=myfont)plt.grid(alpha=0.3)#设置网格plt.show()</code></pre><p>暂时的matplotlib到这，更多用法查询csdn</p><h4 id="其他绘图工具推荐"><a href="#其他绘图工具推荐" class="headerlink" title="其他绘图工具推荐"></a>其他绘图工具推荐</h4><p>echart:一个前端js框架</p><p>plotly:一个github上的项目，比matplotlib好看</p><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="创建numpy数组"><a href="#创建numpy数组" class="headerlink" title="创建numpy数组"></a>创建numpy数组</h3><pre><code class="python">import numpy as npt1=np.array([1,2,3])print(t1)print(type(t1))#[1 2 3]#&lt;class &#39;numpy.ndarray&#39;&gt;t2 = np.array(range(10))print(t2)t3 = np.arange(10)print(t3)#效果一样#[0 1 2 3 4 5 6 7 8 9]print(t3.dtype)#int32t3.dtype=floatprint(t3.dtype)#float64t4=np.array([rd.random() for i in range(10)])print(t4)print(t4.dtype)#[0.06217892 0.51319594 0.84344407 0.14711661 0.03576193 0.48263391#0.79937126 0.49026005 0.43495258 0.8738894 ]#float64print(np.round(t4,2))print(t4.dtype)#取两位#[0.99 0.76 0.46 0.78 0.32 0.33 0.   0.56 0.89 0.66]#float64</code></pre><h3 id="numpy数组操作"><a href="#numpy数组操作" class="headerlink" title="numpy数组操作"></a>numpy数组操作</h3><h4 id="改变形状"><a href="#改变形状" class="headerlink" title="改变形状"></a>改变形状</h4><pre><code class="python">import numpy as npimport random as rdt1=np.arange(12)print(t1.shape)t2=np.array([[1,2,3],[3,4,5]])print(t2.shape)#查看形状#修改形状t3=np.arange(12)t4=t3.reshape((3,4))print(t4)#改变形状，注意这里改变形状不对原数组进行改变,原地操作</code></pre><p>注意这里的shape</p><p>(24,)与（24,1）是不一样的，前者的1个24行向量，后者是24个1列向量</p><p>以下是操作：</p><ul><li>t.shape[0]  t.shape[1]分别是行数和列数</li><li>t.flatten()数组降维一维</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>nan:不是一个数字</p><p>INF:无穷</p><ul><li>点加减: t1+2</li><li>点乘除：t1*2</li><li>矩阵相加减：t1+t2（若不符合矩阵运算，某一维度相同时可以计算，效果类似点加减，广播原则）</li><li>矩阵相乘除：t1*t2(以上要符合矩阵运算规律)</li></ul><p>具体查csdn</p><h3 id="numpy读取文件"><a href="#numpy读取文件" class="headerlink" title="numpy读取文件"></a>numpy读取文件</h3><p>现在这里有一个英国和美国各自youtube1000多个视频的点击,喜欢,不喜欢,评论数量([“views”,”likes” , “dislikes”,” comment total”])的csv,运用刚刚所学习的只是,我们尝试来对其进行操作</p><p><a href="https://www.kaggle.com/datasnaek/youtube/data">数据来源</a></p><h3 id="切片索引操作"><a href="#切片索引操作" class="headerlink" title="切片索引操作"></a>切片索引操作</h3><p>见blog</p><p><a href="https://blog.csdn.net/liujian20150808/article/details/81273289?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941748916780299054215%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160941748916780299054215&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-81273289.pc_search_result_cache&utm_term=numpy%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C">numpy切片索引操作</a></p><p>或者bilibili视频</p><h3 id="数据拼接"><a href="#数据拼接" class="headerlink" title="数据拼接"></a>数据拼接</h3><p><a href="https://blog.csdn.net/qq_39516859/article/details/80666070?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941769016780277095641%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160941769016780277095641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-80666070.pc_search_result_cache&utm_term=numpy%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5">数组拼接</a></p><h3 id="好的参考blog"><a href="#好的参考blog" class="headerlink" title="好的参考blog"></a>好的参考blog</h3><p><a href="https://blog.csdn.net/weixin_45651336/article/details/111408557?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-2&spm=1001.2101.3001.4242">blog1</a></p><p><a href="https://blog.csdn.net/a373595475/article/details/79580734?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160941798816780310237261%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160941798816780310237261&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~hot_rank-1-79580734.pc_v1_rank_blog_v1&utm_term=numpy%E6%93%8D%E4%BD%9C">blog2</a></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;numpy-matplotlib-pandas以及文件批量操作&quot;&gt;&lt;a href=&quot;#numpy-matplotlib-pandas以及文件批量操作&quot; class=&quot;headerlink&quot; title=&quot;numpy,matplotlib,pandas以及文件批量操</summary>
      
    
    
    
    <category term="machine learning" scheme="http://sweetheart.nefu.site/categories/machine-learning/"/>
    
    
    <category term="machine learning" scheme="http://sweetheart.nefu.site/tags/machine-learning/"/>
    
    <category term="numpy" scheme="http://sweetheart.nefu.site/tags/numpy/"/>
    
    <category term="pandas" scheme="http://sweetheart.nefu.site/tags/pandas/"/>
    
    <category term="matplotlib" scheme="http://sweetheart.nefu.site/tags/matplotlib/"/>
    
    <category term="文件批量操作" scheme="http://sweetheart.nefu.site/tags/%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>matlab基础使用(更新中)</title>
    <link href="http://sweetheart.nefu.site/2020/08/15/matlab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://sweetheart.nefu.site/2020/08/15/matlab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-15T14:01:13.000Z</published>
    <updated>2020-08-28T06:45:10.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab基础使用"><a href="#Matlab基础使用" class="headerlink" title="Matlab基础使用"></a>Matlab基础使用</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>和之前那篇不同的是，这篇文章记录了matlab基础使用的方法，总共也就那么几个部分</p><ul><li>向量运算</li><li>多项式运算</li><li>矩阵运算</li><li>符号运算</li><li>数列求和与函数极限与导数操作</li><li>函数积分</li><li>方程求解</li><li>微分方程//曲线方程</li><li>拟合插值（这个我更倾向于excel）</li><li>程序设计</li><li>二维绘图</li><li>三维绘图</li></ul><p>大概基础就这么多了，之前知识都是散的于是来个汇总。真·边复习高数线代边用matlab解高数线代题。</p><h2 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h2><p>向量：行矩阵列矩阵，秩数为1</p><h3 id="向量创建"><a href="#向量创建" class="headerlink" title="向量创建"></a>向量创建</h3><ul><li>直接创建：a=[1,2,3,4]</li><li>步距创建：a=1:4</li><li>函数生成：a=linspace(0,10,6),从0到10共六个数的向量,自动求步距</li><li>对数分割：a=logspace(1,3,3),表示三个数，10的1次到10的3次</li></ul><h4 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h4><pre><code>- 加法- 减法- 数乘- 求内积：dot(a，b)- 求外积：cross(a,b)- 混合积：dot(a,cross(b,c))</code></pre><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><h3 id="单元型变量"><a href="#单元型变量" class="headerlink" title="单元型变量"></a>单元型变量</h3><ul><li>类似于结构体</li><li>cell来表示，排列方式又类似于矩阵</li></ul><h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><ul><li>struct创建</li><li>要求键值对对应：struct(‘a’,{A});</li></ul><h2 id="多项式操作"><a href="#多项式操作" class="headerlink" title="多项式操作"></a>多项式操作</h2><h4 id="多项式创建"><a href="#多项式创建" class="headerlink" title="多项式创建"></a>多项式创建</h4><ul><li>直接创建：’ax+bx^n’</li><li>向量加函数创建：ploy2sym(p)，p中元素按照顺序分别为n次到0次的系数</li></ul><h4 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h4><ul><li>乘法：conv(a,b),ab分别为向量</li><li>除法：decov(a,b),同上</li></ul><h4 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h4><p>​    步骤：</p><pre><code>- 先向量创建成多项式符号函数- 利用polyder()给多项式求导，得出导数的系数向量- 然后在系数向量创建</code></pre><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><p>基础操作：</p><h3 id="矩阵创建："><a href="#矩阵创建：" class="headerlink" title="矩阵创建："></a>矩阵创建：</h3><ul><li>rand()</li><li>zeros()</li><li>ones()</li><li>eye()</li></ul><p>主要就是这些</p><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul><li>删除元素：将某一行设置为空列表，例如：a(m;:)=[]</li><li>元素赋值，a(m,n)=b</li><li>组合矩阵</li></ul><h4 id="变维变向抽取"><a href="#变维变向抽取" class="headerlink" title="变维变向抽取"></a>变维变向抽取</h4><ul><li>变维：reshape():根据顺序以列的顺序上下重排元素</li><li>变向：翻转，基本上不用</li><li>抽取元素：<ul><li>diag()</li><li>tril()，下三角</li><li>triu(),上三角</li></ul></li></ul><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><ul><li>加法</li><li>减法</li><li>数乘</li><li>乘法</li><li>点乘，A.*B</li><li>除法，记得区分左除\和一般除法/（右除）</li><li>幂运算:A^n,  A.^n</li><li>求逆：inv(A)，pinv(A)</li><li>求秩：rank(A)</li><li>转置：s’</li><li>求行列式det(C)</li></ul><h2 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a>符号运算</h2><h3 id="符号与数值转换"><a href="#符号与数值转换" class="headerlink" title="符号与数值转换"></a>符号与数值转换</h3><ul><li><p>sym():数值转换成分数</p></li><li><p>eval():分数转化为小数（同时也可以用vpa()对某个表达式求数值解）</p></li><li><p>设置表达式数值精度：digits(D)//d为有效数字个数-&gt;vpa(s)或者vpa(s,d)</p></li></ul><h3 id="符号创建"><a href="#符号创建" class="headerlink" title="符号创建"></a>符号创建</h3><ul><li>x=sym(‘x’)创建符号变量</li><li>syms x 进行定义</li><li>矩阵创建sym(‘a’,n);</li></ul><h3 id="数值带入表达式"><a href="#数值带入表达式" class="headerlink" title="数值带入表达式"></a>数值带入表达式</h3><ul><li>sub(f，x,c)：f为表达式，x是变量，c是数值</li></ul><h3 id="符号运算-1"><a href="#符号运算-1" class="headerlink" title="符号运算"></a>符号运算</h3><ul><li>因式分解：factor(f)：f是表达式，或者用sym()转化的数值，转化为质数乘积表达式</li><li>幂函数展开：expand(f):比如展开x（x+1)</li><li>求通分后的分子分母：[n，m]=numden(F)，n是分子，m是分母</li></ul><h2 id="数列求和求积与函数极限与导数操作与级数求和"><a href="#数列求和求积与函数极限与导数操作与级数求和" class="headerlink" title="数列求和求积与函数极限与导数操作与级数求和"></a>数列求和求积与函数极限与导数操作与级数求和</h2><h3 id="数列求和"><a href="#数列求和" class="headerlink" title="数列求和"></a>数列求和</h3><h4 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h4><ul><li>sum(1:n)返回1到n的累加和</li><li>sun（a),a是矩阵，返回各个列的累加和，结果组成行矩阵</li><li>sum(a,1or2),1表示不求和，2表示求和结果等于原来数列的和，若a是矩阵，啧1对列求和2对行求和</li><li>nansum(),忽略累加中的nan</li></ul><h4 id="cumsum"><a href="#cumsum" class="headerlink" title="cumsum"></a>cumsum</h4><ul><li>求该元素前的累积和加上该元素的和</li></ul><h3 id="数列求积-数值求和"><a href="#数列求积-数值求和" class="headerlink" title="数列求积(数值求和)"></a>数列求积(数值求和)</h3><h4 id="prod"><a href="#prod" class="headerlink" title="prod"></a>prod</h4><ul><li>用法同sum,但是是求积</li></ul><h4 id="cumprod"><a href="#cumprod" class="headerlink" title="cumprod"></a>cumprod</h4><ul><li>用法同cumsum，但是求积</li></ul><h3 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h3><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>默认求极小值</p><p>使用步骤：</p><p>1.定义变量syms x</p><p>2.带入limit(f,范围)，例子：limit((1+1/n)^n,inf)</p><p><strong>多元求极限</strong>：</p><p>syms x y</p><p>f=(exp(x+exp(y))/(cos(x)-sin(y))</p><p>limit(limit(f,x,0),y,0)</p><h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>diff(f,x,n):求f函数关于x的n阶数导</p><p>diff(f，n):求n阶导数</p><p>可知可以通过这种方式求偏导</p><h3 id="级数求和（符号求和）"><a href="#级数求和（符号求和）" class="headerlink" title="级数求和（符号求和）"></a>级数求和（符号求和）</h3><h4 id="symsum"><a href="#symsum" class="headerlink" title="symsum"></a>symsum</h4><ul><li>symsum（f，x,a,b),f关于x从a到b的所有和</li><li>结果用vpa()转换</li><li>无穷级数symsum(f,0,inf)表示，结果用vpa转换</li></ul><h2 id="函数积分"><a href="#函数积分" class="headerlink" title="函数积分"></a>函数积分</h2><h3 id="定积分和不定积分"><a href="#定积分和不定积分" class="headerlink" title="定积分和不定积分"></a>定积分和不定积分</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><ul><li>int(f,x,a,b):求f关于x在a到b上的定积分，然后用vpa表示数值</li><li>int(f,x,0,inf):求反常积分</li><li>不定积分就相对于定积分少一个范围参数</li></ul><h3 id="重积分"><a href="#重积分" class="headerlink" title="重积分"></a>重积分</h3><h4 id="dblquad（二重积分求解快捷方式）"><a href="#dblquad（二重积分求解快捷方式）" class="headerlink" title="dblquad（二重积分求解快捷方式）"></a>dblquad（二重积分求解快捷方式）</h4><ul><li><p>dblquad(f,xm,xM,ym,yM)</p><p>或者也可以用int来求解,int（）通过调换参数可以实现多元积分</p></li></ul><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><h4 id="taylor"><a href="#taylor" class="headerlink" title="taylor()"></a>taylor()</h4><ul><li>taylor(f,m,a),求f以x0=a，的情况下的m阶泰勒展开，当a舍去的时候，求麦克劳林展开</li><li>taylor(f,’order’,n)求n阶麦克劳林展开</li></ul><h4 id="傅里叶展开"><a href="#傅里叶展开" class="headerlink" title="傅里叶展开"></a>傅里叶展开</h4><h4 id="Fourierzpi"><a href="#Fourierzpi" class="headerlink" title="Fourierzpi()"></a>Fourierzpi()</h4><ul><li>[a0,an,bn]=Fourierzpi(f)直接出表达式</li></ul><h2 id="方程求解"><a href="#方程求解" class="headerlink" title="方程求解"></a>方程求解</h2><h3 id="线性方程求解"><a href="#线性方程求解" class="headerlink" title="线性方程求解"></a>线性方程求解</h3><ul><li><p>除法求解：（当解唯一时）</p><p>​    X=A\B 注意是左除即左乘上A的逆矩阵</p></li><li><p>求齐次通解：</p><p>​    1 判断是否是：唯一解，无穷解，有解</p><p>​    2 null函数求通解：X=null(A,’r’),A是齐次方程的系数矩阵，’r’表示有理数形式返回</p></li><li><p>求非齐次通解：</p><p>​    1 先用伪逆求特解：x0=pinv(A)*B,不用A满秩</p><p>​    2 然后求同届 null(A,’r’);</p></li><li><p>将增广矩阵化为行阶梯型，求行阶梯型矩阵，</p><p>​    1x=rref(AB);AB是增广矩阵</p><p>​    2解为曾广矩阵最后一列</p></li></ul><h3 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h3><ul><li>x=fzero(f,x0)</li></ul><h3 id="非线性方程组求解"><a href="#非线性方程组求解" class="headerlink" title="非线性方程组求解"></a>非线性方程组求解</h3><ul><li>x=fsolve(f,x0)</li></ul><h2 id="微分方程求解"><a href="#微分方程求解" class="headerlink" title="微分方程求解"></a>微分方程求解</h2><ul><li><p>dsolve</p><ul><li><p>示例：</p><p>y=dsolve(‘(Dy)^2-x*Dy+y=0’,’x);</p></li></ul></li></ul><h3 id="微分方程求特解"><a href="#微分方程求特解" class="headerlink" title="微分方程求特解"></a>微分方程求特解</h3><p>示例：y=dsolve(‘(D2y)*x-5Dy=-x^3’,’y(1)=0,y(5)=0’,x)</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>建议excel</p><h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><h3 id="polyfit"><a href="#polyfit" class="headerlink" title="polyfit"></a>polyfit</h3><p>y=polyfit(x,y,n),用<strong>n阶多项式</strong>来拟合x，y数据</p><p>注意，最后呈现的不是一个曲线形式而是求出一个多项式的系数向量；</p><h3 id="linefit"><a href="#linefit" class="headerlink" title="linefit"></a>linefit</h3><p>顾名思义，直线拟合，基于最小二乘法</p><p>[k,b]=linefit(x,y),求出系数和截距</p><p>然后用y1=polyval([k,b],x);生成多项式函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Matlab基础使用&quot;&gt;&lt;a href=&quot;#Matlab基础使用&quot; class=&quot;headerlink&quot; title=&quot;Matlab基础使用&quot;&gt;&lt;/a&gt;Matlab基础使用&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;head</summary>
      
    
    
    
    <category term="数学建模" scheme="http://sweetheart.nefu.site/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="matlab" scheme="http://sweetheart.nefu.site/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>蒟蒻的matlab实战笔记（更新中）</title>
    <link href="http://sweetheart.nefu.site/2020/08/15/%E8%92%9F%E8%92%BB%E7%9A%84matlab%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://sweetheart.nefu.site/2020/08/15/%E8%92%9F%E8%92%BB%E7%9A%84matlab%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-15T10:05:04.000Z</published>
    <updated>2020-08-15T18:09:59.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab-实战笔记"><a href="#Matlab-实战笔记" class="headerlink" title="Matlab 实战笔记"></a>Matlab 实战笔记</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>暑假为了参加国赛学习了matlab（白给的可能性比较大毕竟第一次参加比赛还撞上开学考试），看了也快有半月多一点了，之前基本上就是看书，会了点线性规划图论微分方程积分等等，然而实践出真知，具体问题还得具体分析。于是从今天起开始对着那本黄书上的案例（数学建模算法与应用）大致复现一遍，顺便做些课后题目，希望能有所收获（事实证明这玩意突然就实战真的能把人搞自闭，走一步是一步），并且配合excel（用这个画图或者进行曲线拟合）进行。</p><p>​    需要：</p><ul><li>Matlab2018b</li><li>《数学建模算法与应用》</li><li>《matlab从入门到精通》</li><li>交流群嫖来的代码</li><li>CSDN解答</li></ul><p>​    那么现在就开始叭</p><h2 id="DAY-1-线性规划-整数规划-非线性规划"><a href="#DAY-1-线性规划-整数规划-非线性规划" class="headerlink" title="DAY 1 线性规划/整数规划/非线性规划"></a>DAY 1 线性规划/整数规划/非线性规划</h2><h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><h4 id="linprog函数"><a href="#linprog函数" class="headerlink" title="linprog函数"></a>linprog函数</h4><p>linprog是求解线性规划的重要函数</p><p>求解线性规划的函数：</p><p>​    <img src="http://pan-yz.chaoxing.com/preview/showpreview_501461499312701440.html?v=1597487340000" alt="求解所用的linprog函数"></p><p>关于lingprog的一些注意事项：</p><ul><li><p>求解结果是线性最小值<strong>当求最大值时一定要把系数为负！！！</strong></p><ul><li><p>f是多元一次线性式的系数（当未知数矩阵是行矩阵，注意是列矩阵）<strong>同时这要求当求max时对应y变为负</strong></p></li><li><p>A是不等式的系数矩阵</p></li><li><p>b是不等式的常数项矩阵</p></li><li><p>要求不等式是小于等于关系<strong>大于等于关系时时对应系数变为负数转换成小于等于</strong>；</p></li><li><p>Aeq和beq是等式约束；</p></li><li><p>lb是各变量下限，要求为列矩阵，ub是上限也是列矩阵；</p></li><li><p>当无某一项约束时，用空矩阵[]代替</p><p>以下为代码案例</p><pre><code>&gt;&gt; clear all&gt;&gt; f=[2;3;1];&gt;&gt; a=[1,4,2;3,2,0];&gt;&gt; a=[-1,-4,-2;-3,-2,0];&gt;&gt; b=[-8;-6];&gt;&gt; [x,y]=linprog(f,a,b,[],[],zeros(3,1));Optimal solution found.//说明运行成功&gt;&gt; x,yx =   2.0000        0   3.0000</code></pre></li></ul></li></ul><p>   y =</p><pre><code>    7</code></pre><p>   ```</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>   编写函数要：</p><ul><li>文件名要和函数名字一样；</li><li>函数要以end结尾；</li><li>工程文件要和函数文件在同一个文件夹下</li></ul><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><h4 id="intlinprog"><a href="#intlinprog" class="headerlink" title="intlinprog"></a>intlinprog</h4><p>​    这是解整数规划的函数使用方法和linprog一样；</p><p>​    <img src="http://imageproxy.chaoxing.com/0x0,q15,jpeg,suFgohD7APLCb6Cke59_2e4xL3xgbs2RgrOVhoeo1w18/http://p.ananas.chaoxing.com/star3/origin/ec92e0ecd6278c84a24712d5c0c59365.png" alt="intlinprog"></p><p>不同的是，整数规划多了限制参数；</p><h3 id="非线性整数规划"><a href="#非线性整数规划" class="headerlink" title="非线性整数规划"></a>非线性整数规划</h3><p><img src="http://pan-yz.chaoxing.com/preview/showpreview_501489184993955840.html?v=1597493941000" alt="当你线性规划用多项式的时候"></p><p>​    很显然，多了函数入口；</p><p>​    使用方法：</p><p>​    <img src="http://pan-yz.chaoxing.com/preview/showpreview_501490501555433472.html?v=1597494257000" alt="使用示例"></p><p>注意函数名要加单引号；</p><h2 id="day2约束问题-图论"><a href="#day2约束问题-图论" class="headerlink" title="day2约束问题/图论"></a>day2约束问题/图论</h2><p>也就是图论开始，我意识到我作为编程手做的最大也就是嫖到算法和函数后套上模型罢了</p><p>只有离散只考了人均水平的垃圾硬看算法看了半天愣是看不出什么所以然，然而事实证明还是matlab的强大的，有现成的图论工具箱，往上套就可以了。</p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Matlab-实战笔记&quot;&gt;&lt;a href=&quot;#Matlab-实战笔记&quot; class=&quot;headerlink&quot; title=&quot;Matlab 实战笔记&quot;&gt;&lt;/a&gt;Matlab 实战笔记&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;</summary>
      
    
    
    
    <category term="数学建模" scheme="http://sweetheart.nefu.site/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="matlab" scheme="http://sweetheart.nefu.site/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>这是一篇关于创建博客的吐槽（持续更新中）</title>
    <link href="http://sweetheart.nefu.site/2020/08/13/something-about-blog/"/>
    <id>http://sweetheart.nefu.site/2020/08/13/something-about-blog/</id>
    <published>2020-08-13T07:56:42.000Z</published>
    <updated>2020-08-25T16:40:06.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一篇关于创建博客的吐槽"><a href="#这是一篇关于创建博客的吐槽" class="headerlink" title="这是一篇关于创建博客的吐槽"></a>这是一篇关于创建博客的吐槽</h1><p>​    搭了自己第一个博客，过程也算顺利，但还是有不少想吐槽的。</p><p>​    对了，右下角是音乐设置，嫌吵可以调小或者关掉。</p><h2 id="关于github"><a href="#关于github" class="headerlink" title="关于github"></a>关于github</h2><p>​    用github部署的麻烦也不少：</p><h3 id="速度慢"><a href="#速度慢" class="headerlink" title="速度慢"></a>速度慢</h3><p>​    首先是速度，真的好慢啊，从第一篇blog上传完成到全部显示出来，隔了很久，毕竟网站架设在国外，个人博客还是建议搭在gitee上。</p><h3 id="域名会被清掉"><a href="#域名会被清掉" class="headerlink" title="域名会被清掉"></a>域名会被清掉</h3><p>​    每次我hexo d后，也就是上传一篇文章或者对网站进行改动后重新部署到github上（这个过程也慢），设置的域名都会被清掉,导致访问出现404,需要重新在设置里面输入域名，太繁琐了。</p><p>​    如果有好的解决方法欢迎分享鸭</p><h2 id="自己踩过的一些坑"><a href="#自己踩过的一些坑" class="headerlink" title="自己踩过的一些坑"></a>自己踩过的一些坑</h2><h3 id="不要乱改配置文件"><a href="#不要乱改配置文件" class="headerlink" title="不要乱改配置文件"></a>不要乱改配置文件</h3><p>​    <del>为了追求刺激</del>为了美观实用，把matery的_config.yml文件改得面目全非，结果美观的目的是达到了，但生成的index.html打开是空的,也就是上传的博客文章打开只有空白网页（泪目）。查了下也不是路径的问题，就是不知道乱动了哪里导致生成空白网页（可能是留言板那的设置），估摸着估计是找不到原因了，于是单独重下matery的config.yml文件，然后不乱改了，问题解决。</p><h3 id="部署后404"><a href="#部署后404" class="headerlink" title="部署后404"></a>部署后404</h3><p>​    主要原因还是每次更新到github设置的域名都会被清掉，重新设置后就解决了，但是真的好麻烦啊。</p><h3 id="首页图片被覆盖的颜色太浓"><a href="#首页图片被覆盖的颜色太浓" class="headerlink" title="首页图片被覆盖的颜色太浓"></a>首页图片被覆盖的颜色太浓</h3><p>​    改matery主题的source文件夹下的matery.css</p><p>​    具体是这三个：</p><pre><code class="kotlin">   /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &amp;#123;    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&amp;#125;@-webkit-keyframes rainbow &amp;#123;   /* 动态切换背景颜色. */&amp;#125;@keyframes rainbow &amp;#123;    /* 动态切换背景颜色. */&amp;#125;</code></pre><h3 id="关于markdown笔记无法加载"><a href="#关于markdown笔记无法加载" class="headerlink" title="关于markdown笔记无法加载"></a>关于markdown笔记无法加载</h3><pre><code>title: “something_about_blogdate: 2020-08-13 15:56:42tags: [技术总结, 吐槽, 避雷]categories: 杂谈</code></pre><p>这是这篇文章markdown的设置，注意：</p><ul><li>每个设置之后都与内容有一个空格隔开，不然会报错，</li><li>tag列表里面每个逗号后面都要有空格，不然也会报错</li></ul><h2 id="待实现的功能"><a href="#待实现的功能" class="headerlink" title="待实现的功能"></a>待实现的功能</h2><p>先记下来有时间做下</p><ul><li>首页图片实现轮播</li><li>每个文章的封面都是一样的</li><li>留言板</li><li>字数统计</li></ul><hr><p>大概就这些了</p><h2 id="8月15日更新"><a href="#8月15日更新" class="headerlink" title="8月15日更新"></a>8月15日更新</h2><ul><li><p>通过在sourse文件夹下添加了写入域名的CNAME文件，解决了部署后域名失效的问题</p></li><li><p>通过调整hexo-theme-matery\layout_partial下的bg-cover-content.ejs文件，成功将首页图变成了刷新一次切换一次</p><p>代码如下：</p></li></ul><pre><code>&lt;script&gt;    // 每天切换 banner 图.  Switch banner image every day.    var bannerUrl = &quot;&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for(&#39;/medias/banner/&#39;) %&gt;&quot; + (new Date().getSeconds())%7 + &#39;.jpg&#39;;    //把getDay（）改成getSecond（）并且对7取余数(因为只有七张图片，如果有多张可以对图片数取余)    $(&#39;.bg-cover&#39;).css(&#39;background-image&#39;, &#39;url(&#39; + bannerUrl + &#39;)&#39;);&lt;/script&gt;</code></pre><ul><li>添加了点击就推荐奶茶的特效（其实还整了烟花特效但真的太花了还是少点特效好）</li><li>去掉了首页图的滤镜特效，（太难看了www为什么开发者要这么设置，明明审美也不差）</li><li>完善了友链</li><li>超星网盘当图床是真的香啊</li><li>开启了背景动态图</li><li>修改了首页栏的透明度</li><li>去掉了音乐（这玩意太吵了，自己都看不下去了）</li></ul><h2 id="8月25日更新"><a href="#8月25日更新" class="headerlink" title="8月25日更新"></a>8月25日更新</h2><ul><li>实现了留言板功能，然而目前好像不支持markdown格式</li><li>迷上了小林家的龙女仆，修改了首页，（康娜托尔suki!)</li></ul><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一篇关于创建博客的吐槽&quot;&gt;&lt;a href=&quot;#这是一篇关于创建博客的吐槽&quot; class=&quot;headerlink&quot; title=&quot;这是一篇关于创建博客的吐槽&quot;&gt;&lt;/a&gt;这是一篇关于创建博客的吐槽&lt;/h1&gt;&lt;p&gt;​    搭了自己第一个博客，过程也算顺利，但还是有</summary>
      
    
    
    
    <category term="杂谈" scheme="http://sweetheart.nefu.site/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="总结" scheme="http://sweetheart.nefu.site/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="避雷" scheme="http://sweetheart.nefu.site/tags/%E9%81%BF%E9%9B%B7/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇blog</title>
    <link href="http://sweetheart.nefu.site/2020/08/13/my_first_blog/"/>
    <id>http://sweetheart.nefu.site/2020/08/13/my_first_blog/</id>
    <published>2020-08-13T03:29:30.000Z</published>
    <updated>2020-08-16T18:54:57.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇blog"><a href="#我的第一篇blog" class="headerlink" title="我的第一篇blog"></a>我的第一篇blog</h1><h2 id="大概是心路历程？"><a href="#大概是心路历程？" class="headerlink" title="大概是心路历程？"></a>大概是心路历程？</h2><p>​    大概在期中的时候就想着要不做一个自己的blog叭，里面放些日常，自己画的画，技术总结（或许还有秀恩爱？）然后在B站搜索blog搭建从入门到精通之类的balalabala。emmmmm，白嫖党看见要花钱注册域名买服务器就不想动了，反正也只是想搭着玩没什么大用处，还不如在QQ空间微博CSDN里面BB。后来了解到可以将blog部署在github便有了兴趣，然而由于懒一直没动，下次一定下次一定。</p><p>​    恰巧在前几天刷b站正好看见一个搭建的视频（保姆级），挺喜欢这个hexo主题，于是便捣鼓出来了这个基于hexo的matery个人blog。搭建完改了改，换上了自己在推特上收集的各种图片（老二次元了）。域名是ht给的，当然他一开始给的非常屑，不过现在的我很满意。这个主题居然还有打赏的功能，i了i了，但还有一些功能没有实现，比如好友评论，有时间做一下。</p><p>​    音乐在右下角，嫌弃吵可以调小点</p><p>​    没了没了</p><hr><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><h3 id="视频和文档"><a href="#视频和文档" class="headerlink" title="视频和文档"></a>视频和文档</h3><p>​    blog搭建的视频地址：</p><p>​    <a href="https://www.bilibili.com/video/BV1je41147Ma">bilibili保姆级基于hexo框架的建站视频</a>  </p><p>​    感谢up的博客提供的支持：</p><p>​    <a href="https://rika0-0.github.io/">up的技术博客</a></p><h3 id="需要："><a href="#需要：" class="headerlink" title="需要："></a>需要：</h3><ul><li><p>一个github账号</p></li><li><p>nodejs环境</p></li><li><p>git环境</p></li><li><p>html css js基础（后期diy需要）</p></li><li><p>markdown语法基础（建议VSCode or Typora编辑器）</p></li><li><p><del>一个提供虐狗域名的npy</del></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的第一篇blog&quot;&gt;&lt;a href=&quot;#我的第一篇blog&quot; class=&quot;headerlink&quot; title=&quot;我的第一篇blog&quot;&gt;&lt;/a&gt;我的第一篇blog&lt;/h1&gt;&lt;h2 id=&quot;大概是心路历程？&quot;&gt;&lt;a href=&quot;#大概是心路历程？&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="web" scheme="http://sweetheart.nefu.site/tags/web/"/>
    
    <category term="html" scheme="http://sweetheart.nefu.site/tags/html/"/>
    
    <category term="css" scheme="http://sweetheart.nefu.site/tags/css/"/>
    
    <category term="markdown" scheme="http://sweetheart.nefu.site/tags/markdown/"/>
    
  </entry>
  
</feed>
